var documenterSearchIndex = {"docs":
[{"location":"basics/bath.html#Bath","page":"Bath","title":"Bath","text":"","category":"section"},{"location":"basics/bath.html","page":"Bath","title":"Bath","text":"We start with a general form of the system-bath interaction Hamiltonian","category":"page"},{"location":"basics/bath.html","page":"Bath","title":"Bath","text":"  H_SB = sum_alpha S_alphaotimes B_alpha","category":"page"},{"location":"basics/bath.html","page":"Bath","title":"Bath","text":"and define each B_alpha (together with the bath Hamiltonian H_B) as an AbstractBath object. An important property of any bath is its two-point correlation function","category":"page"},{"location":"basics/bath.html","page":"Bath","title":"Bath","text":"  C(t_1 t_2) = langle mathcalB(t_1) mathcalB(t_2) rangle","category":"page"},{"location":"basics/bath.html","page":"Bath","title":"Bath","text":"where","category":"page"},{"location":"basics/bath.html","page":"Bath","title":"Bath","text":"  mathcalB(t) = U_B^dagger (t) B U_B(t)","category":"page"},{"location":"basics/bath.html","page":"Bath","title":"Bath","text":"and U_B(t) is the unitary generated by the pure bath Hamiltonian","category":"page"},{"location":"basics/bath.html","page":"Bath","title":"Bath","text":"  U_B(t) = mathcalTexpBig -iint_0^t H_B mathrmdtau Big","category":"page"},{"location":"basics/bath.html","page":"Bath","title":"Bath","text":"The spectral density of the bath is defined as the Fourier transform of the two-point correlation function and is denoted as gamma(omega) in OpenQuantumTools. It is important to note that only for a Gaussian bath (whose higher order correlations satisfy Wick's Theorem) does the two-point correlation function uniquely determine the bath. Otherwise, high-order correlation functions are necessary. Nevertheless, we only deal with the two-point correlation function in OpenQuantumTools.","category":"page"},{"location":"basics/bath.html","page":"Bath","title":"Bath","text":"Currently, there are two built-in concrete types of the AbstractBath class – OhmicBath and HybridOhmicBath.","category":"page"},{"location":"basics/bath.html#Ohmic-Bath","page":"Bath","title":"Ohmic Bath","text":"","category":"section"},{"location":"basics/bath.html","page":"Bath","title":"Bath","text":"A self-consistent reference for the Ohmic bath is [1] Quantum adiabatic markovian master equations. Users can use Ohmic function to construct OhmicBath object:","category":"page"},{"location":"basics/bath.html","page":"Bath","title":"Bath","text":"η = 1e-4; fc=4; T=16\nbath = Ohmic(η, fc, T);","category":"page"},{"location":"basics/bath.html","page":"Bath","title":"Bath","text":"The correlation and spectral density of the bath object can be calculated via","category":"page"},{"location":"basics/bath.html","page":"Bath","title":"Bath","text":"correlation(τ, bath)\nspectrum(ω, bath)","category":"page"},{"location":"basics/bath.html","page":"Bath","title":"Bath","text":"This interface is true for every concrete type of AbstractBath. However, plotting works differently for different bath models. For OhmicBath, the user can use","category":"page"},{"location":"basics/bath.html","page":"Bath","title":"Bath","text":"ω = range(0, 20, length=200)\nplot(bath, :γ, ω)\nplot(bath, :S, ω)","category":"page"},{"location":"basics/bath.html","page":"Bath","title":"Bath","text":"to conveniently plot the spectral density and the S function in the Lamb shift terms.","category":"page"},{"location":"basics/bath.html","page":"Bath","title":"Bath","text":"(Image: plot_ohmic_spectrum) (Image: plot_ohmic_lamb)","category":"page"},{"location":"basics/bath.html#Hybrid-Ohmic-Bath","page":"Bath","title":"Hybrid Ohmic Bath","text":"","category":"section"},{"location":"basics/bath.html","page":"Bath","title":"Bath","text":"Details of the hybrid ohmic bath model are discussed in [2] Probing high-frequency noise with macroscopic resonant tunneling and [3] Theory of open quantum dynamics with hybrid noise. The core idea is to assume the noise spectrum can be split into low-frequency and high-frequency parts","category":"page"},{"location":"basics/bath.html","page":"Bath","title":"Bath","text":"  gamma(omega) = gamma_L(ω) + gamma_H(ω)","category":"page"},{"location":"basics/bath.html","page":"Bath","title":"Bath","text":"The high-frequency spectrum gamma_H(ω) comes from the Ohmic bath and the low frequency spectrum gamma_L(ω) can be interpreted as an approximation of 1f noise. A benefit of this formalism is that instead of the entire spectral density, gamma_L(omega) can be parametrized by a single parameter in a macroscopic resonant tunneling (MRT) experiment. To construct a HybridOhmicBath object, run the following command:","category":"page"},{"location":"basics/bath.html","page":"Bath","title":"Bath","text":"η = 1e-4; fc=4; T=16; W=10\nbath = HybridOhmic(W, η, fc, T)","category":"page"},{"location":"basics/bath.html#Spin-fluctuator","page":"Bath","title":"Spin-fluctuator","text":"","category":"section"},{"location":"basics/bath.html","page":"Bath","title":"Bath","text":"The spin-fluctuator model is a classical noise model for 1/f noise often found in superconducting qubits [4] 1/f noise: Implications for solid-state quantum information. It is a stochastic process generated by summing telegraph processes","category":"page"},{"location":"basics/bath.html","page":"Bath","title":"Bath","text":"sum_i=1^K n_i(t)  ","category":"page"},{"location":"basics/bath.html","page":"Bath","title":"Bath","text":"where n_i(s) is the telegraph process that switches randomly between pm b_i with a rate gamma_i and K is the total number of fluctuators. Such a noise model can be constructed using EnsembleFluctuator:","category":"page"},{"location":"basics/bath.html","page":"Bath","title":"Bath","text":"bvec = 0.2 * ones(10)\nγvec = log_uniform(0.01, 1, 10)\nfluctuator_ensemble = EnsembleFluctuator(bvec, γvec)","category":"page"},{"location":"basics/bath.html","page":"Bath","title":"Bath","text":"The above code block defines a 10-fluctuator ensemble whose b_i=02 and gamma_is are log-uniformly distributed within 001 1. More details about simulating stochastic Schrödinger with spin-fluctuator noise can be found in this tutorial.","category":"page"},{"location":"basics/solver.html#Solvers","page":"Solver","title":"Solvers","text":"","category":"section"},{"location":"basics/solver.html#Summary","page":"Solver","title":"Summary","text":"","category":"section"},{"location":"basics/solver.html","page":"Solver","title":"Solver","text":"OpenQuantumTools.jl provides the following solvers:","category":"page"},{"location":"basics/solver.html","page":"Solver","title":"Solver","text":"solve_schrodinger: Schrödinger equation solver;\nsolve_von_neumann: von Neumann equation solver;\nsolve_unitary: unitary solver;\nsolve_lindblad: Lindblad equation solver;\nsolve_redfield: Redfield equation solver;\nsolve_cgme: coarse-grained master equation solver ([1] Completely positive master equation for arbitrary driving and small level spacing);\nsolve_ule: universal Lindblad equation solver ([2] Universal Lindblad equation for open quantum systems);\nsolve_ame: adiabatic master equation solver ([3] Quantum adiabatic markovian master equations);\nbuild_ensembles: build EnsembleProblem for stochastic noise or quantum trajectories simulation.","category":"page"},{"location":"basics/solver.html#Solver-options","page":"Solver","title":"Solver options","text":"","category":"section"},{"location":"basics/solver.html","page":"Solver","title":"Solver","text":"Each solver in OpenQuantumTools has some algorithm-dependent options. Meanwhile, they also share some common options and inherit an even larger set of common arguments from DifferentialEquations universe. We summarize some of these options below:","category":"page"},{"location":"basics/solver.html#Common-solver-options","page":"Solver","title":"Common solver options","text":"","category":"section"},{"location":"basics/solver.html","page":"Solver","title":"Solver","text":"vectorize::Bool = false: For equations with a density matrix, this argument denotes whether to vectorize the equation.\ntspan = (0, tf): Denotes the time interval over which to solve the dynamics. This option is not supported for master equations (MEs) which require integrating over the previous dynamics, e.g., the Redfield equation, the CGME, and the ULE.","category":"page"},{"location":"basics/solver.html#Redfield/ULE/CGME","page":"Solver","title":"Redfield/ULE/CGME","text":"","category":"section"},{"location":"basics/solver.html","page":"Solver","title":"Solver","text":"unitary: This is a positional argument. The user needs to provide the precomputed or predefined unitary operator through this argument.\nTa: For solve_cgme, it denotes the coarse-graining time. If set to nothing, the solver will automatically choose the value. The default value is nothing. For solve_redfield and solve_ule, it denotes the integration region in their corresponding Liouville operator. The default value is tf.\nint_atol: The absolute error tolerance for the internal integration algorithm.\nint_rtol: The relative error tolerance for the internal integration algorithm.","category":"page"},{"location":"basics/solver.html#AME","page":"Solver","title":"AME","text":"","category":"section"},{"location":"basics/solver.html","page":"Solver","title":"Solver","text":"ω_hint=[]: Specifies a grid over which to precompute the S function in the Lamb shift term. The precomputation is skipped if it is empty.\nlambshift::Bool=true: Denotes whether to include the Lamb shift term in the simulation.\nlambshift_S=nothing: The user can provide a custom routine to calculate the S function in the Lamb shift term via this argument. \nlvl::Int=size(A.H, 1): The argument specifies the number of levels to keep in the simulation. Higher levels will be ignored to speed up the computation.\none_sided=false: It denotes whether to solve the one-sided AME or the Lindblad form.","category":"page"},{"location":"basics/solver.html#ODE-solver-options","page":"Solver","title":"ODE solver options","text":"","category":"section"},{"location":"basics/solver.html","page":"Solver","title":"Solver","text":"Extra keyword arguments kwargs are directly passed to the ODE solve interface. Every solver option in DifferentialEquations is supported. Several useful options are:","category":"page"},{"location":"basics/solver.html","page":"Solver","title":"Solver","text":"alg: This argument specifies the ODE algorithm to use. Users can find a list of the available solver algorithms here. The default option (Tsitouras 5/4 Runge-Kutta method) performs well for most problems. For equations with the density matrix, the implicit methods are only supported when vectorize is set to true.\nsave_everystep: Denotes whether to save the result at every step. Setting it to false can significantly reduce memory consumption when the problem size is large.\nsaveat: This argument denotes specific times to save the solution at, during the solution phase. It overrides the save_everystep argument. Saving only at a small number of points can also significantly reduce memory consumption when the problem size is large.\ntstops: Denotes extra times that the time-stepping algorithm must step to. It will increase the accuracy if the algorithm is instructed to step to the known singular points of the problem.\nabstol=1e-6: Absolute tolerance in adaptive time-stepping. This is the tolerance on local error estimates, not necessarily the global error (though these quantities are related). In real applications, it is usually chosen by trial and error. It needs to be small when the total evolution time is long.\nreltol=1e-3: Relative tolerance in adaptive time-stepping. This is the tolerance on local error estimates, not necessarily the global error (though these quantities are related). In real applications, it is usually chosen by trial and error. It needs to be small when the total evolution time is long.","category":"page"},{"location":"basics/solver.html#Examples","page":"Solver","title":"Examples","text":"","category":"section"},{"location":"basics/solver.html","page":"Solver","title":"Solver","text":"All the above solvers have detailed examples in HOQSTTutorial.jl.","category":"page"},{"location":"lib/coupling.html#Couplings","page":"Coupling","title":"Couplings","text":"","category":"section"},{"location":"lib/coupling.html#Constant-couplings","page":"Coupling","title":"Constant couplings","text":"","category":"section"},{"location":"lib/coupling.html","page":"Coupling","title":"Coupling","text":"ConstantCouplings\nConstantCouplings(mats::Union{Vector{Matrix{T}},Vector{SparseMatrixCSC{T,Int}}}; unit=:h) where {T<:Number}\nConstantCouplings(c::Vector{T}; sp = false, unit=:h) where T <: AbstractString\ncollective_coupling(op, num_qubit; sp = false, unit = :h)","category":"page"},{"location":"lib/coupling.html#OpenQuantumBase.ConstantCouplings","page":"Coupling","title":"OpenQuantumBase.ConstantCouplings","text":"struct ConstantCouplings <: OpenQuantumBase.AbstractCouplings\n\nDefines constant system bath coupling operators.\n\nFields\n\nmats\n1-D array for independent coupling operators\nstr_rep\nString representation for the coupling (for display purpose)\n\n\n\n\n\n","category":"type"},{"location":"lib/coupling.html#OpenQuantumBase.ConstantCouplings-Union{Tuple{Union{Array{Matrix{T}, 1}, Array{SparseMatrixCSC{T, Int64}, 1}}}, Tuple{T}} where T<:Number","page":"Coupling","title":"OpenQuantumBase.ConstantCouplings","text":"function ConstantCouplings(mats::Union{Vector{Matrix{T}},Vector{SparseMatrixCSC{T,Int}}}; unit=:h) where {T<:Number}\n\nConstructor of ConstantCouplings object. mats is 1-D array of matrices. str_rep is the optional string representation of the coupling terms. unit is the unit one – :h or :ħ. The mats will be scaled by 2π is unit is :h.\n\n\n\n\n\n","category":"method"},{"location":"lib/coupling.html#OpenQuantumBase.ConstantCouplings-Union{Tuple{Vector{T}}, Tuple{T}} where T<:AbstractString","page":"Coupling","title":"OpenQuantumBase.ConstantCouplings","text":"function ConstantCouplings(c::Vector{T}; sp = false, unit=:h) where T <: AbstractString\n\nIf the first argument is a 1-D array of strings. The constructor will automatically construct the matrics represented by the string representations.\n\n\n\n\n\n","category":"method"},{"location":"lib/coupling.html#OpenQuantumBase.collective_coupling-Tuple{Any, Any}","page":"Coupling","title":"OpenQuantumBase.collective_coupling","text":"function collective_coupling(op, num_qubit; sp = false, unit = :h)\n\nCreate ConstantCouplings object with operator op on each qubits. op is the string representation of one of the Pauli matrices. num_qubit is the total number of qubits. sp set whether to use sparse matrices. unit set the unit one – :h or :ħ.\n\n\n\n\n\n","category":"method"},{"location":"lib/coupling.html#Time-dependent-couplings","page":"Coupling","title":"Time dependent couplings","text":"","category":"section"},{"location":"lib/coupling.html","page":"Coupling","title":"Coupling","text":"TimeDependentCoupling\nTimeDependentCouplings","category":"page"},{"location":"lib/coupling.html#OpenQuantumBase.TimeDependentCoupling","page":"Coupling","title":"OpenQuantumBase.TimeDependentCoupling","text":"struct TimeDependentCoupling\n\nDefines a single time dependent system bath coupling operator. It is defined as S(s)=f(s)M.  Keyword argument unit set the unit one – :h or :ħ.\n\nFields\n\nfuncs\n1-D array of time dependent functions\nmats\n1-D array of constant matrics\n\nExamples\n\njulia> TimeDependentCoupling([(s)->s], [σz], unit=:ħ)\n\n\n\n\n\n","category":"type"},{"location":"lib/coupling.html#OpenQuantumBase.TimeDependentCouplings","page":"Coupling","title":"OpenQuantumBase.TimeDependentCouplings","text":"struct TimeDependentCouplings <: OpenQuantumBase.AbstractTimeDependentCouplings\n\nDefines an 1-D array of time dependent system bath coupling operators.\n\nFields\n\ncoupling\nA tuple of single TimeDependentCoupling operators\n\n\n\n\n\n","category":"type"},{"location":"lib/coupling.html#Others","page":"Coupling","title":"Others","text":"","category":"section"},{"location":"lib/coupling.html","page":"Coupling","title":"Coupling","text":"CustomCouplings\nCustomCouplings(funcs; unit = :h)","category":"page"},{"location":"lib/coupling.html#OpenQuantumBase.CustomCouplings","page":"Coupling","title":"OpenQuantumBase.CustomCouplings","text":"struct CustomCouplings <: OpenQuantumBase.AbstractTimeDependentCouplings\n\nCustomCouplings is a container for any user defined coupling operators.\n\nFields\n\ncoupling\nA 1-D array of callable objects that returns coupling matrices\nsize\nSize of the coupling operator\n\n\n\n\n\n","category":"type"},{"location":"lib/coupling.html#OpenQuantumBase.CustomCouplings-Tuple{Any}","page":"Coupling","title":"OpenQuantumBase.CustomCouplings","text":"CustomCouplings(funcs; unit)\n\n\nCreate a CustomCouplings object from a list of functions funcs.\n\n\n\n\n\n","category":"method"},{"location":"lib/interactions.html#Interactions","page":"Interaction","title":"Interactions","text":"","category":"section"},{"location":"lib/interactions.html#Interactions-2","page":"Interaction","title":"Interactions","text":"","category":"section"},{"location":"lib/interactions.html","page":"Interaction","title":"Interaction","text":"Interaction\nInteractionSet","category":"page"},{"location":"lib/interactions.html#OpenQuantumBase.Interaction","page":"Interaction","title":"OpenQuantumBase.Interaction","text":"struct Interaction <: OpenQuantumBase.AbstractInteraction\n\nAn object to hold coupling operator and the corresponding bath object.\n\ncoupling\nsystem operator\nbath\nbath coupling to the system operator\n\n\n\n\n\n","category":"type"},{"location":"lib/interactions.html#OpenQuantumBase.InteractionSet","page":"Interaction","title":"OpenQuantumBase.InteractionSet","text":"struct InteractionSet{T<:Tuple}\n\nAn container for different system-bath interactions.\n\ninteractions\nA tuple of Interaction\n\n\n\n\n\n","category":"type"},{"location":"lib/interactions.html#","page":"Interaction","title":"","text":"","category":"section"},{"location":"lib/interactions.html","page":"Interaction","title":"Interaction","text":"Lindblad","category":"page"},{"location":"lib/interactions.html#OpenQuantumBase.Lindblad","page":"Interaction","title":"OpenQuantumBase.Lindblad","text":"struct Lindblad <: OpenQuantumBase.AbstractInteraction\n\nA Lindblad operator, define by a rate γ and corresponding operator L`.\n\nγ\nLindblad rate\nL\nLindblad operator\nsize\nsize\n\n\n\n\n\n","category":"type"},{"location":"basics/math_symbol.html#Math-Symbols","page":"Math Symbol","title":"Math Symbols","text":"","category":"section"},{"location":"basics/math_symbol.html","page":"Math Symbol","title":"Math Symbol","text":"OpenQuantumTools defines some commonly used mathematical symbols and operators, including:","category":"page"},{"location":"basics/math_symbol.html#Pauli-matrices","page":"Math Symbol","title":"Pauli matrices","text":"","category":"section"},{"location":"basics/math_symbol.html","page":"Math Symbol","title":"Math Symbol","text":"The constants σx, σy, σz and σi represent the Pauli matrices. The binary operator ⊗ (can be typed as \\otimes<tab>) represents the tensor product. For example,","category":"page"},{"location":"basics/math_symbol.html","page":"Math Symbol","title":"Math Symbol","text":"julia> σx⊗σz\n4×4 Array{Complex{Float64},2}:\n 0.0+0.0im   0.0+0.0im  1.0+0.0im   0.0+0.0im\n 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -1.0+0.0im\n 1.0+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im\n 0.0+0.0im  -1.0+0.0im  0.0+0.0im  -0.0+0.0im","category":"page"},{"location":"basics/math_symbol.html","page":"Math Symbol","title":"Math Symbol","text":"calculates the tensor product of σx and σz.","category":"page"},{"location":"basics/math_symbol.html","page":"Math Symbol","title":"Math Symbol","text":"The eigenvectors of each Pauli matrix are also stored in the constant PauliVec, where PauliVec[1],PauliVec[2],PauliVec[3] correspond to the  eigenvectors of σx, σy, σz respectively. The first element in each PauliVec[i] is the one with a positive eigenvalue","category":"page"},{"location":"basics/math_symbol.html","page":"Math Symbol","title":"Math Symbol","text":"julia> σz*PauliVec[3][1] == PauliVec[3][1]\ntrue","category":"page"},{"location":"basics/math_symbol.html","page":"Math Symbol","title":"Math Symbol","text":"Additionally, sparse versions of the Pauli matrices are defined in spσx, spσy, spσz and spσi. They can be used to construct SparseHamiltonian.","category":"page"},{"location":"basics/math_symbol.html#Utility-functions","page":"Math Symbol","title":"Utility functions","text":"","category":"section"},{"location":"basics/math_symbol.html","page":"Math Symbol","title":"Math Symbol","text":"OpenQuantumTools provides various utility functions for convenience.","category":"page"},{"location":"basics/math_symbol.html","page":"Math Symbol","title":"Math Symbol","text":"check_positivity: check if a matrix is positive semi-definite.\ncheck_unitary: check if a matrix is unitary.\ncheck_density_matrix: check if a matrix is a valid density matrix.\nfidelity: calculate the fidelity between two density matrices ρ and σ using Trsqrtsqrtrhosigmasqrtrho^2","category":"page"},{"location":"basics/math_symbol.html","page":"Math Symbol","title":"Math Symbol","text":"julia> ρ = PauliVec[1][1]*PauliVec[1][1]'\njulia> σ = PauliVec[3][1]*PauliVec[3][1]'\njulia> fidelity(ρ, σ)\n0.49999999999999944","category":"page"},{"location":"basics/math_symbol.html","page":"Math Symbol","title":"Math Symbol","text":"partial_trace: calculate the partial trace of a matrix","category":"page"},{"location":"basics/math_symbol.html","page":"Math Symbol","title":"Math Symbol","text":"julia> ρ1 = [0.4 0.2; 0.2 0.6]; ρ2 = [0.5 0; 0 0.5];\njulia> partial_trace(ρ1⊗ρ2, [1])\n2×2 Array{Float64,2}:\n0.4  0.2\n0.2  0.6","category":"page"},{"location":"basics/math_symbol.html","page":"Math Symbol","title":"Math Symbol","text":"matrix_decompose: project a matrix onto a list of basis elements","category":"page"},{"location":"basics/math_symbol.html","page":"Math Symbol","title":"Math Symbol","text":"julia> matrix_decompose(1.0*σx+2.0*σy+3.0*σz, [σx,σy,σz])\n3-element Array{Complex{Float64},1}:\n1.0 + 0.0im\n2.0 + 0.0im\n3.0 + 0.0im","category":"page"},{"location":"basics/math_symbol.html#Construction-of-multi-qubit-matrices","page":"Math Symbol","title":"Construction of multi-qubit matrices","text":"","category":"section"},{"location":"basics/math_symbol.html","page":"Math Symbol","title":"Math Symbol","text":"A collection of functions to conveniently construct multi-qubit matrices is also listed below, to which a keyword argument sp can be supplied to generate sparse matrices.","category":"page"},{"location":"basics/math_symbol.html","page":"Math Symbol","title":"Math Symbol","text":"standard_driver builds the standard driver Hamiltonian in quantum annealing:","category":"page"},{"location":"basics/math_symbol.html","page":"Math Symbol","title":"Math Symbol","text":"julia> standard_driver(2) == σx⊗σi + σi⊗σx\ntrue\njulia> standard_driver(2, sp=true) == spσx⊗spσi + spσi⊗spσx\ntrue","category":"page"},{"location":"basics/math_symbol.html","page":"Math Symbol","title":"Math Symbol","text":"q_translate builds a multi-qubit matrix from its string representation:","category":"page"},{"location":"basics/math_symbol.html","page":"Math Symbol","title":"Math Symbol","text":"julia> q_translate(\"ZZ+0.5ZI-XZ\")\n4×4 Array{Complex{Float64},2}:\n  1.5+0.0im   0.0+0.0im  -1.0+0.0im   0.0+0.0im\n  0.0+0.0im  -0.5+0.0im   0.0+0.0im   1.0+0.0im\n -1.0+0.0im   0.0+0.0im  -1.5+0.0im  -0.0+0.0im\n  0.0+0.0im   1.0+0.0im  -0.0+0.0im   0.5+0.0im","category":"page"},{"location":"basics/math_symbol.html","page":"Math Symbol","title":"Math Symbol","text":"collective_operator constructs a collective Pauli operator (the same Pauli operator acting on each individual qubit):","category":"page"},{"location":"basics/math_symbol.html","page":"Math Symbol","title":"Math Symbol","text":"julia> collective_operator(\"z\", 3) == σz⊗σi⊗σi + σi⊗σz⊗σi + σi⊗σi⊗σz\ntrue","category":"page"},{"location":"basics/math_symbol.html","page":"Math Symbol","title":"Math Symbol","text":"single_clause builds a single-clause term:","category":"page"},{"location":"basics/math_symbol.html","page":"Math Symbol","title":"Math Symbol","text":"julia> single_clause([\"z\",\"z\"], [2,3], -2, 4) == -2σi⊗σz⊗σz⊗σi\ntrue","category":"page"},{"location":"basics/math_symbol.html","page":"Math Symbol","title":"Math Symbol","text":"local_field_term builds a local field terms of the form ΣhᵢZᵢ:","category":"page"},{"location":"basics/math_symbol.html","page":"Math Symbol","title":"Math Symbol","text":"julia> local_field_term([1.0, 0.5], [1, 2], 2) == σz⊗σi+0.5σi⊗σz\ntrue","category":"page"},{"location":"basics/math_symbol.html","page":"Math Symbol","title":"Math Symbol","text":"two_local_term builds two-local terms of the form JᵢⱼZᵢZⱼ:","category":"page"},{"location":"basics/math_symbol.html","page":"Math Symbol","title":"Math Symbol","text":"julia> two_local_term([1.0, 0.5], [[1,2], [1,3]], 3) == σz⊗σz⊗σi + 0.5σz⊗σi⊗σz\ntrue","category":"page"},{"location":"basics/math_symbol.html#Construction-of-multi-qubit-states","page":"Math Symbol","title":"Construction of multi-qubit states","text":"","category":"section"},{"location":"basics/math_symbol.html","page":"Math Symbol","title":"Math Symbol","text":"The quantum state of a spin system can be constructed byq_translate_state","category":"page"},{"location":"basics/math_symbol.html","page":"Math Symbol","title":"Math Symbol","text":"julia> q_translate_state(\"001\")\n8-element Array{Complex{Float64},1}:\n 0.0 + 0.0im\n 1.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im","category":"page"},{"location":"basics/math_symbol.html","page":"Math Symbol","title":"Math Symbol","text":"In the string representation, 0 and 1 represent the eigenstates of the σ_z operator.","category":"page"},{"location":"basics/hpc.html#Parallel-Simulation","page":"Parallel","title":"Parallel Simulation","text":"","category":"section"},{"location":"basics/hpc.html","page":"Parallel","title":"Parallel","text":"OpenQuantumTools provides the parallel trajectory simulation capability through the ensemble simulation interface of the DifferentialEquations.jl package. ","category":"page"},{"location":"basics/hpc.html#Starting-Julia-in-the-correct-parallel-model","page":"Parallel","title":"Starting Julia in the correct parallel model","text":"","category":"section"},{"location":"basics/hpc.html","page":"Parallel","title":"Parallel","text":"Julia provides different paradigms of parallel computing with their corresponding interfaces. OpenQuantumTools does not check or manage the parallel mode of the current Julia process. So to use a particular parallel paradigm (multi-threading, distributed computing, etc.), Julia must first be properly launched in the correct parallel mode. For example, to use the thread-level parallelization, Julia needs to be started with multiple threads; to use the cluster-level parallelization, Julia needs to be launched in a cluster environment using either the distributed interface or a cluster manager.","category":"page"},{"location":"basics/hpc.html#Building-a-problem","page":"Parallel","title":"Building a problem","text":"","category":"section"},{"location":"basics/hpc.html","page":"Parallel","title":"Parallel","text":"To perform a simulation on an ensemble of trajectories, a EnsembleProblem needs to be defined. OpenQuantumTools provides a wrapper function for the original constructor:","category":"page"},{"location":"basics/hpc.html","page":"Parallel","title":"Parallel","text":"prob = build_ensembles(annealing::Annealing, tf::Real, type::Symbol, kwargs...)","category":"page"},{"location":"basics/hpc.html","page":"Parallel","title":"Parallel","text":"annealing: The annealing/evolution defined by the open quantum system model.\ntf: The total annealing/evolution time.\ntype: The type of the trajectory simulation to perform. Currently four types of trajectory simulations are supported:\n:stochastic: The stochastic Schrödinger equation for the spin-fluctuator model;\n:lindblad: The trajectory simulation of the Lindblad master equation; \n:ame: The trajectory simulation of the adiabatic master equation; \n:redfield: The time-form Redfield equation hybridized with spin-fluctuator noise.","category":"page"},{"location":"basics/hpc.html","page":"Parallel","title":"Parallel","text":"All the other keyword arguments of the original constructor are also supported. To avoid complications, only the most relevant keyword arguments are listed here. Interested readers are encouraged to explore the original documentation for more features.","category":"page"},{"location":"basics/hpc.html#Solving-the-Problem","page":"Parallel","title":"Solving the Problem","text":"","category":"section"},{"location":"basics/hpc.html","page":"Parallel","title":"Parallel","text":"sim = solve(prob::EnsembleProblem,alg,ensemblealg,kwargs...)","category":"page"},{"location":"basics/hpc.html","page":"Parallel","title":"Parallel","text":"The special keyword arguments to note are:","category":"page"},{"location":"basics/hpc.html","page":"Parallel","title":"Parallel","text":"trajectories: The number of trajectory simulations to run. This argument is required.\nensemblealg: The ensemble algorithm that specify how the multiple trajectories are handled. This argument is optional and will default to EnsembleThreads(). Currently, the ensemble algorithm types are:\nEnsembleSerial() - No parallelism\nEnsembleThreads() - The default. This uses multithreading. It's local (single computer, shared memory)\nparallelism only. Fastest when the trajectories are quick.\nEnsembleDistributed() - Uses pmap internally. It will use as many processors as the available Julia processes. To add more processes, use addprocs(n). See Julia's documentation for more details. Recommended for the case when each trajectory calculation isn't \"too quick\".\nEnsembleSplitThreads() - This uses threading on each process, splitting the problem\ninto nprocs() even parts. This is for solving many quick trajectories on a   multi-node machine. It's recommended you have one process on each node.","category":"page"},{"location":"basics/annealing.html#Annealing/Evolution","page":"Annealing","title":"Annealing/Evolution","text":"","category":"section"},{"location":"basics/annealing.html#Single-system-bath-coupling","page":"Annealing","title":"Single system-bath coupling","text":"","category":"section"},{"location":"basics/annealing.html","page":"Annealing","title":"Annealing","text":"This package implements the AbstractFactory pattern for a quantum evolution via a concrete type Annealing. A complete quantum evolution is assembled from the following parts:","category":"page"},{"location":"basics/annealing.html","page":"Annealing","title":"Annealing","text":"Hamiltonian: Any object that implements the AbstractHamiltonian interface\nInitial state: A state vector/density matrix\n(Optional) System bath coupling – system part\n(Optional) System bath coupling – bath part\n(Optional) System-bath interaction – InteractionSet\n(Optional) Additional control protocols","category":"page"},{"location":"basics/annealing.html","page":"Annealing","title":"Annealing","text":"For example, the following code block","category":"page"},{"location":"basics/annealing.html","page":"Annealing","title":"Annealing","text":"H = DenseHamiltonian([(s)->1-s, (s)->s], -[σx, σz]/2, unit=:ħ)\nu0 = PauliVec[1][1]\ncoupling = ConstantCouplings([\"Z\"], unit=:ħ)\nbath = Ohmic(1e-4, 4, 16)\nannealing = Annealing(H, u0; coupling=coupling, bath=bath)","category":"page"},{"location":"basics/annealing.html","page":"Annealing","title":"Annealing","text":"constructs a standard single-qubit annealing process with the total Hamiltonian","category":"page"},{"location":"basics/annealing.html","page":"Annealing","title":"Annealing","text":"H(s) = -(1-s)fracX2 - sfracZ2 + Z otimes B + H_B  ","category":"page"},{"location":"basics/annealing.html","page":"Annealing","title":"Annealing","text":"where B H_B forms an Ohmic bath.","category":"page"},{"location":"basics/annealing.html#Multiple-system-bath-couplings","page":"Annealing","title":"Multiple system-bath couplings","text":"","category":"section"},{"location":"basics/annealing.html","page":"Annealing","title":"Annealing","text":"If multiple system-bath couplings are needed, they can be merged into an InteractionSet via Interactions before constructing Annealing.","category":"page"},{"location":"basics/annealing.html","page":"Annealing","title":"Annealing","text":"coupling_1 = ConstantCouplings([\"X\"])\nbath_1 = Ohmic(1e-4, 4, 16)\ninteraction_1 = Interaction(coupling_1, bath_1)\n\ncoupling_2 = ConstantCouplings([\"Z\"])\nbath_2 = Ohmic(1e-4, 0.1, 16)\ninteraction_2 = Interaction(coupling_2, bath_2)\n\ninteraction_set = InteractionSet(interaction_1, interaction_2)\nannealing = Annealing(H, u0, interactions=interaction_set)","category":"page"},{"location":"basics/annealing.html","page":"Annealing","title":"Annealing","text":"The above code block builds the same single-qubit Hamiltonian coupled to two different Ohmic baths via both sigma_z and sigma_x operators","category":"page"},{"location":"basics/annealing.html","page":"Annealing","title":"Annealing","text":"H(s) = -(1-s)fracX2 - sfracZ2 + X otimes B_1 + Z otimes B_2 + H_B  ","category":"page"},{"location":"basics/annealing.html#Other-interaction-types","page":"Annealing","title":"Other interaction types","text":"","category":"section"},{"location":"basics/annealing.html","page":"Annealing","title":"Annealing","text":"Sometimes it is impractical to directly start from the system-bath interaction Hamiltonian. For example, often the Lindblad equation is the starting point. In such cases, instead of building Interactions from AbstractCouplings and AbstractBath, the user can specify different subtypes of AbstractInteraction. For example,","category":"page"},{"location":"basics/annealing.html","page":"Annealing","title":"Annealing","text":"lind = Lindblad(0.1, σz)","category":"page"},{"location":"basics/annealing.html","page":"Annealing","title":"Annealing","text":"defines the Lindblad superoperator","category":"page"},{"location":"basics/annealing.html","page":"Annealing","title":"Annealing","text":"gamma Big( L rho L^dagger - frac12bigL^dagger L rhobigBig)  ","category":"page"},{"location":"basics/annealing.html","page":"Annealing","title":"Annealing","text":"where L=Z and gamma=01. In the above example, Lindblad is a subtype of AbstractInteraction that can be combined into an InteractionSet. To learn more about this example, please see the tutorial.","category":"page"},{"location":"basics/couplings.html#Couplings","page":"Coupling","title":"Couplings","text":"","category":"section"},{"location":"basics/couplings.html","page":"Coupling","title":"Coupling","text":"We start with a general form of a system-bath interaction Hamiltonian","category":"page"},{"location":"basics/couplings.html","page":"Coupling","title":"Coupling","text":"  H_SB = sum_alpha S_alphaotimes B_alpha","category":"page"},{"location":"basics/couplings.html","page":"Coupling","title":"Coupling","text":"and define the set of S_alpha_alpha with corresponding B_α_alpha as AbstractCouplings objects. Mathematically, every element in the same AbstractCouplings object shares the same bath correlation function. Three concrete types of AbstractCouplings are implemented – ConstantCouplings, TimeDependentCouplings and CustomCouplings.","category":"page"},{"location":"basics/couplings.html#Constant-Couplings","page":"Coupling","title":"Constant Couplings","text":"","category":"section"},{"location":"basics/couplings.html","page":"Coupling","title":"Coupling","text":"ConstantCouplings represents time-independent operators. For example, the following code line","category":"page"},{"location":"basics/couplings.html","page":"Coupling","title":"Coupling","text":"coupling = ConstantCouplings([\"ZI\", \"IZ\"])","category":"page"},{"location":"basics/couplings.html","page":"Coupling","title":"Coupling","text":"creates a set of two constant operators: ZI and IZ. The corresponding interaction Hamiltonian is","category":"page"},{"location":"basics/couplings.html","page":"Coupling","title":"Coupling","text":"  H_SB = ZIB_1 + IZB_2  ","category":"page"},{"location":"basics/couplings.html","page":"Coupling","title":"Coupling","text":"where B_1 and B_2 are independent and have identical correlation functions. ","category":"page"},{"location":"basics/couplings.html#Time-dependent-Couplings","page":"Coupling","title":"Time-dependent Couplings","text":"","category":"section"},{"location":"basics/couplings.html","page":"Coupling","title":"Coupling","text":"On the other hand, TimeDependentCouplings can be constructed by a two-step procedure. First, a single TimeDependentCoupling needs to be constructed using","category":"page"},{"location":"basics/couplings.html","page":"Coupling","title":"Coupling","text":"c1 = TimeDependentCoupling([(s)->cos(s)], [σx], unit=:ħ)\nc2 = TimeDependentCoupling([(s)->sin(s)], [σz], unit=:ħ)","category":"page"},{"location":"basics/couplings.html","page":"Coupling","title":"Coupling","text":"which creates two time-dependent coupling operators cos(s) X and sin(s) Z. Then, c1 and c2 are grouped together to create the coupling set:","category":"page"},{"location":"basics/couplings.html","page":"Coupling","title":"Coupling","text":"coupling = TimeDependentCouplings(c1, c2)","category":"page"},{"location":"basics/couplings.html#Custom-Couplings","page":"Coupling","title":"Custom Couplings","text":"","category":"section"},{"location":"basics/couplings.html","page":"Coupling","title":"Coupling","text":"In addition, CustomCouplings provides a more flexible interface to construct the system-bath coupling operators from a list of user-defined functions:","category":"page"},{"location":"basics/couplings.html","page":"Coupling","title":"Coupling","text":"coupling = CustomCouplings([(s)->σz])","category":"page"},{"location":"basics/couplings.html","page":"Coupling","title":"Coupling","text":"Finally, we remark that only AbstractCouplings can be used to create an Annealing object.","category":"page"},{"location":"lib/hamiltonian.html#Hamiltonian","page":"Hamiltonian","title":"Hamiltonian","text":"","category":"section"},{"location":"lib/hamiltonian.html#Hamiltonian-types","page":"Hamiltonian","title":"Hamiltonian types","text":"","category":"section"},{"location":"lib/hamiltonian.html","page":"Hamiltonian","title":"Hamiltonian","text":"DenseHamiltonian\nDenseHamiltonian(funcs, mats; unit = :h, EIGS = EIGEN_DEFAULT)\nSparseHamiltonian\nSparseHamiltonian(funcs, mats; unit = :h, EIGS = EIGEN_DEFAULT)\nAdiabaticFrameHamiltonian\nAdiabaticFrameHamiltonian(ωfuns, geofuns)","category":"page"},{"location":"lib/hamiltonian.html#OpenQuantumBase.DenseHamiltonian","page":"Hamiltonian","title":"OpenQuantumBase.DenseHamiltonian","text":"struct DenseHamiltonian{T<:Number, dimensionless_time} <: OpenQuantumBase.AbstractDenseHamiltonian{T<:Number}\n\nDefines a time dependent Hamiltonian object using Julia arrays.\n\nFields\n\nf\nList of time dependent functions\nm\nList of constant matrices\nu_cache\nInternal cache\nsize\nSize\n\n\n\n\n\n","category":"type"},{"location":"lib/hamiltonian.html#OpenQuantumBase.DenseHamiltonian-Tuple{Any, Any}","page":"Hamiltonian","title":"OpenQuantumBase.DenseHamiltonian","text":"DenseHamiltonian(funcs, mats; unit, dimensionless_time)\n\n\nConstructor of the DenseHamiltonian type. funcs and mats are lists of time-dependent functions and the corresponding matrices. The Hamiltonian can be represented as ᵢfuncsi(s)matsi. \n\nunit specifies wether :h or :ħ is set to one when defining funcs and mats. The mats will be scaled by 2π if unit is :h.\n\ndimensionless_time specifies wether the arguments of the functions are dimensionless (normalized to total evolution time).\n\n\n\n\n\n","category":"method"},{"location":"lib/hamiltonian.html#OpenQuantumBase.SparseHamiltonian","page":"Hamiltonian","title":"OpenQuantumBase.SparseHamiltonian","text":"struct SparseHamiltonian{T<:Number, dimensionless_time} <: OpenQuantumBase.AbstractSparseHamiltonian{T<:Number}\n\nDefines a time dependent Hamiltonian object with sparse matrices.\n\nFields\n\nf\nList of time dependent functions\nm\nList of constant matrices\nu_cache\nInternal cache\nsize\nSize\n\n\n\n\n\n","category":"type"},{"location":"lib/hamiltonian.html#OpenQuantumBase.SparseHamiltonian-Tuple{Any, Any}","page":"Hamiltonian","title":"OpenQuantumBase.SparseHamiltonian","text":"SparseHamiltonian(funcs, mats; unit, dimensionless_time)\n\n\nConstructor of the SparseHamiltonian type. funcs and mats are lists of time-dependent functions and the corresponding matrices. The Hamiltonian can be represented as ᵢfuncsi(s)matsi. unit specifies wether :h or :ħ is set to one when defining funcs and mats. The mats will be scaled by 2π if unit is :h.\n\n\n\n\n\n","category":"method"},{"location":"lib/hamiltonian.html#OpenQuantumBase.AdiabaticFrameHamiltonian","page":"Hamiltonian","title":"OpenQuantumBase.AdiabaticFrameHamiltonian","text":"struct AdiabaticFrameHamiltonian{T} <: OpenQuantumBase.AbstractDenseHamiltonian{T}\n\nDefines a time dependent Hamiltonian in adiabatic frame.\n\nFields\n\ngeometric\nGeometric part\ndiagonal\nAdiabatic part\nsize\nSize of the Hamiltonian\n\n\n\n\n\n","category":"type"},{"location":"lib/hamiltonian.html#OpenQuantumBase.AdiabaticFrameHamiltonian-Tuple{Any, Any}","page":"Hamiltonian","title":"OpenQuantumBase.AdiabaticFrameHamiltonian","text":"function AdiabaticFrameHamiltonian(ωfuns, geofuns)\n\nConstructor of adiabatic frame Hamiltonian. ωfuns is a 1-D array of functions which specify the eigen energies (in GHz) of the Hamiltonian. geofuns is a 1-D array of functions which specifies the geometric phases of the Hamiltonian. geofuns can be thought as a flattened lower triangular matrix (without diagonal elements) in column-major order.\n\n\n\n\n\n","category":"method"},{"location":"lib/hamiltonian.html#","page":"Hamiltonian","title":"","text":"","category":"section"},{"location":"lib/hamiltonian.html","page":"Hamiltonian","title":"Hamiltonian","text":"evaluate(H::OpenQuantumBase.AbstractHamiltonian, s::Real)\neigen_decomp(H::OpenQuantumBase.AbstractHamiltonian, s; lvl::Int=2)\neigen_decomp(H::OpenQuantumBase.AbstractHamiltonian, s::AbstractArray{Float64,1}; lvl::Int=2)","category":"page"},{"location":"lib/hamiltonian.html#OpenQuantumBase.evaluate-Tuple{OpenQuantumBase.AbstractHamiltonian, Real}","page":"Hamiltonian","title":"OpenQuantumBase.evaluate","text":"evaluate(H, s)\n\n\nEvaluate the time dependent Hamiltonian at time s with the unit of GHz. \n\nFallback to H.(s)/2/π for generic AbstractHamiltonian type.\n\n\n\n\n\n","category":"method"},{"location":"lib/hamiltonian.html#OpenQuantumBase.eigen_decomp-Tuple{OpenQuantumBase.AbstractHamiltonian, Any}","page":"Hamiltonian","title":"OpenQuantumBase.eigen_decomp","text":"eigen_decomp(H, s; lvl)\n\n\nCalculate the eigen value decomposition of the Hamiltonian H at time s. Keyword argument lvl specifies the number of levels to keep in the output. w is a vector of eigenvalues and v is a matrix of the eigenvectors in the columns. (The kth eigenvector can be obtained from the slice v[:, k].) w will be in unit of GHz.\n\n\n\n\n\n","category":"method"},{"location":"lib/hamiltonian.html#OpenQuantumBase.eigen_decomp-Tuple{OpenQuantumBase.AbstractHamiltonian, AbstractVector{Float64}}","page":"Hamiltonian","title":"OpenQuantumBase.eigen_decomp","text":"eigen_decomp(H, s; lvl)\n\n\nCalculate the eigen value decomposition of the Hamiltonian H at an array of time points s. The output keeps the lowest lvl eigenstates and their corresponding eigenvalues. Output (vals, vecs) have the dimensions of (lvl, length(s)) and (size(H, 1), lvl, length(s)) respectively.\n\n\n\n\n\n","category":"method"},{"location":"basics/hamiltonians.html#Hamiltonians","page":"Hamiltonian","title":"Hamiltonians","text":"","category":"section"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"An AbstractHamiltonian type defines a time-dependent matrix and provide the interface to the low-level solvers. OpenQuantumTools offers three ways to construct a Hamiltonian object. Before introducing them, we clarify how HOQST handles units in this case.","category":"page"},{"location":"basics/hamiltonians.html#Units","page":"Hamiltonian","title":"Units","text":"","category":"section"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"From the Schrodinger equation","category":"page"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"  ihbar lvert Phi rangle = H lvert Phi rangle  ","category":"page"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"it follows that the Hamiltonian can be normalized as H  hbar. If we set h=1, then what appears on the RHS of the Schrodinger equation is 2pi H where H has frequency units. In OpenQuantumTools, we set this to the natural units of superconducting qubits – GHz. Internally, OpenQuantumTools always works with the convention of h=1.","category":"page"},{"location":"basics/hamiltonians.html#Construction","page":"Hamiltonian","title":"Construction","text":"","category":"section"},{"location":"basics/hamiltonians.html#Affine-operator","page":"Hamiltonian","title":"Affine operator","text":"","category":"section"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"For fs = [f1,f2,...,fn] and Ms = [M1,M2,...,Mn] where each of the fis and Mis are Function(or callable object) and Matrix, the following constructor","category":"page"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"function TypeHamiltonian(fs,Ms)","category":"page"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"builds a time-dependent Hamiltonian H = f_1(t)M_1 + f_2(t)M_2 +  + f_n(t)M_n. The Type should be changed to a specific descriptor of the Hamiltonian. For example, a Hamiltonian consisting of dense matrices can be constructed with DenseHamiltonian:","category":"page"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"julia> H = DenseHamiltonian([(s)->1-s, (s)->s], [σx, σz])","category":"page"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"The above code line creates a standard single-qubit annealing Hamiltonian of the form H(s)=(1-s)σ_x+sσ_z, whose default unit is GHz (h=1). Internally, OpenQuantumTools stores the value of Hhbar. So any object created with the default unit will be scaled by 2π. Users can set the unit to ħ=1 by","category":"page"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"julia> H_ħ  = DenseHamiltonian([(s)->1-s, (s)->s], [σx, σz]; unit=:ħ)","category":"page"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"which means that the input of the constructor is already Hhbar.","category":"page"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"To obtain the value of Hamiltonian at a given dimensionless time s in a consistent manner, we recommend using the function evaluate:","category":"page"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"julia> evaluate(H, 0.5)\n2×2 Array{Complex{Float64},2}:\n  0.5+0.0im  -0.5+0.0im\n -0.5+0.0im  -0.5+0.0im","category":"page"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"It always returns energy in GHz units. On the other hand, calling H directly like a Function will return a numerical value of Hhbar:","category":"page"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"julia> H(0.5) == 2π*(σx + σz)/2\ntrue","category":"page"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"There are two additional constructors: SparseHamiltonian and AdiabaticFrameHamiltonian, which construct the sparse and adiabatic-frame Hamiltonian, respectively.","category":"page"},{"location":"basics/hamiltonians.html#Interpolation","page":"Hamiltonian","title":"Interpolation","text":"","category":"section"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"The second method to construct a Hamiltonian is to interpolate a list of precomputed values:","category":"page"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"  H(s_1) H(s_2) ldots","category":"page"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"The syntax is","category":"page"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"H_interp = InterpDenseHamiltonian(s_axis, H_list)\nH_interp = InterpSparseHamiltonian(s_axis, H_list)","category":"page"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"where s_axis and H_list are the grid points and corresponding Hamiltonian values. The constructors also take the keyword arguments method, order and unit. method and order specify the internal interpolation method and its corresponding order. For dense Hamiltonians, both BSpline of order 0-3 and Gridded of order 0-1 are supported. For sparse Hamiltonians, only Gridded of order 0-1 is supported. Internally, OpenQuantumTools relies on Interpolations.jl for interpolation.","category":"page"},{"location":"basics/hamiltonians.html#Functions","page":"Hamiltonian","title":"Functions","text":"","category":"section"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"The third way to build a Hamiltonian is to use a function directly. A custom Hamiltonian can be obtained by using hamiltonian_from_function:","category":"page"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"julia> hamiltonian_from_function((s)->σz)\nCustomDenseHamiltonian with Complex{Float64}\nwith size: (2, 2)","category":"page"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"However, this part is still under construction, so should only used by advanced users at this time.","category":"page"},{"location":"basics/hamiltonians.html#Eigendecomposition","page":"Hamiltonian","title":"Eigendecomposition","text":"","category":"section"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"eigen_decomp can be used to perform an eigendecomposition of the AbstractHamiltonian at a particular time. For example","category":"page"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"w, v = eigen_decomp(H, 0.5, lvl=2)","category":"page"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"calculates the lowest two energy eigenvalues and eigenvectors of H at s=05. w is returned in the unit of GHz, and each column in v corresponds to one eigenvector.","category":"page"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"In addition, a user-defined eigendecomposition function can be attached to any subtype of AbstractHamiltonian if there is a better eigendecomposition algorithm than the default LAPACK routine by defining a haml_eigs function for it. The following code","category":"page"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"import OpenQuantumTools: haml_eigs\n\nfunction haml_eigs(H::DenseHamiltonian, t, lvl)\n        println(\"I am the user defined eigendecomposition routine.\")\n        w, v = eigen(Hermitian(H(t)))\n        w[1:lvl], v[:, 1:lvl]\nend\n\nH = DenseHamiltonian([(s)->1-s, (s)->s], [σx, σz])\neigen_decomp(H, 0.5, lvl=2)","category":"page"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"is a trivial example of replacing the default eigendecomposition routine with a user-defined one. More details can be found in the tutorial.","category":"page"},{"location":"basics/hamiltonians.html#Plotting","page":"Hamiltonian","title":"Plotting","text":"","category":"section"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"OpenQuantumTools also interacts with Plots.jl and provides convenient ways to visualize the spectrum of any given Hamiltonian. For example","category":"page"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"#]add Plots # You need to install Plots.jl before your first time using it!\nusing Plots\n#plotly() # You can optionally choose a plotting backend\nplot(H, 0:0.01:1, 2)","category":"page"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"will produce the following figure. The second argument 0:0.01:1 is the x_axis values, and the third argument 2 is the number of levels to plot. The third argument can also be a list of levels to plot.","category":"page"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"(Image: plot_hamiltonian_example)","category":"page"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"Behind the scenes, the plot function uses the eigen_decomp to calculate the Hamiltonian spectrum up to lvl for each s points and collect the results for plotting.","category":"page"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"s_list = 0:0.01:1\ny = []\nfor s in s_list\n    w, _ = eigen_decomp(H, s; lvl=2)\n    push!(y, w)\nend\ny = hcat(y...)'\nplot(s_list, y)","category":"page"},{"location":"basics/hamiltonians.html#Formal-Properties-of-AbstractHamiltonian","page":"Hamiltonian","title":"Formal Properties of AbstractHamiltonian","text":"","category":"section"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"These are the formal properties that an AbstractHamiltonian should obey for it to work in the solvers:","category":"page"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"Function call H(s) to return a numerical value of H(s)  hbar.\nsize(H) and size(H, dim) functions to return the size of the Hamiltonian. Fallback to size(H)=H.size and size(H, dim)=H.size[dim].\n'getcache(H)' to return a pre-located cache space to store -1.0im*H(s). The cache space will be used by the ODE solver. Fallback to `H.ucache`.\nOptional: In-place function call H(du, u ,p, s) to reset the cache du to -1.0im*(H(s)*u - u*H(s)).\nOptional: In-place functions update_cache!(cache, H, p, s) and update_vectorized_cache!(cache, H, p, s) to update an internal cache w.r.t. -1.0im*H(s) and -1.0im*(I⊗H(s) - transpose(H(s))⊗I).\nOptional: haml_eigs(H, t, lvl) to return the lowest lvl eigenvalues and eigenvectors. The return values should have the same format as the eigen function in the standard library.","category":"page"},{"location":"basics/hamiltonians.html","page":"Hamiltonian","title":"Hamiltonian","text":"The optional properties have their default fallbacks using H(s) call. However, implementing an optimized routine would greatly speedup the calculation.","category":"page"},{"location":"lib/matrix_util.html#Matrix-Utilities","page":"Matrix Utility","title":"Matrix Utilities","text":"","category":"section"},{"location":"lib/matrix_util.html#Symbols","page":"Matrix Utility","title":"Symbols","text":"","category":"section"},{"location":"lib/matrix_util.html","page":"Matrix Utility","title":"Matrix Utility","text":"PauliVec\n⊗","category":"page"},{"location":"lib/matrix_util.html#OpenQuantumBase.PauliVec","page":"Matrix Utility","title":"OpenQuantumBase.PauliVec","text":"PauliVec\n\nA constant that holds the eigenvectors of the Pauli matrices. Indices 1, 2 and 3 corresponds to the eigenvectors of σ_x, σ_y and σ_z.\n\nExamples\n\njulia> σx*PauliVec[1][1] == PauliVec[1][1]\ntrue\n\n\n\n\n\n","category":"constant"},{"location":"lib/matrix_util.html#OpenQuantumBase.:⊗","page":"Matrix Utility","title":"OpenQuantumBase.:⊗","text":"⊗(A, B)\n\nCalculate the tensor product of A and B.\n\nExamples\n\njulia> σx⊗σz\n4×4 Array{Complex{Float64},2}:\n 0.0+0.0im   0.0+0.0im  1.0+0.0im   0.0+0.0im\n 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -1.0+0.0im\n 1.0+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im\n 0.0+0.0im  -1.0+0.0im  0.0+0.0im  -0.0+0.0im\n\n\n\n\n\n","category":"function"},{"location":"lib/matrix_util.html#Math-utilities","page":"Matrix Utility","title":"Math utilities","text":"","category":"section"},{"location":"lib/matrix_util.html","page":"Matrix Utility","title":"Matrix Utility","text":"check_positivity(m::AbstractMatrix)\ncheck_unitary(𝐔::AbstractMatrix; rtol = 1e-6, atol = 1e-8)\ncheck_density_matrix(ρ; atol::Real=0, rtol::Real=atol>0 ? 0 : √eps())\nfidelity(ρ, σ)\npartial_trace(ρ::Matrix, qubit_2_keep::AbstractVector{Int})\npartial_trace(ρ::Matrix, sys_dim::AbstractVector{Int}, dim_2_keep::AbstractVector{Int})\nmatrix_decompose(mat::AbstractMatrix, basis::Vector{<:AbstractMatrix})","category":"page"},{"location":"lib/matrix_util.html#OpenQuantumBase.check_positivity-Tuple{AbstractMatrix}","page":"Matrix Utility","title":"OpenQuantumBase.check_positivity","text":"check_positivity(m)\n\nCheck if matrix m is positive. Return true is the minimum eigenvalue of m is greater than or equal to 0.\n\n\n\n\n\n","category":"method"},{"location":"lib/matrix_util.html#OpenQuantumBase.check_unitary-Tuple{AbstractMatrix}","page":"Matrix Utility","title":"OpenQuantumBase.check_unitary","text":"check_unitary(𝐔; rtol, atol)\n\n\nTest if 𝐔 is a unitary matrix. The function checks how close both 𝐔𝐔^ and 𝐔^𝐔 are to I, with relative and absolute error given by rtol, atol.\n\nExamples\n\njulia> check_unitary(exp(-1.0im*5*0.5*σx))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/matrix_util.html#OpenQuantumBase.check_density_matrix-Tuple{Any}","page":"Matrix Utility","title":"OpenQuantumBase.check_density_matrix","text":"check_density_matrix(ρ; atol, rtol)\n\n\nCheck whether matrix ρ is a valid density matrix. atol and rtol is the absolute and relative error tolerance to use when checking ρ ≈ 1.\n\nExamples\n\njulia> check_density_matrix(σx)\nfalse\njulia> check_density_matrix(σi/2)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/matrix_util.html#OpenQuantumBase.fidelity-Tuple{Any, Any}","page":"Matrix Utility","title":"OpenQuantumBase.fidelity","text":"fidelity(ρ, σ)\n\n\nCalculate the fidelity between two density matrices ρ and σ: Trsqrtsqrtρσsqrtρ².\n\nExamples\n\njulia> ρ = PauliVec[1][1]*PauliVec[1][1]'\njulia> σ = PauliVec[3][1]*PauliVec[3][1]'\njulia> fidelity(ρ, σ)\n0.49999999999999944\n\n\n\n\n\n","category":"method"},{"location":"lib/matrix_util.html#OpenQuantumBase.partial_trace-Tuple{Matrix, AbstractVector{Int64}}","page":"Matrix Utility","title":"OpenQuantumBase.partial_trace","text":"partial_trace(ρ, qubit_2_keep)\n\n\nCalculate the partial trace of the density matrix ρ, assuming all the subsystems are qubits. qubit_2_keep denotes the indices whose corresponding qubits are not traced out.\n\nExamples\n\njulia> ρ1 = [0.4 0.2; 0.2 0.6]; ρ2 = [0.5 0; 0 0.5];\njulia> partial_trace(ρ1⊗ρ2, [1])\n2×2 Array{Float64,2}:\n 0.4  0.2\n 0.2  0.6\n\n\n\n\n\n","category":"method"},{"location":"lib/matrix_util.html#OpenQuantumBase.partial_trace-Tuple{Matrix, AbstractVector{Int64}, AbstractVector{Int64}}","page":"Matrix Utility","title":"OpenQuantumBase.partial_trace","text":"partial_trace(ρ, sys_dim, dim_2_keep)\n\n\nCalculate the partial trace of the density matrix ρ. Assume ρ is in the tensor space of ℋ₁ℋ₂, sys_dim is an array of the corresponding sub-system dimensions. dim_2_keep is an array of the indices whose corresponding subsystems are not traced out.\n\nExamples\n\njulia> ρ1 = [0.4 0.2; 0.2 0.6]; ρ2 = [0.5 0; 0 0.5];\njulia> partial_trace(ρ1⊗ρ2, [2, 2], [1])\n2×2 Array{Float64,2}:\n 0.4  0.2\n 0.2  0.6\n\n\n\n\n\n","category":"method"},{"location":"lib/matrix_util.html#OpenQuantumBase.matrix_decompose-Tuple{AbstractMatrix, Vector{<:AbstractMatrix}}","page":"Matrix Utility","title":"OpenQuantumBase.matrix_decompose","text":"matrix_decompose(mat, basis)\n\n\nDecompse matrix mat onto matrix basis basis\n\nExamples\n\njulia> matrix_decompose(1.0*σx+2.0*σy+3.0*σz, [σx,σy,σz])\n3-element Array{Complex{Float64},1}:\n 1.0 + 0.0im\n 2.0 + 0.0im\n 3.0 + 0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/matrix_util.html#Construction-utilities","page":"Matrix Utility","title":"Construction utilities","text":"","category":"section"},{"location":"lib/matrix_util.html","page":"Matrix Utility","title":"Matrix Utility","text":"q_translate(h::String; sp = false)\nq_translate_state(h::String; normal=false)\nsingle_clause(ops::Vector{String}, q_ind, weight, num_qubit; sp=false)\nsingle_clause(ops::Vector{T}, q_ind, weight, num_qubit; sp=false) where T<:AbstractMatrix\nstandard_driver(num_qubit; sp = false)\nlocal_field_term(h, idx, num_qubit; sp=false)\ntwo_local_term(j, idx, num_qubit; sp=false)\ncollective_operator(op, num_qubit; sp=false)","category":"page"},{"location":"lib/matrix_util.html#OpenQuantumBase.q_translate-Tuple{String}","page":"Matrix Utility","title":"OpenQuantumBase.q_translate","text":"q_translate(h::String; sp = false)\n\nConvert a string h representing multi-qubits Pauli matrices summation into its numerical form. Generate sparse matrix when sp is set to true.\n\nExamples\n\njulia> q_translate(\"X+2.0Z\")\n2×2 Array{Complex{Float64},2}:\n 2.0+0.0im   1.0+0.0im\n 1.0+0.0im  -2.0+0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/matrix_util.html#OpenQuantumBase.q_translate_state-Tuple{String}","page":"Matrix Utility","title":"OpenQuantumBase.q_translate_state","text":"q_translate_state(h::String; normal=false)\n\nConvert a string representation of quantum state to a vector. The keyword argument normal indicates whether to normalize the output vector. (Currently only '0' and '1' are supported)\n\nExamples\n\nSingle term:\n\njulia> q_translate_state(\"001\")\n8-element Array{Complex{Float64},1}:\n 0.0 + 0.0im\n 1.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n\nMultiple terms:\n\njulia> q_translate_state(\"(101)+(001)\", normal=true)\n8-element Array{Complex{Float64},1}:\n                0.0 + 0.0im\n 0.7071067811865475 + 0.0im\n                0.0 + 0.0im\n                0.0 + 0.0im\n                0.0 + 0.0im\n 0.7071067811865475 + 0.0im\n                0.0 + 0.0im\n                0.0 + 0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/matrix_util.html#OpenQuantumBase.single_clause-Tuple{Vector{String}, Any, Any, Any}","page":"Matrix Utility","title":"OpenQuantumBase.single_clause","text":"single_clause(ops::Vector{String}, q_ind, weight, num_qubit; sp=false)\n\nConstruct a single clause of the multi-qubits Hamiltonian. ops is a list of Pauli operator names which appear in this clause. q_ind is the list of indices corresponding to the Pauli matrices in ops. weight is the constant factor of this clause. num_qubit is the total number of qubits. A sparse matrix can be construct by setting sp to true. The following example construct a clause of Z_1 I Z_32.\n\nExamples\n\njulia> single_clause([\"z\", \"z\"], [1, 3], 0.5, 3)\n8×8 Array{Complex{Float64},2}:\n 0.5+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im\n 0.0+0.0im  -0.5+0.0im  0.0+0.0im  -0.0+0.0im   0.0+0.0im  -0.0+0.0im   0.0+0.0im  -0.0+0.0im\n 0.0+0.0im   0.0+0.0im  0.5+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im\n 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -0.5+0.0im   0.0+0.0im  -0.0+0.0im   0.0+0.0im  -0.0+0.0im\n 0.0+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im  -0.5+0.0im  -0.0+0.0im  -0.0+0.0im  -0.0+0.0im\n 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -0.0+0.0im  -0.0+0.0im   0.5-0.0im  -0.0+0.0im   0.0-0.0im\n 0.0+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im  -0.0+0.0im  -0.0+0.0im  -0.5+0.0im  -0.0+0.0im\n 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -0.0+0.0im  -0.0+0.0im   0.0-0.0im  -0.0+0.0im   0.5-0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/matrix_util.html#OpenQuantumBase.single_clause-Union{Tuple{T}, Tuple{Vector{T}, Any, Any, Any}} where T<:(AbstractMatrix)","page":"Matrix Utility","title":"OpenQuantumBase.single_clause","text":"single_clause(ops::Vector{T}, q_ind, weight, num_qubit; sp=false) where T<:AbstractMatrix\n\nConstruct a single clause of the multi-qubits Hamiltonian. ops is a list of single-qubit operators that appear in this clause. The sparse identity matrix is used once sp is set to true. The following example construct a clause of Z_1 I Z_32.\n\nExamples\n\njulia> single_clause([σz, σz], [1, 3], 0.5, 3)\n8×8 Array{Complex{Float64},2}:\n 0.5+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im\n 0.0+0.0im  -0.5+0.0im  0.0+0.0im  -0.0+0.0im   0.0+0.0im  -0.0+0.0im   0.0+0.0im  -0.0+0.0im\n 0.0+0.0im   0.0+0.0im  0.5+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im\n 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -0.5+0.0im   0.0+0.0im  -0.0+0.0im   0.0+0.0im  -0.0+0.0im\n 0.0+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im  -0.5+0.0im  -0.0+0.0im  -0.0+0.0im  -0.0+0.0im\n 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -0.0+0.0im  -0.0+0.0im   0.5-0.0im  -0.0+0.0im   0.0-0.0im\n 0.0+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im  -0.0+0.0im  -0.0+0.0im  -0.5+0.0im  -0.0+0.0im\n 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -0.0+0.0im  -0.0+0.0im   0.0-0.0im  -0.0+0.0im   0.5-0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/matrix_util.html#OpenQuantumBase.standard_driver-Tuple{Any}","page":"Matrix Utility","title":"OpenQuantumBase.standard_driver","text":"standard_driver(num_qubit; sp=false)\n\nConstruct the standard driver Hamiltonian for a system of num_qubit qubits. For example, a two qubits standard driver matrix is IX + XI. Generate sparse matrix when sp is set to true.\n\n\n\n\n\n","category":"method"},{"location":"lib/matrix_util.html#OpenQuantumBase.local_field_term-Tuple{Any, Any, Any}","page":"Matrix Utility","title":"OpenQuantumBase.local_field_term","text":"local_field_term(h, idx, num_qubit; sp=false)\n\nConstruct local Hamiltonian of the form hᵢσᵢᶻ. idx is the index of all local field terms and h is a list of the corresponding weights. num_qubit is the total number of qubits. Generate sparse matrix when sp is set to true.\n\nExamples\n\njulia> local_field_term([1.0, 0.5], [1, 2], 2) == σz⊗σi+0.5σi⊗σz\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/matrix_util.html#OpenQuantumBase.two_local_term-Tuple{Any, Any, Any}","page":"Matrix Utility","title":"OpenQuantumBase.two_local_term","text":"two_local_term(j, idx, num_qubit; sp=false)\n\nConstruct local Hamiltonian of the form Jᵢⱼσᵢᶻσⱼᶻ. idx is the index of all two local terms and j is a list of the corresponding weights. num_qubit is the total number of qubits. Generate sparse matrix when sp is set to true.\n\nExamples\n\njulia> two_local_term([1.0, 0.5], [[1,2], [1,3]], 3) == σz⊗σz⊗σi + 0.5σz⊗σi⊗σz\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/matrix_util.html#OpenQuantumBase.collective_operator-Tuple{Any, Any}","page":"Matrix Utility","title":"OpenQuantumBase.collective_operator","text":"collective_operator(op, num_qubit; sp=false)\n\nConstruct the collective operator for a system of num_qubit qubits. op is the name of the collective Pauli matrix. For example, the following code construct an IZ + ZI matrix. Generate sparse matrix when sp is set to true.\n\nExamples\n\njulia> collective_operator(\"z\", 2)\n4×4 Array{Complex{Float64},2}:\n 2.0+0.0im  0.0+0.0im  0.0+0.0im   0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im   0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im   0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  -2.0+0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/annealing.html#Annealing","page":"Annealing","title":"Annealing","text":"","category":"section"},{"location":"lib/annealing.html","page":"Annealing","title":"Annealing","text":"Annealing","category":"page"},{"location":"lib/annealing.html#OpenQuantumBase.Annealing","page":"Annealing","title":"OpenQuantumBase.Annealing","text":"mutable struct Annealing{hType, uType} <: OpenQuantumBase.AbstractAnnealing{hType, uType}\n\nAnnealing type defines the evolution of a time-dependent Hamiltonian in both closed-system and open-system settings. It is called Annealing because HOQST started as a toolbox for quantum annealing.\n\nFields\n\nH\nHamiltonian for the annealing.\nu0\nInitial state for the annealing.\nannealing_parameter\nFunction of annealing parameter s wrt to t\ninteractions\nA system bath interaction set.\n\n\n\n\n\n","category":"type"},{"location":"lib/solvers.html#Solvers","page":"Solver","title":"Solvers","text":"","category":"section"},{"location":"lib/solvers.html#High-level-interface","page":"Solver","title":"High level interface","text":"","category":"section"},{"location":"lib/solvers.html#Closed-system","page":"Solver","title":"Closed system","text":"","category":"section"},{"location":"lib/solvers.html","page":"Solver","title":"Solver","text":"solve_schrodinger(A::Annealing, tf::Real; tspan = (0, tf), kwargs...)\nsolve_unitary(A::Annealing, tf::Real; vectorize::Bool = false, tspan = (0, tf), kwargs...)\nsolve_von_neumann(A::Annealing, tf::Real; tspan = (0, tf), vectorize::Bool = false, kwargs...)","category":"page"},{"location":"lib/solvers.html#OpenQuantumTools.solve_schrodinger-Tuple{Annealing, Real}","page":"Solver","title":"OpenQuantumTools.solve_schrodinger","text":"solve_schrodinger(A, tf; tspan, kwargs...)\n\n\nSolve Schrodinger equation defined by A for a total evolution time tf.\n\n...\n\nArguments\n\nA::Annealing: the Annealing/Evolution object.\ntf::Real: the total annealing time.\ntspan = (0, tf): time interval to solve the dynamics.\nkwargs: other keyword arguments supported by DifferentialEquations.\n\n...\n\n\n\n\n\n","category":"method"},{"location":"lib/solvers.html#OpenQuantumTools.solve_unitary-Tuple{Annealing, Real}","page":"Solver","title":"OpenQuantumTools.solve_unitary","text":"solve_unitary(A, tf; vectorize, tspan, kwargs...)\n\n\nSolve the unitary defined by A for a total evolution time tf.\n\n...\n\nArguments\n\nA::Annealing: the Annealing/Evolution object.\ntf::Real: the total annealing time.\nvectorize::Bool = false: whether to vectorize the density matrix.\ntspan = (0, tf): time interval to solve the dynamics.\nkwargs: other keyword arguments supported by DifferentialEquations.\n\n...\n\n\n\n\n\n","category":"method"},{"location":"lib/solvers.html#OpenQuantumTools.solve_von_neumann-Tuple{Annealing, Real}","page":"Solver","title":"OpenQuantumTools.solve_von_neumann","text":"solve_von_neumann(A, tf; tspan, vectorize, kwargs...)\n\n\nSolve the von Neumann equation defined by A for a total evolution time tf.\n\n...\n\nArguments\n\nA::Annealing: the Annealing/Evolution object.\ntf::Real: the total annealing time.\nvectorize::Bool = false: whether to vectorize the density matrix.\ntspan = (0, tf): time interval to solve the dynamics.\nkwargs: other keyword arguments supported by DifferentialEquations.\n\n...\n\n\n\n\n\n","category":"method"},{"location":"lib/solvers.html#Open-system","page":"Solver","title":"Open system","text":"","category":"section"},{"location":"lib/solvers.html","page":"Solver","title":"Solver","text":"solve_lindblad(\n    A::Annealing,\n    tf::Real;\n    tspan=(0.0, tf),\n    vectorize::Bool=false,\n    kwargs...,\n)\n\nsolve_redfield(\n    A::Annealing,\n    tf::Real,\n    unitary;\n    vectorize::Bool=false,\n    int_atol=1e-8,\n    int_rtol=1e-6,\n    Ta=tf,\n    kwargs...,\n)\n\nsolve_cgme(\n    A::Annealing,\n    tf::Real,\n    unitary;\n    vectorize::Bool=false,\n    Ta=nothing,\n    int_atol=1e-8,\n    int_rtol=1e-6,\n    kwargs...,\n)\n\nsolve_ule(\n    A::Annealing,\n    tf::Real,\n    unitary;\n    vectorize::Bool=false,\n    int_atol=1e-8,\n    int_rtol=1e-6,\n    Ta=tf,\n    kwargs...,\n)\n\nsolve_ame(\n    A::Annealing,\n    tf::Real;\n    tspan=(0.0, tf),\n    ω_hint=[],\n    lambshift::Bool=true,\n    lvl::Int=size(A.H, 1),\n    vectorize::Bool=false,\n    kwargs...,\n)","category":"page"},{"location":"lib/solvers.html#OpenQuantumTools.solve_lindblad-Tuple{Annealing, Real}","page":"Solver","title":"OpenQuantumTools.solve_lindblad","text":"solve_lindblad(A, tf; tspan, vectorize, kwargs...)\n\n\nSolve the Lindblad equation defined by A for a total evolution time tf.\n\n...\n\nArguments\n\nA::Annealing: the Annealing object.\ntf::Real: the total annealing time.\ntspan = (0, tf): time interval to solve the dynamics.\nvectorize::Bool = false: whether to vectorize the density matrix.\nkwargs : other keyword arguments supported by DifferentialEquations.\n\n...\n\n\n\n\n\n","category":"method"},{"location":"lib/solvers.html#OpenQuantumTools.solve_redfield-Tuple{Annealing, Real, Any}","page":"Solver","title":"OpenQuantumTools.solve_redfield","text":"solve_redfield(A, tf, unitary; vectorize, int_atol, int_rtol, Ta, kwargs...)\n\n\nSolve the time-dependent Redfield equation defined by A for a total evolution time tf.\n\n...\n\nArguments\n\nA::Annealing: the Annealing/Evolution object.\ntf::Real: the total evolution time.\nunitary: precomputed unitary operator of the corresponding closed-system evolution.\nvectorize::Bool = false: whether to vectorize the density matrix.\nint_atol = 1e-8: the absolute error tolerance for integration.\nint_rtol = 1e-6: the relative error tolerance for integration.\nTa = tf: the timescale of the backward integration.\nkwargs: other keyword arguments supported by DifferentialEquations.\n\n...\n\n\n\n\n\n","category":"method"},{"location":"lib/solvers.html#OpenQuantumTools.solve_cgme-Tuple{Annealing, Real, Any}","page":"Solver","title":"OpenQuantumTools.solve_cgme","text":"solve_cgme(A, tf, unitary; vectorize, Ta, int_atol, int_rtol, kwargs...)\n\n\nSolve the time-dependent coarse-grained master equation (CGME) defined by A for a total evolution time tf.\n\n...\n\nArguments\n\nA::Annealing: the Annealing/Evolution object.\ntf::Real: the total evolution time.\nunitary: precomputed unitary operator of the corresponding closed-system evolution.\nvectorize::Bool = false: whether to vectorize the density matrix.\nTa = nothing: coarse-graining time. If set to nothing, the solver will automatically choose the value.\nint_atol = 1e-8: the absolute error tolerance for integration.\nint_rtol = 1e-6: the relative error tolerance for integration.\nkwargs: other keyword arguments supported by DifferentialEquations.\n\n...\n\n\n\n\n\n","category":"method"},{"location":"lib/solvers.html#OpenQuantumTools.solve_ule-Tuple{Annealing, Real, Any}","page":"Solver","title":"OpenQuantumTools.solve_ule","text":"solve_ule(A, tf, unitary; vectorize, int_atol, int_rtol, Ta, kwargs...)\n\n\nSolve the time-dependent universal Lindblad equation (ULE) defined by A for a total evolution time tf.\n\n...\n\nArguments\n\nA::Annealing: the Annealing/Evolution object.\ntf::Real: the total evolution time.\nunitary: precomputed unitary operator of the corresponding closed-system evolution.\nvectorize::Bool = false: whether to vectorize the density matrix.\nint_atol = 1e-8: the absolute error tolerance for integration.\nint_rtol = 1e-6: the relative error tolerance for integration.\nTa = tf: the timescale of the integration region.\nkwargs: other keyword arguments supported by DifferentialEquations.\n\n...\n\n\n\n\n\n","category":"method"},{"location":"lib/solvers.html#OpenQuantumTools.solve_ame-Tuple{Annealing, Real}","page":"Solver","title":"OpenQuantumTools.solve_ame","text":"solve_ame(A, tf; tspan, ω_hint, lambshift, lambshift_S, lvl, vectorize, one_sided, digits, sigdigits, kwargs...)\n\n\nSolve the adiabatic master equation defined by A for a total evolution time tf.\n\n...\n\nArguments\n\nA::Annealing: the Annealing/Evolution object.\ntf::Real: the total annealing time.\ntspan = (0, tf): time interval to solve the dynamics.\nω_hint=[]: specify a grid to precompute the S function in the Lamb shift term. Skip the precomputation if empty.\ndigits::Int=8: the number of digits to keep when checking if a gap is zero.\nsigdigits::Int=8: the number of significant digits when rounding non-zero gaps for comparison.\nlambshift::Bool=true: whether to include the Lamb shift in the simulation.\nlambshift_S=nothing: provide a custom routine to calculate the S function in the Lamb shift term. This overrides the argument lambshift.\nlvl::Int=size(A.H, 1): number of levels to keep. The higher levels are ignored to speed up the computation.\nvectorize::Bool = false: whether to vectorize the density matrix.\none_sided::Bool=false: whether to solve the one-sided AME.\nkwargs : other keyword arguments supported by DifferentialEquations.\n\n...\n\n\n\n\n\n","category":"method"},{"location":"lib/solvers.html#Parallel","page":"Solver","title":"Parallel","text":"","category":"section"},{"location":"lib/solvers.html","page":"Solver","title":"Solver","text":"build_ensembles(\n    A::Annealing,\n    tf::Real,\n    type::Symbol;\n    tspan = (0.0, tf),\n    output_func = (sol, i) -> (sol, false),\n    reduction = (u, data, I) -> (append!(u, data), false),\n    initializer = DEFAULT_INITIALIZER,\n    kwargs...,\n)","category":"page"},{"location":"lib/solvers.html#OpenQuantumTools.build_ensembles-Tuple{Annealing, Real, Symbol}","page":"Solver","title":"OpenQuantumTools.build_ensembles","text":"build_ensembles(A, tf, type; tspan, output_func, reduction, initializer, save_positions, kwargs...)\n\n\nBuild EnsembleProblem object for different open-system models. For :lindblad and :ame, it build the ensemble for the quantum trajectories method. For :stochastic, it builds the ensemble for the stochastic Schrödinger equation. For :redfield, it builds the ensemble to infuse stochastic nosie into the Redfield equation.\n\n...\n\nArguments\n\nA::Annealing: the Annealing/Evolution object.\ntf::Real: the total annealing time.\ntype::Symbol: type of the ensemble to build. Available options are :lindblad, :ame, :stochastic and :redfield.\ntspan = (0, tf): time interval to solve the dynamics.\ninitializer = DEFAULT_INITIALIZER: initializer for the ensemble problem. Currently it is only supported by the :stochastic ensemble.\nsave_positions = (false, false): Boolean tuple for whether to save before and after the callbacks. This saving will occur just before and after the event, only at event times, and does not depend on options like saveat, save_everystep, etc. (i.e. if saveat=[1.0,2.0,3.0], this can still add a save point at 2.1 if true).\noutput_func: The function determines what is saved from the solution to the output array. Defaults to saving the solution itself. The output is (out,rerun) where out is the output and rerun is a boolean which designates whether to rerun. It is part of the DifferentialEquations's parallel interface.\nreduction: This function determines how to reduce the data in each batch. Defaults to appending the data from the batches. The second part of the output determines whether the simulation has converged. If true, the simulation will exit early. By default, this is always false. It is part of the DifferentialEquations's parallel interface.\nkwargs: other keyword arguments supported by the specific solver or by DifferentialEquations.\n\n...\n\n\n\n\n\n","category":"method"},{"location":"lib/callbacks.html#Callbacks","page":"Callback","title":"Callbacks","text":"","category":"section"},{"location":"lib/callbacks.html","page":"Callback","title":"Callback","text":"InstPulseCallback(tstops, pulse_update)\nPositivityCheckCallback()","category":"page"},{"location":"lib/callbacks.html#OpenQuantumTools.InstPulseCallback-Tuple{Any, Any}","page":"Callback","title":"OpenQuantumTools.InstPulseCallback","text":"InstPulseCallback(tstops, pulse_update)\n\n\nBuilds the callback to apply instantaneous pulses during the evolution.\n\n...\n\nArguments\n\ntstops: time points to apply pulses.\npulse_update: udpate function for the state of the system. It taks two argument pulse_update(c, i) where c is the state vector or density matrix and i is the index of the pulse being applied.\n\n...\n\n\n\n\n\n","category":"method"},{"location":"lib/callbacks.html#OpenQuantumTools.PositivityCheckCallback-Tuple{}","page":"Callback","title":"OpenQuantumTools.PositivityCheckCallback","text":"PositivityCheckCallback()\n\n\nBuilds the callback to check positivity of the system density matrix during the evolution.\n\n\n\n\n\n","category":"method"},{"location":"index.html#HOME","page":"Home","title":"HOME","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Hamiltonian Open Quantum System Toolkit (HOQST) for the Julia programming language.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The official name of this package is \"Hamiltonian Open Quantum System Toolkit\" (HOQST). To conform with the Julia package name guidelines the code name of the package is OpenQuantumTools. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"note: `OpenQuantumTools` starts as a toolkit for quantum annealing\nSome terminology used by OpenQuantumTools comes from the fields of adiabatic quantum computing and quantum annealing (for more details see [1] Adiabatic quantum computation).","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"To install, run the following commands inside the Julia REPL:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"OpenQuantumTools\")","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Alternatively, this can also be done in Julia's Pkg REPL:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(1.5) pkg> add OpenQuantumTools","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"More information about Julia's package manager can be found at Pkg.jl. OpenQuantumTools requires Julia 1.4 or higher. Installing it on an older version of Julia will result in an unsatisfiable requirements error.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"To load the package, use the command:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using OpenQuantumTools","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"It is highly recommended that new users start with the introductory-level tutorials in HOQSTTutorials.","category":"page"},{"location":"index.html#Useful-Packages","page":"Home","title":"Useful Packages","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The following external packages are needed to take full advantage of OpenQuantumTools:","category":"page"},{"location":"index.html#[DifferentialEquations.jl](http://docs.juliadiffeq.org/latest/)","page":"Home","title":"DifferentialEquations.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"DifferentialEquations is needed to provide the low-level ODE solvers. For low dependency usage, users can use OrdinaryDiffEq.jl instead.","category":"page"},{"location":"index.html#[Plots.jl](https://github.com/JuliaPlots/Plots.jl)","page":"Home","title":"Plots.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Plots is a visualization interface and toolset for Julia. OpenQuantumTools provides several plotting functionality by defining PlotRecipes.","category":"page"},{"location":"index.html#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"In the first example, we consider a single qubit with the following time-dependent Hamiltonian","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"    H(s) = A(s)X + B(s)Z  ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"which is known as a standard single qubit annealing protocol. s in the above equation is the dimensionless time s=tt_f where t_f means the total evolution time. A(s)=1-s and B(s)=s are scalar functions that are known as the annealing schedules. X and Z stand for the Pauli matrices sigma_x and sigma_z. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The general workflow is:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"define the Hamiltonian;\nconstruct the annealing/time evolution process;\ncall the solver. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The full code for solving the Schrodinger evolution is:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using OpenQuantumTools\nusing DifferentialEquations\ntf = 20\nu0 = PauliVec[1][2]\nH = DenseHamiltonian([(s)->1-s, (s)->s], [σx, σz], unit=:ħ)\nannealing = Annealing(H, u0)\nsol = solve_schrodinger(annealing, tf)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"where the different pieces are explained below.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"First, we need to load the package DifferentialEquations for the ODE solvers. Then we define the Hamiltonian of the annealing process. In \"OpenQuantumTools\", a time-dependent Hamiltonian can be specified by a list of time-dependent functions and a list of constant matrices","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"H = DenseHamiltonian([(s)->1-s, (s)->s], [σx, σz], unit=:ħ)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The resulting Hamiltonian is an affine combination of the corresponding functions and the matrices (1-s)X+ sZ. Next, we define the initial state u0:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"u0 = PauliVec[1][2]","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"where PauliVec is a Constant which holds the eigenvectors of the Pauli matrices. The user can define any length 2 Vector as the initial state.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"An annealing/evolution object can be constructed by combining the Hamiltonian and the initial state:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"annealing = Annealing(H, u0)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"terminology: Annealing\nStrictly speaking, annealing means slowly changing the Hamiltonian from an initial configuration to a final configuration in an open quantum system setup. Even though the master equations in OpenQuantumTools can deal with arbitrary time-dependent Hamiltonians, the name Annealing is still used. Evolution is also supported as a synonym to Annealing.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The final step is to call the solver. In this example, solve_schrodinger solves the Schrodinger equation for a total evolution time tf.","category":"page"},{"location":"index.html#Tutorials","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The following tutorials will introduce you to the functionality of OpenQuantumTools. More examples can be found in HOQSTTutorials.jl.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"tutorials/math_symbol.md\",\n    \"tutorials/hamiltonians.md\",\n    \"tutorials/couplings.md\",\n    \"tutorials/bath.md\",\n    \"tutorials/annealing.md\",\n    \"tutorials/solver.md\"\n    ]\nDepth = 1","category":"page"},{"location":"lib/bath.html#Bath-Module","page":"Bath","title":"Bath Module","text":"","category":"section"},{"location":"lib/bath.html#Ohmic-bath","page":"Bath","title":"Ohmic bath","text":"","category":"section"},{"location":"lib/bath.html","page":"Bath","title":"Bath","text":"OhmicBath\nOhmic","category":"page"},{"location":"lib/bath.html#OpenQuantumBase.OhmicBath","page":"Bath","title":"OpenQuantumBase.OhmicBath","text":"OhmicBath\n\nOhmic bath object to hold a particular parameter set.\n\nFields\n\nη – strength.\nωc – cutoff frequence.\nβ – inverse temperature.\n\n\n\n\n\n","category":"type"},{"location":"lib/bath.html#OpenQuantumBase.Ohmic","page":"Bath","title":"OpenQuantumBase.Ohmic","text":"Ohmic(η, fc, T)\n\n\nConstruct OhmicBath from parameters with physical unit: η–unitless interaction strength; fc–cutoff frequency in GHz; T–temperature in mK.\n\n\n\n\n\n","category":"function"},{"location":"lib/bath.html#Hybrid-Ohmic-bath","page":"Bath","title":"Hybrid Ohmic bath","text":"","category":"section"},{"location":"lib/bath.html","page":"Bath","title":"Bath","text":"HybridOhmicBath\nHybridOhmic","category":"page"},{"location":"lib/bath.html#OpenQuantumBase.HybridOhmicBath","page":"Bath","title":"OpenQuantumBase.HybridOhmicBath","text":"struct HybridOhmicBath <: OpenQuantumBase.AbstractBath\n\nA hybrid noise model with both low and high frequency noise. The high frequency noise is characterized by Ohmic bath and the low frequence noise is characterized by the MRT width W.\n\nW\nMRT width (2π GHz)\nϵl\nlow spectrum reorganization energy (2π GHz)\nη\nstrength of high frequency Ohmic bath\nωc\ncutoff frequency\nβ\ninverse temperature\n\n\n\n\n\n","category":"type"},{"location":"lib/bath.html#OpenQuantumBase.HybridOhmic","page":"Bath","title":"OpenQuantumBase.HybridOhmic","text":"HybridOhmic(W, η, fc, T)\n\nConstruct HybridOhmicBath object with parameters in physical units. W: MRT width (mK); η: interaction strength (unitless); fc: Ohmic cutoff frequency (GHz); T: temperature (mK).\n\n\n\n\n\n","category":"function"},{"location":"lib/bath.html#Spin-fluctuator","page":"Bath","title":"Spin-fluctuator","text":"","category":"section"},{"location":"lib/bath.html","page":"Bath","title":"Bath","text":"EnsembleFluctuator","category":"page"},{"location":"lib/bath.html#OpenQuantumBase.EnsembleFluctuator","page":"Bath","title":"OpenQuantumBase.EnsembleFluctuator","text":"struct EnsembleFluctuator{T} <: OpenQuantumBase.StochasticBath\n\nAn ensemble of random telegraph noise.\n\nf\nA list of RTNs\n\n\n\n\n\n","category":"type"},{"location":"lib/bath.html#Others","page":"Bath","title":"Others","text":"","category":"section"},{"location":"lib/bath.html","page":"Bath","title":"Bath","text":"CustomBath\nCorrelatedBath","category":"page"},{"location":"lib/bath.html#OpenQuantumBase.CustomBath","page":"Bath","title":"OpenQuantumBase.CustomBath","text":"mutable struct CustomBath <: OpenQuantumBase.AbstractBath\n\nAn custum bath object defined by the two-point correlation function and the corresponding spectrum.\n\ncfun\ncorrelation function\nγ\nspectrum\n\n\n\n\n\n","category":"type"},{"location":"lib/bath.html#OpenQuantumBase.CorrelatedBath","page":"Bath","title":"OpenQuantumBase.CorrelatedBath","text":"mutable struct CorrelatedBath <: OpenQuantumBase.AbstractBath\n\nCorrelatedBath defines a correlated bath type by the matrices of its two-point correlation functions and corresponding spectrums.\n\ncfun\ncorrelation function\nγ\nspectrum\ninds\nbath correlator idx\n\n\n\n\n\n","category":"type"},{"location":"lib/bath.html#Common-interface","page":"Bath","title":"Common interface","text":"","category":"section"},{"location":"lib/bath.html","page":"Bath","title":"Bath","text":"correlation(τ, bath::OhmicBath)\nγ(ω, bath::OhmicBath)\nspectrum(ω, bath::OhmicBath)\nS(w, bath::OhmicBath; atol=1e-7)","category":"page"},{"location":"lib/bath.html#OpenQuantumBase.correlation-Tuple{Any, OhmicBath}","page":"Bath","title":"OpenQuantumBase.correlation","text":"correlation(τ, bath)\n\n\nCalculate the two point correlation function C(τ) of bath.\n\n\n\n\n\n","category":"method"},{"location":"lib/bath.html#OpenQuantumBase.γ-Tuple{Any, OhmicBath}","page":"Bath","title":"OpenQuantumBase.γ","text":"γ(ω, bath)\n\n\nCalculate spectral density γ(ω) of bath.\n\n\n\n\n\n","category":"method"},{"location":"lib/bath.html#OpenQuantumBase.spectrum-Tuple{Any, OhmicBath}","page":"Bath","title":"OpenQuantumBase.spectrum","text":"spectrum(ω, bath)\n\n\nCalculate spectral density γ(ω) of bath.\n\n\n\n\n\n","category":"method"},{"location":"lib/bath.html#OpenQuantumBase.S-Tuple{Any, OhmicBath}","page":"Bath","title":"OpenQuantumBase.S","text":"S(w, bath; kwargs...)\n\n\nCalculate the Lamb shift of bath. All the keyword arguments of quadgk function is supported.\n\n\n\n\n\n","category":"method"}]
}
