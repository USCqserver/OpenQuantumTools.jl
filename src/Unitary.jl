export calculate_unitary, unitary_check, solve_schrodinger

"""
    calculate_unitary(ğ‡; rtol=1e-6, atol=1e-8)

Calculate the unitary operator generated by Hamiltonian `ğ‡`. `ğ‡` is a callable object whose only argument is unitless time `` s = t / t_f ``.
"""
function calculate_unitary(ğ‡;rtol=1e-6,atol=1e-8)
    u0 = Matrix{ComplexF64}(I, size(ğ‡(0.0)))
    function f(du, u, p, t)
        hmat = -1.0im * ğ‡(t)
        mul!(du, hmat, u)
    end
    prob = ODEProblem(f, u0, (0.0,1.0))
    sol = solve(prob,Tsit5(),reltol=rtol,abstol=atol)
end

"""
    unitary_check(ğ”; rtol=1e-6, atol=1e-8)

Test if `ğ”` is a unitary matrix. The function checks how close both `` ğ”ğ”^â€  `` and `` ğ”^â€ ğ” `` are to `` I ``, with relative and absolute error given by `rtol`, `atol`.

# Examples
```julia-repl
julia> unitary_check(exp(-1.0im*5*0.5*Ïƒx))
true
```
"""
function unitary_check(ğ”::Array{T,2}; rtol=1e-6, atol=1e-8) where T<:Number
    a1 = isapprox(ğ”*ğ”', Matrix{eltype(ğ”)}(I,size(ğ”)),rtol=rtol,atol=atol)
    a2 = isapprox(ğ”'*ğ”, Matrix{eltype(ğ”)}(I,size(ğ”)),rtol=rtol,atol=atol)
    a1 && a2
end

function solve_schrodinger(ğ‡, u0; rtol=1e-6,atol=1e-8)
    function f(du, u, p, t)
        hmat = -1.0im * ğ‡(t)
        mul!(du, hmat, u)
    end
    prob = ODEProblem(f, u0, (0.0,1.0))
    sol = solve(prob,Tsit5(),reltol=rtol,abstol=atol)
end
