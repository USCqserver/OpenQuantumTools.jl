var documenterSearchIndex = {"docs": [

{
    "location": "index.html#",
    "page": "Home",
    "title": "Home",
    "category": "page",
    "text": ""
},

{
    "location": "index.html#HOME-1",
    "page": "Home",
    "title": "HOME",
    "category": "section",
    "text": "This is a quantum toolbox for Julia programming language.This package has the following features"
},

{
    "location": "index.html#Define-mathematical-symbols-and-operations-1",
    "page": "Home",
    "title": "Define mathematical symbols and operations",
    "category": "section",
    "text": "The package defines some commonly used mathematical symbols and operators. For example, the single qubit Pauli matrices are defined by σx, σy, σz and σi. One can simply calculate the tensor product of single qubits Pauli matrices byjulia> σx⊗σz\r\n4×4 Array{Complex{Float64},2}:\r\n 0.0+0.0im   0.0+0.0im  1.0+0.0im   0.0+0.0im\r\n 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -1.0+0.0im\r\n 1.0+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im\r\n 0.0+0.0im  -1.0+0.0im  0.0+0.0im  -0.0+0.0im"
},

{
    "location": "lib/public.html#QTool.PauliVec",
    "page": "Public",
    "title": "QTool.PauliVec",
    "category": "constant",
    "text": "PauliVec\n\nConstants for the eigen vectors of single qubit Pauli matrices. Indices 1, 2 and 3 corresponds to the eigen vectors of σ_x, σ_y and σ_z.\n\nExamples\n\njulia> σx*PauliVec[1][1] == PauliVec[1][1]\ntrue\n\n\n\n\n\n"
},

{
    "location": "lib/public.html#QTool.Hamiltonian",
    "page": "Public",
    "title": "QTool.Hamiltonian",
    "category": "type",
    "text": "Object to hold general time dependent Hamiltonians, whose form is assumed to be a summation of time dependent function times constant matrices. \n\n\n\n\n\n"
},

{
    "location": "lib/public.html#QTool.Hamiltonian-Tuple{Real}",
    "page": "Public",
    "title": "QTool.Hamiltonian",
    "category": "method",
    "text": "Evaluate the Hamiltonian at time t \n\n\n\n\n\n"
},

{
    "location": "lib/public.html#QTool.:⊗",
    "page": "Public",
    "title": "QTool.:⊗",
    "category": "function",
    "text": "⊗(A, B)\n\nCalculate the tensor product of A and B.\n\nExamples\n\njulia> σx⊗σz\n4×4 Array{Complex{Float64},2}:\n 0.0+0.0im   0.0+0.0im  1.0+0.0im   0.0+0.0im\n 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -1.0+0.0im\n 1.0+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im\n 0.0+0.0im  -1.0+0.0im  0.0+0.0im  -0.0+0.0im\n\n\n\n\n\n"
},

{
    "location": "lib/public.html#QTool.calculate_unitary-Tuple{Any}",
    "page": "Public",
    "title": "QTool.calculate_unitary",
    "category": "method",
    "text": "calculate_unitary(𝐇; rtol=1e-6, atol=1e-8)\n\nCalculate the unitary operator generated by Hamiltonian 𝐇. 𝐇 is a callable object whose only argument is unitless time s = t  t_f.\n\n\n\n\n\n"
},

{
    "location": "lib/public.html#QTool.check_positivity-Union{Tuple{T}, Tuple{Array{T,2}}} where T<:Number",
    "page": "Public",
    "title": "QTool.check_positivity",
    "category": "method",
    "text": "check_positivity(m)\n\nCheck if matrix m is positive. Internally it compares the minimum eigen value of m to 0.\n\n\n\n\n\n"
},

{
    "location": "lib/public.html#QTool.comm!-Tuple{Any,Any,Any}",
    "page": "Public",
    "title": "QTool.comm!",
    "category": "method",
    "text": "comm!(Y, A, B)\n\nCalculate the commutator of matrices A and B. Write the result in Y\n\n\n\n\n\n"
},

{
    "location": "lib/public.html#QTool.comm-Tuple{Any,Any}",
    "page": "Public",
    "title": "QTool.comm",
    "category": "method",
    "text": "comm(A, B)\n\nCalculate the commutator of matrices A and B\n\n\n\n\n\n"
},

{
    "location": "lib/public.html#QTool.construct_hamming_weight_op-Tuple{Int64,String}",
    "page": "Public",
    "title": "QTool.construct_hamming_weight_op",
    "category": "method",
    "text": "construct_hamming_weight_op(num_qubit::Int64, op::String)\n\nConstruct the Hamming weight operator for system of size num_qubit. The type of the Hamming weight operator is specified by op: \"x\", \"y\" or \"z\".\n\nExamples\n\njulia> construct_hamming_weight_op(2,\"z\")\n4×4 Array{Complex{Float64},2}:\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  2.0+0.0im\n\n\n\n\n\n"
},

{
    "location": "lib/public.html#QTool.eigen_state_continuation!-Tuple{Any}",
    "page": "Public",
    "title": "QTool.eigen_state_continuation!",
    "category": "method",
    "text": "eigen_state_continuation!(eigen_states)\n\nGive a list of eigen_states at different time, adjust the sign of each eigen state such that the inner product between the neighboring eigen states are positive.\n\n\n\n\n\n"
},

{
    "location": "lib/public.html#QTool.eigen_state_eval-Tuple{Any,AbstractArray{Float64,1}}",
    "page": "Public",
    "title": "QTool.eigen_state_eval",
    "category": "method",
    "text": "eigen_state_eval(hfun, t[, levels=[1,]])\n\nCalculate the eigen states of Hamiltonian hfun at each points of t. The output levels are specified by levels argument.\n\n\n\n\n\n"
},

{
    "location": "lib/public.html#QTool.eigen_sys_eval-Tuple{Any,AbstractArray{Float64,1}}",
    "page": "Public",
    "title": "QTool.eigen_sys_eval",
    "category": "method",
    "text": "eigen_sys_eval(hfun, t[, levels])\n\nCalculate the eigen values and eigen states of Hamiltonian hfun at each points of t. The output levels are specified by levels argument.\n\n\n\n\n\n"
},

{
    "location": "lib/public.html#QTool.eigen_value_eval-Tuple{Any,AbstractArray{Float64,1}}",
    "page": "Public",
    "title": "QTool.eigen_value_eval",
    "category": "method",
    "text": "eigen_value_eval(hfun, t[, levels])\n\nCalculate the eigen values of Hamiltonian hfun at each points of t. The output levels are specified by levels argument.\n\n\n\n\n\n"
},

{
    "location": "lib/public.html#QTool.gibbs_state-Tuple{Any,Any}",
    "page": "Public",
    "title": "QTool.gibbs_state",
    "category": "method",
    "text": "gibbs_state(h, β)\n\nCalculate the Gibbs state of the matrix h at temperature β.\n\nExamples\n\n```julia-repl julia> gibbs_state(σz, 0.1) 2×2 LinearAlgebra.Hermitian{Complex{Float64},Array{Complex{Float64},2}}:  0.450166+0.0im       0.0+0.0im       0.0-0.0im  0.549834+0.0im\n\n\n\n\n\n"
},

{
    "location": "lib/public.html#QTool.inst_population-Tuple{Any,Any,Any}",
    "page": "Public",
    "title": "QTool.inst_population",
    "category": "method",
    "text": "function inst_population(t, states, hamiltonian; level=1)\n\nFor a time series quantum states given by states, whose time points are given by t, calculate the population of instantaneous eigenstates of hamiltonian. The levels of the instantaneous eigenstates are specified by level, which can be any slice index.\n\n\n\n\n\n"
},

{
    "location": "lib/public.html#QTool.low_level_hamiltonian-Tuple{Any,Any}",
    "page": "Public",
    "title": "QTool.low_level_hamiltonian",
    "category": "method",
    "text": "low_level_hamiltonian(h, levels)\n\nCalculate the Hamiltonian h projected to lower energy subspace containing levels energy levels.\n\nExamples\n\n```julia-repl julia> lowlevelhamiltonian(σx⊗σx, 2) 4×4 LinearAlgebra.Hermitian{Complex{Float64},Array{Complex{Float64},2}}:  -0.5+0.0im   0.0+0.0im   0.0+0.0im   0.5+0.0im   0.0-0.0im  -0.5+0.0im   0.5+0.0im   0.0+0.0im   0.0-0.0im   0.5-0.0im  -0.5+0.0im   0.0+0.0im   0.5-0.0im   0.0-0.0im   0.0-0.0im  -0.5+0.0im\n\n\n\n\n\n"
},

{
    "location": "lib/public.html#QTool.matrix_decompose-Union{Tuple{T}, Tuple{Array{T,2},Array{Array{T,2},1}}} where T<:Number",
    "page": "Public",
    "title": "QTool.matrix_decompose",
    "category": "method",
    "text": "matrix_decompose(mat::Array{T,2}, basis::Array{Array{T,2},1})\n\nDecompse matrix mat onto matrix basis basis\n\nExamples\n\njulia> matrix_decompose(1.0*σx+2.0*σy+3.0*σz, [σx,σy,σz])\n3-element Array{Complex{Float64},1}:\n 1.0 + 0.0im\n 2.0 + 0.0im\n 3.0 + 0.0im\n\n\n\n\n\n"
},

{
    "location": "lib/public.html#QTool.minimum_gap-Tuple{Any}",
    "page": "Public",
    "title": "QTool.minimum_gap",
    "category": "method",
    "text": "minimum_gap(h)\n\nCalculate the minimum gap of Hamiltonian h using Optim.jl package.\n\n\n\n\n\n"
},

{
    "location": "lib/public.html#QTool.q_translate-Tuple{String}",
    "page": "Public",
    "title": "QTool.q_translate",
    "category": "method",
    "text": "q_translate(h::String)\n\nConvert a string h representing multi-qubits Pauli matrices summation into its numerical form.\n\nExamples\n\njulia> q_translate(\"X+2.0Z\")\n2×2 Array{Complex{Float64},2}:\n 2.0+0.0im   1.0+0.0im\n 1.0+0.0im  -2.0+0.0im\n\n\n\n\n\n"
},

{
    "location": "lib/public.html#QTool.temperature_2_beta-Tuple{Any}",
    "page": "Public",
    "title": "QTool.temperature_2_beta",
    "category": "method",
    "text": "temperature_2_beta(T; unit=:h)\n\nConvert temperature from mK to unit*β\n\n\n\n\n\n"
},

{
    "location": "lib/public.html#QTool.temperature_2_freq-Tuple{Any}",
    "page": "Public",
    "title": "QTool.temperature_2_freq",
    "category": "method",
    "text": "temperature_2_freq(T)\n\nConvert temperature from mK to GHz(physical unit)\n\n\n\n\n\n"
},

{
    "location": "lib/public.html#QTool.unitary_check-Union{Tuple{T}, Tuple{Array{T,2}}} where T<:Number",
    "page": "Public",
    "title": "QTool.unitary_check",
    "category": "method",
    "text": "unitary_check(𝐔; rtol=1e-6, atol=1e-8)\n\nTest if 𝐔 is a unitary matrix. The function checks how close both 𝐔𝐔^ and 𝐔^𝐔 are to I, with relative and absolute error given by rtol, atol.\n\nExamples\n\njulia> unitary_check(exp(-1.0im*5*0.5*σx))\ntrue\n\n\n\n\n\n"
},

{
    "location": "lib/public.html#",
    "page": "Public",
    "title": "Public",
    "category": "page",
    "text": "Modules = [QTool]\nPrivate = false"
},

]}
