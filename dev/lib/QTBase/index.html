<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Base · QuantumAnnealingTools</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>QuantumAnnealingTools</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../../tutorials/math_symbol/">Math Symbol</a></li><li><a class="toctext" href="../../tutorials/hamiltonians/">Hamiltonian</a></li><li><a class="toctext" href="../../tutorials/annealing/">Annealing</a></li></ul></li><li><span class="toctext">Library</span><ul><li class="current"><a class="toctext" href>Base</a><ul class="internal"></ul></li><li><a class="toctext" href="../bath/">Bath</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href>Base</a></li></ul><a class="edit-page" href="https://github.com/USCqserver/QuantumAnnealingTools.jl/blob/master/docs/src/lib/QTBase.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Base</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.PauliVec" href="#QTBase.PauliVec"><code>QTBase.PauliVec</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">PauliVec</code></pre><p>Constants for the eigenvectors of single qubit Pauli matrices. Indices 1, 2 and 3 corresponds to the eigenvectors of <span>$σ_x$</span>, <span>$σ_y$</span> and <span>$σ_z$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; σx*PauliVec[1][1] == PauliVec[1][1]
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/math_util.jl#L15-L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.AbstractAnnealingControl" href="#QTBase.AbstractAnnealingControl"><code>QTBase.AbstractAnnealingControl</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract type AbstractAnnealingControl</code></pre><p>Base for types defining various control protocols in quantum annealing process.</p></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/QTBase.jl#L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.AbstractAnnealingParams" href="#QTBase.AbstractAnnealingParams"><code>QTBase.AbstractAnnealingParams</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract type AbstractAnnealingParams</code></pre><p>Base for types defining <a href="http://docs.juliadiffeq.org/latest/tutorials/ode_example.html">parametrized functions</a> for annealing ODEs.</p></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/annealing/annealing_params.jl#L1">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.AbstractDenseHamiltonian" href="#QTBase.AbstractDenseHamiltonian"><code>QTBase.AbstractDenseHamiltonian</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract type AbstractDenseHamiltonian &lt;: AbstractHamiltonian{T&lt;:Number}</code></pre><p>Base for types defining Hamiltonians using dense matrices.</p></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/QTBase.jl#L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.AbstractHamiltonian" href="#QTBase.AbstractHamiltonian"><code>QTBase.AbstractHamiltonian</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract type AbstractHamiltonian</code></pre><p>Suptertype for Hamiltonians with elements of type <code>T</code>. Any Hamiltonian object should implement two interfaces: <code>H(t)</code> and <code>H(du, u, p, t)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/QTBase.jl#L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.AbstractOpenSys" href="#QTBase.AbstractOpenSys"><code>QTBase.AbstractOpenSys</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract type AbstractOpenSys</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/QTBase.jl#L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.AbstractSparseHamiltonian" href="#QTBase.AbstractSparseHamiltonian"><code>QTBase.AbstractSparseHamiltonian</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract type AbstractSparseHamiltonian &lt;: AbstractHamiltonian{T&lt;:Number}</code></pre><p>Base for types defining Hamiltonians using sparse matrices.</p></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/QTBase.jl#L29">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.Annealing" href="#QTBase.Annealing"><code>QTBase.Annealing</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct Annealing{hType, uType} &lt;: QTBase.AbstractAnnealing{hType,uType}</code></pre><p>Defines a quantum annealing process.</p><p><strong>Fields</strong></p><ul><li><p><code>H</code></p><p>Hamiltonian for the annealing.</p></li><li><p><code>u0</code></p><p>Initial state for the annealing.</p></li><li><p><code>sspan</code></p><p>Range of annealing parameter.</p></li><li><p><code>coupling</code></p><p>A list of system bath coupling operators(system part).</p></li><li><p><code>bath</code></p><p>A list of system bath coupling operators(bath part).</p></li><li><p><code>control</code></p><p>Additional control protocols for the annealing.</p></li><li><p><code>tstops</code></p><p>Extra times that the timestepping algorithm must step to.</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/annealing/annealing_type.jl#L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.DaviesGenerator" href="#QTBase.DaviesGenerator"><code>QTBase.DaviesGenerator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct DaviesGenerator &lt;: AbstractOpenSys</code></pre><p>Defines Davies generator</p><p><strong>Fields</strong></p><ul><li><p><code>coupling</code></p></li><li><p><code>γ</code></p></li><li><p><code>S</code></p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/opensys/davies.jl#L1">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.DenseHamiltonian" href="#QTBase.DenseHamiltonian"><code>QTBase.DenseHamiltonian</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct DenseHamiltonian{T&lt;:Complex} &lt;: AbstractDenseHamiltonian{T&lt;:Complex}</code></pre><p>Defines a time dependent Hamiltonian object with dense Matrices. All the values in the input is assumed to have the unit of <code>GHz</code>. An additional <span>$2π$</span> factor will be multiplied to each matrices when constructing the object.</p><p><strong>Fields</strong></p><ul><li><p><code>f</code></p><p>List of time dependent functions</p></li><li><p><code>m</code></p><p>List of constant matrices</p></li><li><p><code>u_cache</code></p><p>Internal cache</p></li><li><p><code>size</code></p><p>Size</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/hamiltonian/dense_hamiltonian.jl#L1">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.DenseHamiltonian-Tuple{Any,Any}" href="#QTBase.DenseHamiltonian-Tuple{Any,Any}"><code>QTBase.DenseHamiltonian</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">function DenseHamiltonian(funcs, mats)</code></pre><p>Constructor of DenseHamiltonian object. <code>funcs</code> and <code>mats</code> are a list of time dependent functions and the corresponding matrices.</p></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/hamiltonian/dense_hamiltonian.jl#L22-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.DenseHamiltonian-Tuple{Real}" href="#QTBase.DenseHamiltonian-Tuple{Real}"><code>QTBase.DenseHamiltonian</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">function (h::DenseHamiltonian)(t::Real)</code></pre><p>Calling the Hamiltonian returns the value <span>$2πH(t)$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/hamiltonian/dense_hamiltonian.jl#L36-L40">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.OpenSysSets" href="#QTBase.OpenSysSets"><code>QTBase.OpenSysSets</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract type OpenSysSets &lt;: AbstractOpenSys</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/QTBase.jl#L59">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.SparseHamiltonian" href="#QTBase.SparseHamiltonian"><code>QTBase.SparseHamiltonian</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct SparseHamiltonian{T} &lt;: AbstractSparseHamiltonian{T}</code></pre><p>Defines a time dependent Hamiltonian object with sparse Matrices. All the values in the input is assumed to have the unit of <code>GHz</code>. An additional <span>$2π$</span> factor will be multiplied to each matrices when constructing the object.</p><p><strong>Fields</strong></p><ul><li><p><code>f</code></p><p>List of time dependent functions</p></li><li><p><code>m</code></p><p>List of constant matrices</p></li><li><p><code>u_cache</code></p><p>Internal cache</p></li><li><p><code>size</code></p><p>Size</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/hamiltonian/sparse_hamiltonian.jl#L1">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.SparseHamiltonian-Tuple{Any,Any}" href="#QTBase.SparseHamiltonian-Tuple{Any,Any}"><code>QTBase.SparseHamiltonian</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">function SparseHamiltonian(funcs, mats)</code></pre><p>Constructor of SparseHamiltonian object. <code>funcs</code> and <code>mats</code> are a list of time dependent functions and the corresponding matrices.</p></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/hamiltonian/sparse_hamiltonian.jl#L22-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.SparseHamiltonian-Tuple{Real}" href="#QTBase.SparseHamiltonian-Tuple{Real}"><code>QTBase.SparseHamiltonian</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">function (h::SparseHamiltonian)(t::Real)</code></pre><p>Calling the Hamiltonian returns the value <span>$2πH(t)$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/hamiltonian/sparse_hamiltonian.jl#L36-L40">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.:⊗" href="#QTBase.:⊗"><code>QTBase.:⊗</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">⊗(A, B)</code></pre><p>Calculate the tensor product of <code>A</code> and <code>B</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; σx⊗σz
4×4 Array{Complex{Float64},2}:
 0.0+0.0im   0.0+0.0im  1.0+0.0im   0.0+0.0im
 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -1.0+0.0im
 1.0+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im
 0.0+0.0im  -1.0+0.0im  0.0+0.0im  -0.0+0.0im</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/math_util.jl#L28-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.beta_2_temperature-Tuple{Any}" href="#QTBase.beta_2_temperature-Tuple{Any}"><code>QTBase.beta_2_temperature</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">beta_2_temperature(β)</code></pre><p>Convert thermodynamic <code>β</code> in the unit of inverse angular frequency to physical temperature <code>T</code> in GHz.</p></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/unit_util.jl#L26-L30">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.check_positivity-Union{Tuple{Array{T,2}}, Tuple{T}} where T&lt;:Number" href="#QTBase.check_positivity-Union{Tuple{Array{T,2}}, Tuple{T}} where T&lt;:Number"><code>QTBase.check_positivity</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">check_positivity(m)</code></pre><p>Check if matrix <code>m</code> is positive. Internally it compares the minimum eigen value of <code>m</code> to 0.</p></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/math_util.jl#L64-L68">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.check_unitary-Union{Tuple{Array{T,2}}, Tuple{T}} where T&lt;:Number" href="#QTBase.check_unitary-Union{Tuple{Array{T,2}}, Tuple{T}} where T&lt;:Number"><code>QTBase.check_unitary</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">check_unitary(𝐔; rtol=1e-6, atol=1e-8)</code></pre><p>Test if <code>𝐔</code> is a unitary matrix. The function checks how close both <span>$𝐔𝐔^†$</span> and <span>$𝐔^†𝐔$</span> are to <span>$I$</span>, with relative and absolute error given by <code>rtol</code>, <code>atol</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; check_unitary(exp(-1.0im*5*0.5*σx))
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/math_util.jl#L194-L204">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.collective_operator-Tuple{Any,Any}" href="#QTBase.collective_operator-Tuple{Any,Any}"><code>QTBase.collective_operator</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">collective_operator(op, num_qubit; sp=false)</code></pre><p>Construct the collective operator for a system of <code>num_qubit</code> qubits. <code>op</code> is the name of the collective Pauli matrix. For example, the following code construct an <span>$IZ + ZI$</span> matrix. Generate sparse matrix when <code>sp</code> is set to true.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; collective_operator(&quot;z&quot;, 2)
4×4 Array{Complex{Float64},2}:
 2.0+0.0im  0.0+0.0im  0.0+0.0im   0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im   0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im   0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  -2.0+0.0im</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/matrix_util.jl#L73-L87">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.construct_hamming_weight_op-Tuple{Int64,String}" href="#QTBase.construct_hamming_weight_op-Tuple{Int64,String}"><code>QTBase.construct_hamming_weight_op</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">construct_hamming_weight_op(num_qubit::Int64, op::String; sp=false)</code></pre><p>Construct the Hamming weight operator for system of size <code>num_qubit</code>. The type of the Hamming weight operator is specified by op: &quot;x&quot;, &quot;y&quot; or &quot;z&quot;. Generate sparse matrix when <code>sp</code> is set to true.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; construct_hamming_weight_op(2,&quot;z&quot;)
4×4 Array{Complex{Float64},2}:
 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  2.0+0.0im</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/matrix_util.jl#L110-L124">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.cpvagk" href="#QTBase.cpvagk"><code>QTBase.cpvagk</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">cpvagk(f, t, a, b, tol=256*eps())</code></pre><p>Calculate the Cauchy principle value integration of the form <span>$𝒫∫_a^b f(x)/(x-t) dx$</span>. The algorithm is adapted from <a href="https://www.sciencedirect.com/science/article/pii/S0377042715004422">P. Keller, 02.01.2015</a></p></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/integration/cpvagk.jl#L1-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.eigen_decomp-Tuple{AbstractDenseHamiltonian,Any}" href="#QTBase.eigen_decomp-Tuple{AbstractDenseHamiltonian,Any}"><code>QTBase.eigen_decomp</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">function eigen_decomp(h::AbstractDenseHamiltonian, t; level = 2) -&gt; (w, v)</code></pre><p>Calculate the eigen value decomposition of the Hamiltonian <code>h</code> at time <code>t</code>. Keyword argument <code>level</code> specifies the number of levels to keep in the output. <code>w</code> is a vector of eigenvalues and <code>v</code> is a matrix of the eigenvectors in the columns. (The <code>k</code>th eigenvector can be obtained from the slice <code>w[:, k]</code>.) <code>w</code> will be in unit of <code>GHz</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/hamiltonian/dense_hamiltonian.jl#L96-L100">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.eigen_decomp-Tuple{AbstractSparseHamiltonian,Any}" href="#QTBase.eigen_decomp-Tuple{AbstractSparseHamiltonian,Any}"><code>QTBase.eigen_decomp</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">function eigen_decomp(h::AbstractSparseHamiltonian, t; level = 2) -&gt; (w, v)</code></pre><p>Calculate the eigen value decomposition of the Hamiltonian <code>h</code> at time <code>t</code>. Keyword argument <code>level</code> specifies the number of levels to keep in the output. <code>w</code> is a vector of eigenvalues and <code>v</code> is a matrix of the eigenvectors in the columns. (The <code>k</code>th eigenvector can be obtained from the slice <code>w[:, k]</code>.) <code>w</code> will be in unit of <code>GHz</code>. <a href="https://julialinearalgebra.github.io/Arpack.jl/stable/">Arpack.jl</a> is used internally for solving eigensystems of sparse matrices. Any keyword arguments of <code>eigs</code> function is supported here.</p></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/hamiltonian/sparse_hamiltonian.jl#L68-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.eigen_sys-Tuple{Any,AbstractArray{Float64,1}}" href="#QTBase.eigen_sys-Tuple{Any,AbstractArray{Float64,1}}"><code>QTBase.eigen_sys</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">eigen_sys(hfun, t; levels=2, tol=1e-4)</code></pre><p>Calculate the eigen values and eigen states of Hamiltonian <code>hfun</code> at each points of vector <code>t</code>. The output keeps the lowest <code>levels</code> eigenstates and their corresponding eigenvalues. <code>tol</code> specifies the error tolerance for sparse matrices decomposition. Output (vals, vecs) whose dimensions are (levels, tdim) and (hdim, levels, tdim) respectively.</p></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/math_util.jl#L80-L84">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.evaluate-Tuple{AbstractHamiltonian,Any}" href="#QTBase.evaluate-Tuple{AbstractHamiltonian,Any}"><code>QTBase.evaluate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">evaluate(H::AbstractHamiltonian, t)</code></pre><p>Evaluate the time dependent Hamiltonian at time t with the unit of <code>GHz</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/hamiltonian/util.jl#L12-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.freq_2_temperature-Tuple{Any}" href="#QTBase.freq_2_temperature-Tuple{Any}"><code>QTBase.freq_2_temperature</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">freq_2_temperature(freq)</code></pre><p>Convert frequency in GHz to temperature in mK.</p></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/unit_util.jl#L35-L39">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.gibbs_state-Tuple{Any,Any}" href="#QTBase.gibbs_state-Tuple{Any,Any}"><code>QTBase.gibbs_state</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">gibbs_state(h, β)</code></pre><p>Calculate the Gibbs state of the matrix <code>h</code> at temperature <code>T</code> (mK).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; gibbs_state(σz, 10)
2×2 Array{Complex{Float64},2}:
 0.178338+0.0im       0.0+0.0im
      0.0+0.0im  0.821662+0.0im</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/math_util.jl#L136-L148">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.inst_population-Tuple{Any,Any,Any}" href="#QTBase.inst_population-Tuple{Any,Any,Any}"><code>QTBase.inst_population</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">function inst_population(t, states, hamiltonian; level=1)</code></pre><p>For a time series quantum states given by <code>states</code>, whose time points are given by <code>t</code>, calculate the population of instantaneous eigenstates of <code>hamiltonian</code>. The levels of the instantaneous eigenstates are specified by <code>level</code>, which can be any slice index.</p></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/math_util.jl#L106-L110">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.local_field_term-Tuple{Any,Any,Any}" href="#QTBase.local_field_term-Tuple{Any,Any,Any}"><code>QTBase.local_field_term</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">local_field_term(h, idx, num_qubit; sp=false)</code></pre><p>Construct local Hamiltonian of the form <span>$∑hᵢσᵢᶻ$</span>. <code>idx</code> is the index of all local field terms and <code>h</code> is a list of the corresponding weights. <code>num_qubit</code> is the total number of qubits. Generate sparse matrix when <code>sp</code> is set to true.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; local_field_term([1.0, 0.5], [1, 2], 2) == σz⊗σi+0.5σi⊗σz
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/matrix_util.jl#L137-L147">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.low_level_hamiltonian-Tuple{Any,Any}" href="#QTBase.low_level_hamiltonian-Tuple{Any,Any}"><code>QTBase.low_level_hamiltonian</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">low_level_hamiltonian(h, levels)</code></pre><p>Calculate the Hamiltonian <code>h</code> projected to lower energy subspace containing <code>levels</code> energy levels.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; low_level_hamiltonian(σx⊗σx, 2)
4×4 Array{Complex{Float64},2}:
 -0.5+0.0im   0.0+0.0im   0.0+0.0im   0.5+0.0im
  0.0+0.0im  -0.5+0.0im   0.5+0.0im   0.0+0.0im
  0.0+0.0im   0.5+0.0im  -0.5+0.0im   0.0+0.0im
  0.5+0.0im   0.0+0.0im   0.0+0.0im  -0.5+0.0im</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/math_util.jl#L163-L177">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.matrix_decompose-Union{Tuple{T}, Tuple{Array{T,2},Array{Array{T,2},1}}} where T&lt;:Number" href="#QTBase.matrix_decompose-Union{Tuple{T}, Tuple{Array{T,2},Array{Array{T,2},1}}} where T&lt;:Number"><code>QTBase.matrix_decompose</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">matrix_decompose(mat::Matrix{T}, basis::Array{Matrix{T},1})</code></pre><p>Decompse matrix <code>mat</code> onto matrix basis <code>basis</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; matrix_decompose(1.0*σx+2.0*σy+3.0*σz, [σx,σy,σz])
3-element Array{Complex{Float64},1}:
 1.0 + 0.0im
 2.0 + 0.0im
 3.0 + 0.0im</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/math_util.jl#L45-L58">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.q_translate-Tuple{String}" href="#QTBase.q_translate-Tuple{String}"><code>QTBase.q_translate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">q_translate(h::String)</code></pre><p>Convert a string <code>h</code> representing multi-qubits Pauli matrices summation into its numerical form.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; q_translate(&quot;X+2.0Z&quot;)
2×2 Array{Complex{Float64},2}:
 2.0+0.0im   1.0+0.0im
 1.0+0.0im  -2.0+0.0im</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/matrix_util.jl#L1-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.q_translate_state-Tuple{String}" href="#QTBase.q_translate_state-Tuple{String}"><code>QTBase.q_translate_state</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">q_translate_state(h::String; normal=false)</code></pre><p>Convert a string representation of quantum state to a vector. The keyword argument <code>normal</code> indicates whether to normalize the output vector. (Currently only &#39;0&#39; and &#39;1&#39; are supported)</p><p><strong>Examples</strong></p><p>Single term:</p><pre><code class="language-julia-repl">julia&gt; q_translate_state(&quot;001&quot;)
8-element Array{Complex{Float64},1}:
 0.0 + 0.0im
 1.0 + 0.0im
 0.0 + 0.0im
 0.0 + 0.0im
 0.0 + 0.0im
 0.0 + 0.0im
 0.0 + 0.0im
 0.0 + 0.0im</code></pre><p>Multiple terms:</p><pre><code class="language-julia-repl">julia&gt; q_translate_state(&quot;(101)+(001)&quot;, normal=true)
8-element Array{Complex{Float64},1}:
                0.0 + 0.0im
 0.7071067811865475 + 0.0im
                0.0 + 0.0im
                0.0 + 0.0im
                0.0 + 0.0im
 0.7071067811865475 + 0.0im
                0.0 + 0.0im
                0.0 + 0.0im</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/matrix_util.jl#L177-L209">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.single_clause-NTuple{4,Any}" href="#QTBase.single_clause-NTuple{4,Any}"><code>QTBase.single_clause</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">single_clause(ops, q_ind, weight, num_qubit; sp=false)</code></pre><p>Construct a single clause of the multi-qubits Hamiltonian. <code>ops</code> is a list of Pauli operator names which appears in this clause. <code>q_ind</code> is the list of indices corresponding to the Pauli matrices in <code>ops</code>. <code>weight</code> is the constant factor of this clause. <code>num_qubit</code> is the total number of qubits. A sparse matrix can be construct by setting <code>sp</code> to <code>true</code>. The following example construct a clause of <span>$Z_1 I Z_3/2$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; single_clause([&quot;z&quot;, &quot;z&quot;], [1, 3], 0.5, 3)
8×8 Array{Complex{Float64},2}:
 0.5+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im
 0.0+0.0im  -0.5+0.0im  0.0+0.0im  -0.0+0.0im   0.0+0.0im  -0.0+0.0im   0.0+0.0im  -0.0+0.0im
 0.0+0.0im   0.0+0.0im  0.5+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im
 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -0.5+0.0im   0.0+0.0im  -0.0+0.0im   0.0+0.0im  -0.0+0.0im
 0.0+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im  -0.5+0.0im  -0.0+0.0im  -0.0+0.0im  -0.0+0.0im
 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -0.0+0.0im  -0.0+0.0im   0.5-0.0im  -0.0+0.0im   0.0-0.0im
 0.0+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im  -0.0+0.0im  -0.0+0.0im  -0.5+0.0im  -0.0+0.0im
 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -0.0+0.0im  -0.0+0.0im   0.0-0.0im  -0.0+0.0im   0.5-0.0im</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/matrix_util.jl#L33-L51">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.standard_driver-Tuple{Any}" href="#QTBase.standard_driver-Tuple{Any}"><code>QTBase.standard_driver</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">standard_driver(num_qubit; sp=false)</code></pre><p>Construct the standard driver Hamiltonian for a system of <code>num_qubit</code> qubits. For example, a two qubits standard driver matrix is <span>$IX + XI$</span>. Generate sparse matrix when <code>sp</code> is set to true.</p></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/matrix_util.jl#L97-L101">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.temperature_2_beta-Tuple{Any}" href="#QTBase.temperature_2_beta-Tuple{Any}"><code>QTBase.temperature_2_beta</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">temperature_2_beta(T; unit=:ħ)</code></pre><p>Convert physical temperature <code>T</code> in mK to thermodynamic <code>β</code> in the unit of inverse angular frequency.</p></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/unit_util.jl#L8-L12">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.temperature_2_freq-Tuple{Any}" href="#QTBase.temperature_2_freq-Tuple{Any}"><code>QTBase.temperature_2_freq</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">temperature_2_freq(T)</code></pre><p>Convert temperature from mK to GHz.</p></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/unit_util.jl#L17-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QTBase.two_local_term-Tuple{Any,Any,Any}" href="#QTBase.two_local_term-Tuple{Any,Any,Any}"><code>QTBase.two_local_term</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">two_local_term(j, idx, num_qubit; sp=false)</code></pre><p>Construct local Hamiltonian of the form <span>$∑Jᵢⱼσᵢᶻσⱼᶻ$</span>. <code>idx</code> is the index of all two local terms and <code>j</code> is a list of the corresponding weights. <code>num_qubit</code> is the total number of qubits. Generate sparse matrix when <code>sp</code> is set to true.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; two_local_term([1.0, 0.5], [[1,2], [1,3]], 3) == σz⊗σz⊗σi + 0.5σz⊗σi⊗σz
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/f16dad980420809fbc436095fc677e92ebf8287f/src/matrix_util.jl#L157-L167">source</a></section><footer><hr/><a class="previous" href="../../tutorials/annealing/"><span class="direction">Previous</span><span class="title">Annealing</span></a><a class="next" href="../bath/"><span class="direction">Next</span><span class="title">Bath</span></a></footer></article></body></html>
