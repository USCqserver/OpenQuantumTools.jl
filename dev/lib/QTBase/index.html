<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Base ¬∑ QuantumAnnealingTools</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">QuantumAnnealingTools</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/math_symbol/">Math Symbol</a></li><li><a class="tocitem" href="../../tutorials/hamiltonians/">Hamiltonian</a></li><li><a class="tocitem" href="../../tutorials/couplings/">Coupling</a></li><li><a class="tocitem" href="../../tutorials/bath/">Bath</a></li><li><a class="tocitem" href="../../tutorials/annealing/">Annealing</a></li><li><a class="tocitem" href="../../tutorials/solver/">Solver</a></li></ul></li><li><span class="tocitem">Library</span><ul><li class="is-active"><a class="tocitem" href>Base</a></li><li><a class="tocitem" href="../bath/">Bath</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Base</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Base</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/USCqserver/QuantumAnnealingTools.jl/blob/master/docs/src/lib/QTBase.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><article class="docstring"><header><a class="docstring-binding" id="QTBase.PauliVec" href="#QTBase.PauliVec"><code>QTBase.PauliVec</code></a> ‚Äî <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">PauliVec</code></pre><p>Constants for the eigenvectors of single qubit Pauli matrices. Indices 1, 2 and 3 corresponds to the eigenvectors of <span>$œÉ_x$</span>, <span>$œÉ_y$</span> and <span>$œÉ_z$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; œÉx*PauliVec[1][1] == PauliVec[1][1]
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/math_util.jl#L17-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.AbstractAnnealing" href="#QTBase.AbstractAnnealing"><code>QTBase.AbstractAnnealing</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractAnnealing</code></pre><p>Base for types defining quantum annealing process.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/QTBase.jl#L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.AbstractBath" href="#QTBase.AbstractBath"><code>QTBase.AbstractBath</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractBath</code></pre><p>Base for types defining bath object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/QTBase.jl#L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.AbstractCouplings" href="#QTBase.AbstractCouplings"><code>QTBase.AbstractCouplings</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractCouplings</code></pre><p>Base for types defining system bath coupling operators in open quantum system models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/QTBase.jl#L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.AbstractDenseHamiltonian" href="#QTBase.AbstractDenseHamiltonian"><code>QTBase.AbstractDenseHamiltonian</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractDenseHamiltonian &lt;: AbstractHamiltonian{T&lt;:Number}</code></pre><p>Base for types defining Hamiltonians using dense matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/QTBase.jl#L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.AbstractHamiltonian" href="#QTBase.AbstractHamiltonian"><code>QTBase.AbstractHamiltonian</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractHamiltonian</code></pre><p>Suptertype for Hamiltonians with elements of type <code>T</code>. Any Hamiltonian object should implement two interfaces: <code>H(t)</code> and <code>H(du, u, p, t)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/QTBase.jl#L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.AbstractLiouvillian" href="#QTBase.AbstractLiouvillian"><code>QTBase.AbstractLiouvillian</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractLiouvillian</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/QTBase.jl#L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.AbstractSparseHamiltonian" href="#QTBase.AbstractSparseHamiltonian"><code>QTBase.AbstractSparseHamiltonian</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractSparseHamiltonian &lt;: AbstractHamiltonian{T&lt;:Number}</code></pre><p>Base for types defining Hamiltonians using sparse matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/QTBase.jl#L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.AdiabaticFrameHamiltonian" href="#QTBase.AdiabaticFrameHamiltonian"><code>QTBase.AdiabaticFrameHamiltonian</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct AdiabaticFrameHamiltonian{T} &lt;: AbstractDenseHamiltonian{T}</code></pre><p>Defines a time dependent Hamiltonian in adiabatic frame.</p><p><strong>Fields</strong></p><ul><li><p><code>geometric</code></p><p>Geometric part</p></li><li><p><code>diagonal</code></p><p>Adiabatic part</p></li><li><p><code>size</code></p><p>Size of the Hamiltonian</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/hamiltonian/adiabatic_frame_hamiltonian.jl#L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.AdiabaticFrameHamiltonian-Tuple{Any,Any}" href="#QTBase.AdiabaticFrameHamiltonian-Tuple{Any,Any}"><code>QTBase.AdiabaticFrameHamiltonian</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function AdiabaticFrameHamiltonian(œâfuns, geofuns)</code></pre><p>Constructor of adiabatic frame Hamiltonian. <code>œâfuns</code> is a 1-D array of functions which specify the eigen energies (in <code>GHz</code>) of the Hamiltonian. <code>geofuns</code> is a 1-D array of functions which specifies the geometric phases of the Hamiltonian. <code>geofuns</code> can be thought as a flattened lower triangular matrix (without diagonal elements) in column-major order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/hamiltonian/adiabatic_frame_hamiltonian.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.Annealing" href="#QTBase.Annealing"><code>QTBase.Annealing</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct Annealing{hType, uType} &lt;: AbstractAnnealing{hType,uType}</code></pre><p>Defines a quantum annealing process.</p><p><strong>Fields</strong></p><ul><li><p><code>H</code></p><p>Hamiltonian for the annealing.</p></li><li><p><code>u0</code></p><p>Initial state for the annealing.</p></li><li><p><code>annealing_parameter</code></p><p>Function of annealing parameter s wrt to t</p></li><li><p><code>interactions</code></p><p>A system bath interaction set.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/annealing/annealing_type.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.ConstantCouplings" href="#QTBase.ConstantCouplings"><code>QTBase.ConstantCouplings</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ConstantCouplings &lt;: AbstractCouplings</code></pre><p>Defines constant system bath coupling operators.</p><p><strong>Fields</strong></p><ul><li><p><code>mats</code></p><p>1-D array for independent coupling operators</p></li><li><p><code>str_rep</code></p><p>String representation for the coupling (for display purpose)</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/coupling/coupling.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.ConstantCouplings-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:AbstractString" href="#QTBase.ConstantCouplings-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:AbstractString"><code>QTBase.ConstantCouplings</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function ConstantCouplings(c::Vector{T}; sp = false, unit=:h) where T &lt;: AbstractString</code></pre><p>If the first argument is a 1-D array of strings. The constructor will automatically construct the matrics represented by the string representations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/coupling/coupling.jl#L47-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.ConstantCouplings-Union{Tuple{Union{Array{Array{T,2},1}, Array{SparseMatrixCSC{T,Int64},1}}}, Tuple{T}} where T&lt;:Number" href="#QTBase.ConstantCouplings-Union{Tuple{Union{Array{Array{T,2},1}, Array{SparseMatrixCSC{T,Int64},1}}}, Tuple{T}} where T&lt;:Number"><code>QTBase.ConstantCouplings</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function ConstantCouplings(mats; str_rep=nothing, unit=:h)</code></pre><p>Constructor of <code>ConstantCouplings</code> object. <code>mats</code> is 1-D array of matrices. <code>str_rep</code> is the optional string representation of the coupling terms. <code>unit</code> is the unit one ‚Äì <code>:h</code> or <code>:ƒß</code>. The <code>mats</code> will be scaled by <span>$2œÄ$</span> is unit is <code>:h</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/coupling/coupling.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.CustomBath" href="#QTBase.CustomBath"><code>QTBase.CustomBath</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct CustomBath &lt;: AbstractBath</code></pre><p>An custum bath object defined by the two-point correlation function and the corresponding spectrum.</p><ul><li><p><code>cfun</code></p><p>correlation function</p></li><li><p><code>Œ≥</code></p><p>spectrum</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/bath/custom.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.CustomCouplings" href="#QTBase.CustomCouplings"><code>QTBase.CustomCouplings</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct CustomCouplings &lt;: AbstractTimeDependentCouplings</code></pre><p><code>CustomCouplings</code> is a container for any user defined coupling operators.</p><p><strong>Fields</strong></p><ul><li><p><code>coupling</code></p><p>A 1-D array of callable objects that returns coupling matrices</p></li><li><p><code>size</code></p><p>Size of the coupling operator</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/coupling/coupling.jl#L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.CustomDenseHamiltonian" href="#QTBase.CustomDenseHamiltonian"><code>QTBase.CustomDenseHamiltonian</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct CustomDenseHamiltonian{T&lt;:Number, in_place} &lt;: AbstractDenseHamiltonian{T&lt;:Number}</code></pre><p>Defines a time dependent Hamiltonian object with custom function.</p><p><strong>Fields</strong></p><ul><li><p><code>f</code></p><p>Function for the Hamiltonian <code>H(s)</code></p></li><li><p><code>u_cache</code></p><p>Internal cache</p></li><li><p><code>size</code></p><p>Size</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/hamiltonian/custom_hamiltonian.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.DaviesGenerator" href="#QTBase.DaviesGenerator"><code>QTBase.DaviesGenerator</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct DaviesGenerator &lt;: AbstractLiouvillian</code></pre><p>Defines Davies generator</p><p><strong>Fields</strong></p><ul><li><p><code>coupling</code></p><p>System bath coupling operators</p></li><li><p><code>Œ≥</code></p><p>Spectrum density</p></li><li><p><code>S</code></p><p>Lambshift spectrum density</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/opensys/davies.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.DenseHamiltonian" href="#QTBase.DenseHamiltonian"><code>QTBase.DenseHamiltonian</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct DenseHamiltonian{T&lt;:Number} &lt;: AbstractDenseHamiltonian{T&lt;:Number}</code></pre><p>Defines a time dependent Hamiltonian object with dense Matrices.</p><p><strong>Fields</strong></p><ul><li><p><code>f</code></p><p>List of time dependent functions</p></li><li><p><code>m</code></p><p>List of constant matrices</p></li><li><p><code>u_cache</code></p><p>Internal cache</p></li><li><p><code>size</code></p><p>Size</p></li><li><p><code>EIGS</code></p><p>Eigen decomposition routine</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/hamiltonian/dense_hamiltonian.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.DenseHamiltonian-Tuple{Any,Any}" href="#QTBase.DenseHamiltonian-Tuple{Any,Any}"><code>QTBase.DenseHamiltonian</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DenseHamiltonian(funcs, mats; unit, EIGS)
</code></pre><p>Constructor of DenseHamiltonian object. <code>funcs</code> and <code>mats</code> are a list of time dependent functions and the corresponding matrices. <code>unit</code> is the unit one ‚Äì <code>:h</code> or <code>:ƒß</code>. The <code>mats</code> will be scaled by <span>$2œÄ$</span> if unit is <code>:h</code>.</p><p><code>EIGS</code> is the initializer for the eigen decomposition routine for the Hamiltonian. It should return a function of signature: <code>(H, s, lvl) -&gt; (w, v)</code>. The default method <code>EIGEN_DEFAULT</code> will use <code>LAPACK</code> routine.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/hamiltonian/dense_hamiltonian.jl#L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.DenseHamiltonian-Tuple{Real}" href="#QTBase.DenseHamiltonian-Tuple{Real}"><code>QTBase.DenseHamiltonian</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function (h::DenseHamiltonian)(s::Real)</code></pre><p>Calling the Hamiltonian returns the value <span>$2œÄH(s)$</span>. The argument <code>s</code> is in the unitless time. The returned matrix is in angular frequency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/hamiltonian/dense_hamiltonian.jl#L51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.EnsembleFluctuator" href="#QTBase.EnsembleFluctuator"><code>QTBase.EnsembleFluctuator</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct EnsembleFluctuator{T} &lt;: AbstractBath</code></pre><p>An ensemble of random telegraph noise.</p><ul><li><p><code>f</code></p><p>A list of RTNs</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/bath/spin_fluc.jl#L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.Fluctuators" href="#QTBase.Fluctuators"><code>QTBase.Fluctuators</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct Fluctuators &lt;: AbstractLiouvillian</code></pre><p>Defines a fluctuator ensemble controller</p><p><strong>Fields</strong></p><ul><li><p><code>coupling</code></p><p>system-bath coupling operator</p></li><li><p><code>dist</code></p><p>waitting time distribution for every fluctuators</p></li><li><p><code>b0</code></p><p>cache for each fluctuator value</p></li><li><p><code>next_idx</code></p><p>index of the fluctuator to be flipped next</p></li><li><p><code>next_œÑ</code></p><p>time interval for next flip event</p></li><li><p><code>n</code></p><p>noise value</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/opensys/stochastic.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.InplaceUnitary" href="#QTBase.InplaceUnitary"><code>QTBase.InplaceUnitary</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct InplaceUnitary</code></pre><p>A tag for inplace unitary function. <code>func(cache, t)</code> is the actual inplace update function.</p><p><strong>Fields</strong></p><ul><li><p><code>func</code></p><p>inplace update function</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/integration/ext_util.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.Interaction" href="#QTBase.Interaction"><code>QTBase.Interaction</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Interaction</code></pre><p>An object to hold system operator and the corresponding bath object.</p><ul><li><p><code>coupling</code></p><p>system operator</p></li><li><p><code>bath</code></p><p>bath coupling to the system operator</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/coupling/interaction.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.InteractionSet" href="#QTBase.InteractionSet"><code>QTBase.InteractionSet</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct InteractionSet{T&lt;:Tuple}</code></pre><p>An container for different system-bath interactions.</p><ul><li><p><code>interactions</code></p><p>A tuple of Interaction</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/coupling/interaction.jl#L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.InterpDenseHamiltonian" href="#QTBase.InterpDenseHamiltonian"><code>QTBase.InterpDenseHamiltonian</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct InterpDenseHamiltonian{T} &lt;: AbstractDenseHamiltonian{T}</code></pre><p>Defines interpolating DenseHamiltonian object</p><p><strong>Fields</strong></p><ul><li><p><code>interp_obj</code></p><p>Interpolating object</p></li><li><p><code>size</code></p><p>Size</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/hamiltonian/interp_hamiltonian.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.InterpSparseHamiltonian" href="#QTBase.InterpSparseHamiltonian"><code>QTBase.InterpSparseHamiltonian</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct InterpSparseHamiltonian{T} &lt;: AbstractSparseHamiltonian{T}</code></pre><p>Defines interpolating SparseHamiltonian object</p><p><strong>Fields</strong></p><ul><li><p><code>interp_obj</code></p><p>Interpolating object</p></li><li><p><code>size</code></p><p>Size</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/hamiltonian/interp_hamiltonian.jl#L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.ODEParams" href="#QTBase.ODEParams"><code>QTBase.ODEParams</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ODEParams</code></pre><p>Defines a complete set of ODE parameters, which includes Hamiltonian, total annealing time, open system and control objects.</p><p><strong>Fields</strong></p><ul><li><p><code>L</code></p><p>Hamiltonian</p></li><li><p><code>tf</code></p><p>Total annealing time</p></li><li><p><code>annealing_parameter</code></p><p>Function to convert physical time to annealing parameter</p></li><li><p><code>control</code></p><p>Annealing control object</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/annealing/annealing_type.jl#L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.OhmicBath" href="#QTBase.OhmicBath"><code>QTBase.OhmicBath</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OhmicBath</code></pre><p>Ohmic bath object to hold a particular parameter set.</p><p><strong>Fields</strong></p><ul><li><code>Œ∑</code> ‚Äì strength.</li><li><code>œâc</code> ‚Äì cutoff frequence.</li><li><code>Œ≤</code> ‚Äì inverse temperature.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/bath/ohmic.jl#L3-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.OpenSysOp" href="#QTBase.OpenSysOp"><code>QTBase.OpenSysOp</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct OpenSysOp{diagonalization, adiabatic_frame}</code></pre><p>Defines an open system DiffEqOperator in the specific basis.</p><p><strong>Fields</strong></p><ul><li><p><code>H</code></p><p>Hamiltonian</p></li><li><p><code>opensys</code></p><p>Open system part</p></li><li><p><code>lvl</code></p><p>Levels to truncate</p></li><li><p><code>u_cache</code></p><p>Internal cache</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/opensys/opensys_op.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.ProjectedCoupling" href="#QTBase.ProjectedCoupling"><code>QTBase.ProjectedCoupling</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ProjectedCoupling</code></pre><p>Object for a projected coupling parameterized by NIBA parameters. This object holds the numerical values at gridded points.</p><p><strong>Fields</strong></p><ul><li><p><code>s</code></p><p>Time grid (unitless) for projection</p></li><li><p><code>a</code></p><p><span>$(œÉ_m - œÉ_n)^2$</span></p></li><li><p><code>b</code></p><p><span>$|œÉ_{mn}|^2$</span></p></li><li><p><code>c</code></p><p><span>$œÉ_{mn}(œÉ_m-œÉ_n)$</span></p></li><li><p><code>d</code></p><p><span>$œÉ_{mn}(œÉ_m+œÉ_n)$</span></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/projection/projection.jl#L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.ProjectedSystem" href="#QTBase.ProjectedSystem"><code>QTBase.ProjectedSystem</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ProjectedSystem</code></pre><p>Object for a projected low level system. The projection is only valid for real Hamiltonians.</p><p><strong>Fields</strong></p><ul><li><p><code>s</code></p><p>Time grid (unitless) for projection</p></li><li><p><code>ev</code></p><p>Energy values for different levels</p></li><li><p><code>dŒ∏</code></p><p>Geometric terms</p></li><li><p><code>op</code></p><p>Projected system bath interaction operators</p></li><li><p><code>ref</code></p><p>Energy eigenstates at the final time</p></li><li><p><code>lvl</code></p><p>Number of levels being kept</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/projection/projection.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.ProjectedTG" href="#QTBase.ProjectedTG"><code>QTBase.ProjectedTG</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ProjectedTG</code></pre><p>Object for a projected system Hamiltonian parameterized by NIBA parameters. This object holds the numerical values at gridded points.</p><p><strong>Fields</strong></p><ul><li><p><code>s</code></p><p>Time grid (unitless) for projection</p></li><li><p><code>œâ</code></p><p>Frequencies of given basis states</p></li><li><p><code>T</code></p><p>Adiabatic part</p></li><li><p><code>G</code></p><p>Geometric phase</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/projection/projection.jl#L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.RedfieldGenerator" href="#QTBase.RedfieldGenerator"><code>QTBase.RedfieldGenerator</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct RedfieldGenerator &lt;: AbstractLiouvillian</code></pre><p>Defines RedfieldGenerator.</p><p><strong>Fields</strong></p><ul><li><p><code>ops</code></p><p>system-bath coupling operator</p></li><li><p><code>unitary</code></p><p>close system unitary</p></li><li><p><code>cfun</code></p><p>bath correlation function</p></li><li><p><code>atol</code></p><p>absolute error tolerance for integration</p></li><li><p><code>rtol</code></p><p>relative error tolerance for integration</p></li><li><p><code>Ut</code></p><p>cache matrix for inplace unitary</p></li><li><p><code>UœÑ</code></p><p>cache matrix for inplace unitary</p></li><li><p><code>Œõ</code></p><p>cache matrix for integration</p></li><li><p><code>Ta</code></p><p>tf minus coarse grain time scale</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/opensys/redfield.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.SparseHamiltonian" href="#QTBase.SparseHamiltonian"><code>QTBase.SparseHamiltonian</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct SparseHamiltonian{T&lt;:Number} &lt;: AbstractSparseHamiltonian{T&lt;:Number}</code></pre><p>Defines a time dependent Hamiltonian object with sparse Matrices.</p><p><strong>Fields</strong></p><ul><li><p><code>f</code></p><p>List of time dependent functions</p></li><li><p><code>m</code></p><p>List of constant matrices</p></li><li><p><code>u_cache</code></p><p>Internal cache</p></li><li><p><code>size</code></p><p>Size</p></li><li><p><code>EIGS</code></p><p>Eigen decomposition routine</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/hamiltonian/sparse_hamiltonian.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.SparseHamiltonian-Tuple{Any,Any}" href="#QTBase.SparseHamiltonian-Tuple{Any,Any}"><code>QTBase.SparseHamiltonian</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SparseHamiltonian(funcs, mats; unit, EIGS)
</code></pre><p>Constructor of SparseHamiltonian object. <code>funcs</code> and <code>mats</code> are a list of time dependent functions and the corresponding matrices. <code>unit</code> is the unit one ‚Äì <code>:h</code> or <code>:ƒß</code>. The <code>mats</code> will be scaled by <span>$2œÄ$</span> is unit is <code>:h</code>.</p><p><code>EIGS</code> is the initializer for the eigen decomposition routine for the Hamiltonian. It should return a function of signature: <code>(H, s, lvl) -&gt; (w, v)</code>. The default method <code>EIGEN_DEFAULT</code> will use <code>LAPACK</code> routine.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/hamiltonian/sparse_hamiltonian.jl#L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.SparseHamiltonian-Tuple{Real}" href="#QTBase.SparseHamiltonian-Tuple{Real}"><code>QTBase.SparseHamiltonian</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function (h::SparseHamiltonian)(t::Real)</code></pre><p>Calling the Hamiltonian returns the value <span>$2œÄH(t)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/hamiltonian/sparse_hamiltonian.jl#L45-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.TimeDependentCoupling" href="#QTBase.TimeDependentCoupling"><code>QTBase.TimeDependentCoupling</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct TimeDependentCoupling</code></pre><p>Defines a single time dependent system bath coupling operator. It is defined as <span>$S(s)=‚àëf(s)√óM$</span>.  Keyword argument <code>unit</code> set the unit one ‚Äì <span>$h$</span> or <span>$ƒß$</span>.</p><p><strong>Fields</strong></p><ul><li><p><code>funcs</code></p><p>1-D array of time dependent functions</p></li><li><p><code>mats</code></p><p>1-D array of constant matrics</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/coupling/coupling.jl#L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.TimeDependentCouplings" href="#QTBase.TimeDependentCouplings"><code>QTBase.TimeDependentCouplings</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct TimeDependentCouplings &lt;: AbstractTimeDependentCouplings</code></pre><p>Defines an 1-D array of time dependent system bath coupling operators.</p><p><strong>Fields</strong></p><ul><li><p><code>coupling</code></p><p>A tuple of single <code>TimeDependentCoupling</code> operators</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/coupling/coupling.jl#L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.ŒìMatrix" href="#QTBase.ŒìMatrix"><code>QTBase.ŒìMatrix</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ŒìMatrix</code></pre><p>Defines rates of Davies form ME acting on the diagonal elements.</p><p><strong>Fields</strong></p><ul><li><p><code>m</code></p><p>interpolated Œì matrix</p></li><li><p><code>lvl</code></p><p>levels of the system</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/projection/gamma_matrix.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.:‚äó" href="#QTBase.:‚äó"><code>QTBase.:‚äó</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">‚äó(A, B)</code></pre><p>Calculate the tensor product of <code>A</code> and <code>B</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; œÉx‚äóœÉz
4√ó4 Array{Complex{Float64},2}:
 0.0+0.0im   0.0+0.0im  1.0+0.0im   0.0+0.0im
 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -1.0+0.0im
 1.0+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im
 0.0+0.0im  -1.0+0.0im  0.0+0.0im  -0.0+0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/math_util.jl#L30-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.EIGEN_DEFAULT-Tuple{AbstractDenseHamiltonian}" href="#QTBase.EIGEN_DEFAULT-Tuple{AbstractDenseHamiltonian}"><code>QTBase.EIGEN_DEFAULT</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function EIGEN_DEFAULT(H)</code></pre><p>The default initializer for eigen factorization method. It returns a function of signature: <code>(H, s, lvl) -&gt; (w, v)</code>. <code>H</code> is the Hamiltonian object, <code>s</code> is the dimensionless time and <code>lvl</code> is the energy levels to keep. This default initializer will use <code>LAPACK</code> routine for both dense and sparse matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/base_util.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.EIGEN_DEFAULT-Tuple{Any}" href="#QTBase.EIGEN_DEFAULT-Tuple{Any}"><code>QTBase.EIGEN_DEFAULT</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function EIGEN_DEFAULT(u_cache)</code></pre><p>The default initializer for eigen factorization method. It returns a function of signature: <code>(H, s, lvl) -&gt; (w, v)</code>. <code>u_cache</code> is the cache for Hamiltonian object, <code>s</code> is the time argument for the Hamiltonian and <code>lvl</code> is the energy levels to keep. This default initializer will use <code>LAPACK</code> routine for both dense and sparse matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/hamiltonian/util.jl#L117-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.Ohmic-Tuple{Any,Any,Any}" href="#QTBase.Ohmic-Tuple{Any,Any,Any}"><code>QTBase.Ohmic</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Ohmic(Œ∑, fc, T)
</code></pre><p>Construct OhmicBath from parameters with physical unit: <code>Œ∑</code>‚Äìunitless interaction strength; <code>fc</code>‚Äìcutoff frequency in GHz; <code>T</code>‚Äìtemperature in mK.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/bath/ohmic.jl#L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.S-Tuple{Any,OhmicBath}" href="#QTBase.S-Tuple{Any,OhmicBath}"><code>QTBase.S</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">S(w, bath; atol)
</code></pre><p>Calculate the Lamb shift of Ohmic spectrum. <code>atol</code> is the absolute tolerance for Cauchy principal value integral.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/bath/ohmic.jl#L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.ame_jump-Tuple{OpenSysOp{true,false},Any,Any,Real}" href="#QTBase.ame_jump-Tuple{OpenSysOp{true,false},Any,Any,Real}"><code>QTBase.ame_jump</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ame_jump(A::OpenSysOp, u, p, t::Real)</code></pre><p>Calculate the jump operator for the <code>OpenSysOp</code> at time <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/opensys/davies.jl#L121-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.check_positivity-Tuple{AbstractArray{T,2} where T}" href="#QTBase.check_positivity-Tuple{AbstractArray{T,2} where T}"><code>QTBase.check_positivity</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">check_positivity(m)</code></pre><p>Check if matrix <code>m</code> is positive. Return <code>true</code> is the minimum eigenvalue of <code>m</code> is greater than or equal to 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/math_util.jl#L66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.check_unitary-Tuple{AbstractArray{T,2} where T}" href="#QTBase.check_unitary-Tuple{AbstractArray{T,2} where T}"><code>QTBase.check_unitary</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">check_unitary(ùêî; rtol, atol)
</code></pre><p>Test if <code>ùêî</code> is a unitary matrix. The function checks how close both <span>$ùêîùêî^‚Ä†$</span> and <span>$ùêî^‚Ä†ùêî$</span> are to <span>$I$</span>, with relative and absolute error given by <code>rtol</code>, <code>atol</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; check_unitary(exp(-1.0im*5*0.5*œÉx))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/math_util.jl#L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.coarse_grain_timescale-Tuple{AbstractBath,Any}" href="#QTBase.coarse_grain_timescale-Tuple{AbstractBath,Any}"><code>QTBase.coarse_grain_timescale</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">coarse_grain_timescale(bath, lim; rtol, atol)
</code></pre><p>Calculate the optimal coarse grain time scale <span>$T_a$</span> for a total evolution time <code>lim</code>. <code>atol</code> and <code>rtol</code> are the absolute and relative error for the integration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/bath/bath_util.jl#L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.collective_coupling-Tuple{Any,Any}" href="#QTBase.collective_coupling-Tuple{Any,Any}"><code>QTBase.collective_coupling</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function collective_coupling(op, num_qubit; sp=false)</code></pre><p>Create <code>ConstantCouplings</code> object with operator <code>op</code> on each qubits. <code>op</code> is the string representation of one of the Pauli matrices. <code>num_qubit</code> is the total number of qubits. <code>sp</code> set whether to use sparse matrices. <code>unit</code> set the unit one ‚Äì <span>$h$</span> or <span>$ƒß$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/coupling/coupling.jl#L72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.collective_operator-Tuple{Any,Any}" href="#QTBase.collective_operator-Tuple{Any,Any}"><code>QTBase.collective_operator</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">collective_operator(op, num_qubit; sp=false)</code></pre><p>Construct the collective operator for a system of <code>num_qubit</code> qubits. <code>op</code> is the name of the collective Pauli matrix. For example, the following code construct an <span>$IZ + ZI$</span> matrix. Generate sparse matrix when <code>sp</code> is set to true.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; collective_operator(&quot;z&quot;, 2)
4√ó4 Array{Complex{Float64},2}:
 2.0+0.0im  0.0+0.0im  0.0+0.0im   0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im   0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im   0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  -2.0+0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/matrix_util.jl#L75-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.concatenate-Tuple" href="#QTBase.concatenate-Tuple"><code>QTBase.concatenate</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function concatenate(args...)</code></pre><p>Concatenate multiple <code>ProjectedSystem</code> objects into a single one. The arguments need to be in time order. The <code>ref</code> field of the new object will have the same value as the last input arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/projection/projection.jl#L199-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.construct_interpolations-Union{Tuple{N}, Tuple{T}, Tuple{S}, Tuple{AbstractRange{S},AbstractArray{T,N}}} where N where T&lt;:Number where S&lt;:Real" href="#QTBase.construct_interpolations-Union{Tuple{N}, Tuple{T}, Tuple{S}, Tuple{AbstractRange{S},AbstractArray{T,N}}} where N where T&lt;:Number where S&lt;:Real"><code>QTBase.construct_interpolations</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function construct_interpolations(x, y; method = &quot;BSpline&quot;, order = 2, extrapolation = &quot;line&quot;)</code></pre><p>Construct interpolation of N-D array <code>y</code> along its last dimension on grid <code>x</code>. <code>method</code> specifies the interpolation algorithm, which can be either &quot;BSpline&quot; or &quot;Gridded&quot;. If <code>x</code> is an <code>AbstractRange</code>, the default method is &quot;BSpline&quot;, otherwise the default <code>method</code> is &quot;Gridded&quot;. <code>order</code> is the interpolation order. If <code>x</code> is <code>AbstractRange</code>, the default order is 2, otherwise the default order is 1. <code>extrapolation</code> specifies the extrapolation methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/interpolation.jl#L16-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.eigen_decomp-Tuple{AbstractHamiltonian,AbstractArray{Float64,1}}" href="#QTBase.eigen_decomp-Tuple{AbstractHamiltonian,AbstractArray{Float64,1}}"><code>QTBase.eigen_decomp</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eigen_decomp(H, s; lvl)
</code></pre><p>Calculate the eigen value decomposition of the Hamiltonian <code>H</code> at an array of time points <code>s</code>. The output keeps the lowest <code>lvl</code> eigenstates and their corresponding eigenvalues. Output <code>(vals, vecs)</code> have the dimensions of <code>(lvl, length(s))</code> and <code>(size(H, 1), lvl, length(s))</code> respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/hamiltonian/util.jl#L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.eigen_decomp-Tuple{AbstractHamiltonian,Any}" href="#QTBase.eigen_decomp-Tuple{AbstractHamiltonian,Any}"><code>QTBase.eigen_decomp</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eigen_decomp(H, s; lvl)
</code></pre><p>Calculate the eigen value decomposition of the Hamiltonian <code>H</code> at time <code>s</code>. Keyword argument <code>lvl</code> specifies the number of levels to keep in the output. <code>w</code> is a vector of eigenvalues and <code>v</code> is a matrix of the eigenvectors in the columns. (The <code>k</code>th eigenvector can be obtained from the slice <code>v[:, k]</code>.) <code>w</code> will be in unit of <code>GHz</code>.</p><p><code>eig_init</code> is the initializer for eigen factorization routine. It returns a function of signature: <code>(H, s, lvl) -&gt; (w, v)</code>. The default initializer <code>EIGEN_DEFAULT</code> will use <code>LAPACK</code> routine for both dense and sparse matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/hamiltonian/util.jl#L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.evaluate-Tuple{AbstractHamiltonian,Any}" href="#QTBase.evaluate-Tuple{AbstractHamiltonian,Any}"><code>QTBase.evaluate</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate(H::AbstractHamiltonian, s)</code></pre><p>Evaluate the time dependent Hamiltonian at time s with the unit of <code>GHz</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/hamiltonian/util.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.evaluate-Tuple{AdiabaticFrameHamiltonian,Any,Any}" href="#QTBase.evaluate-Tuple{AdiabaticFrameHamiltonian,Any,Any}"><code>QTBase.evaluate</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function evaluate(H::AdiabaticFrameHamiltonian, s, tf)</code></pre><p>Evaluate the adiabatic frame Hamiltonian at (unitless) time <code>s</code>, with total annealing time <code>tf</code> (in the unit of <span>$ns$</span>). The final result is given in unit of <span>$GHz$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/hamiltonian/adiabatic_frame_hamiltonian.jl#L58-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.freq_2_temperature-Tuple{Any}" href="#QTBase.freq_2_temperature-Tuple{Any}"><code>QTBase.freq_2_temperature</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">freq_2_temperature(freq)</code></pre><p>Convert frequency in GHz to temperature in mK.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/unit_util.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.get_dŒ∏" href="#QTBase.get_dŒ∏"><code>QTBase.get_dŒ∏</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_dŒ∏(sys::ProjectedSystem, i=1, j=2)</code></pre><p>Get the geometric terms between i, j energy levels from <code>ProjectedSystem</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/projection/projection.jl#L181-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.gibbs_state-Tuple{Any,Any}" href="#QTBase.gibbs_state-Tuple{Any,Any}"><code>QTBase.gibbs_state</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gibbs_state(h, Œ≤)</code></pre><p>Calculate the Gibbs state of the matrix <code>h</code> at temperature <code>T</code> (mK).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; gibbs_state(œÉz, 10)
2√ó2 Array{Complex{Float64},2}:
 0.178338+0.0im       0.0+0.0im
      0.0+0.0im  0.821662+0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/math_util.jl#L82-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.gradient-Tuple{Any,Number}" href="#QTBase.gradient-Tuple{Any,Number}"><code>QTBase.gradient</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function gradient(itp, s)</code></pre><p>Calculate the gradient of <code>itp</code> at <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/interpolation.jl#L155-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.hamming_weight_operator-Tuple{Int64,String}" href="#QTBase.hamming_weight_operator-Tuple{Int64,String}"><code>QTBase.hamming_weight_operator</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hamming_weight_operator(num_qubit::Int64, op::String; sp=false)</code></pre><p>Construct the Hamming weight operator for system of size <code>num_qubit</code>. The type of the Hamming weight operator is specified by op: &quot;x&quot;, &quot;y&quot; or &quot;z&quot;. Generate sparse matrix when <code>sp</code> is set to true.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; hamming_weight_operator(2,&quot;z&quot;)
4√ó4 Array{Complex{Float64},2}:
 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  2.0+0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/matrix_util.jl#L113-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.inst_population-Tuple{Any,Any,AbstractHamiltonian}" href="#QTBase.inst_population-Tuple{Any,Any,AbstractHamiltonian}"><code>QTBase.inst_population</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inst_population(s, states, H; lvl)
</code></pre><p>For a time series quantum states given by <code>states</code>, whose time points are given by <code>s</code>, calculate the population of instantaneous eigenstates of <code>H</code>. The levels of the instantaneous eigenstates are specified by <code>lvl</code>, which can be any slice index.</p><p><code>eig_init</code> is the initializer for eigen factorization routine. It returns a function of signature: <code>(H, s, lvl) -&gt; (w, v)</code>. The default initializer <code>EIGEN_DEFAULT</code> will use <code>LAPACK</code> routine for both dense and sparse matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/hamiltonian/util.jl#L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.local_field_term-Tuple{Any,Any,Any}" href="#QTBase.local_field_term-Tuple{Any,Any,Any}"><code>QTBase.local_field_term</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">local_field_term(h, idx, num_qubit; sp=false)</code></pre><p>Construct local Hamiltonian of the form <span>$‚àëh·µ¢œÉ·µ¢·∂ª$</span>. <code>idx</code> is the index of all local field terms and <code>h</code> is a list of the corresponding weights. <code>num_qubit</code> is the total number of qubits. Generate sparse matrix when <code>sp</code> is set to true.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; local_field_term([1.0, 0.5], [1, 2], 2) == œÉz‚äóœÉi+0.5œÉi‚äóœÉz
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/matrix_util.jl#L133-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.log_uniform-Tuple{Any,Any,Any}" href="#QTBase.log_uniform-Tuple{Any,Any,Any}"><code>QTBase.log_uniform</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">log_uniform(a, b, num; base)
</code></pre><p>Generate a log-uniformly distributed array with <code>num</code> elements between <code>a</code> and <code>b</code>. The base of log is <code>base</code> with default value 10.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/math_util.jl#L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.low_level_matrix-Tuple{Any,Any}" href="#QTBase.low_level_matrix-Tuple{Any,Any}"><code>QTBase.low_level_matrix</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">low_level_matrix(M, lvl)</code></pre><p>Calculate the matrix <code>M</code> projected to lower energy subspace containing <code>lvl</code> energy lvl.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; low_level_matrix(œÉx‚äóœÉx, 2)
4√ó4 Array{Complex{Float64},2}:
 -0.5+0.0im   0.0+0.0im   0.0+0.0im   0.5+0.0im
  0.0+0.0im  -0.5+0.0im   0.5+0.0im   0.0+0.0im
  0.0+0.0im   0.5+0.0im  -0.5+0.0im   0.0+0.0im
  0.5+0.0im   0.0+0.0im   0.0+0.0im  -0.5+0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/math_util.jl#L109-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.matrix_decompose-Tuple{AbstractArray{T,2} where T,Array{#s16,1} where #s16&lt;:(AbstractArray{T,2} where T)}" href="#QTBase.matrix_decompose-Tuple{AbstractArray{T,2} where T,Array{#s16,1} where #s16&lt;:(AbstractArray{T,2} where T)}"><code>QTBase.matrix_decompose</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">matrix_decompose(mat, basis)
</code></pre><p>Decompse matrix <code>mat</code> onto matrix basis <code>basis</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; matrix_decompose(1.0*œÉx+2.0*œÉy+3.0*œÉz, [œÉx,œÉy,œÉz])
3-element Array{Complex{Float64},1}:
 1.0 + 0.0im
 2.0 + 0.0im
 3.0 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/math_util.jl#L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.partial_trace-Tuple{Array{T,2} where T,Any}" href="#QTBase.partial_trace-Tuple{Array{T,2} where T,Any}"><code>QTBase.partial_trace</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">partial_trace(œÅ, qubit_2_keep)
</code></pre><p>Calculate the partial trace of the density matrix <code>œÅ</code>. <code>qubit_2_keep</code> is an array of qubit indices to keep.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; œÅ1 = [0.4 0.5; 0.5 0.6]; œÅ2 = [0.5 0; 0 0.5];
julia&gt; partial_trace(œÅ1‚äóœÅ2, [1])
2√ó2 Array{Float64,2}:
 0.4  0.5
 0.5  0.6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/math_util.jl#L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.project_to_lowlevel-Union{Tuple{S}, Tuple{T}, Tuple{AbstractHamiltonian{T},Any,Any,AbstractArray{S,1}}} where S&lt;:Real where T&lt;:Real" href="#QTBase.project_to_lowlevel-Union{Tuple{S}, Tuple{T}, Tuple{AbstractHamiltonian{T},Any,Any,AbstractArray{S,1}}} where S&lt;:Real where T&lt;:Real"><code>QTBase.project_to_lowlevel</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">project_to_lowlevel(H::AbstractHamiltonian{T}, dH, coupling, s_axis; lvl=2, eig_init = EIGEN_DEFAULT)</code></pre><p>Project a Hamiltonian <code>H</code> to the lowest <code>lvl</code> level subspace. <code>dH</code> is the derivative of Hamiltonian and <code>coupling</code> is the system-bath interaction operator. They should be callable with a single argument ‚Äì annealing parameter <code>s</code>. <code>s_axis</code> is the (unitless) times to calculate the projection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/projection/projection.jl#L118-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.q_translate-Tuple{String}" href="#QTBase.q_translate-Tuple{String}"><code>QTBase.q_translate</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">q_translate(h::String)</code></pre><p>Convert a string <code>h</code> representing multi-qubits Pauli matrices summation into its numerical form.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; q_translate(&quot;X+2.0Z&quot;)
2√ó2 Array{Complex{Float64},2}:
 2.0+0.0im   1.0+0.0im
 1.0+0.0im  -2.0+0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/matrix_util.jl#L3-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.q_translate_state-Tuple{String}" href="#QTBase.q_translate_state-Tuple{String}"><code>QTBase.q_translate_state</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">q_translate_state(h::String; normal=false)</code></pre><p>Convert a string representation of quantum state to a vector. The keyword argument <code>normal</code> indicates whether to normalize the output vector. (Currently only &#39;0&#39; and &#39;1&#39; are supported)</p><p><strong>Examples</strong></p><p>Single term:</p><pre><code class="language-julia-repl">julia&gt; q_translate_state(&quot;001&quot;)
8-element Array{Complex{Float64},1}:
 0.0 + 0.0im
 1.0 + 0.0im
 0.0 + 0.0im
 0.0 + 0.0im
 0.0 + 0.0im
 0.0 + 0.0im
 0.0 + 0.0im
 0.0 + 0.0im</code></pre><p>Multiple terms:</p><pre><code class="language-julia-repl">julia&gt; q_translate_state(&quot;(101)+(001)&quot;, normal=true)
8-element Array{Complex{Float64},1}:
                0.0 + 0.0im
 0.7071067811865475 + 0.0im
                0.0 + 0.0im
                0.0 + 0.0im
                0.0 + 0.0im
 0.7071067811865475 + 0.0im
                0.0 + 0.0im
                0.0 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/matrix_util.jl#L173-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.single_clause-NTuple{4,Any}" href="#QTBase.single_clause-NTuple{4,Any}"><code>QTBase.single_clause</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">single_clause(ops, q_ind, weight, num_qubit; sp=false)</code></pre><p>Construct a single clause of the multi-qubits Hamiltonian. <code>ops</code> is a list of Pauli operator names which appears in this clause. <code>q_ind</code> is the list of indices corresponding to the Pauli matrices in <code>ops</code>. <code>weight</code> is the constant factor of this clause. <code>num_qubit</code> is the total number of qubits. A sparse matrix can be construct by setting <code>sp</code> to <code>true</code>. The following example construct a clause of <span>$Z_1 I Z_3/2$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; single_clause([&quot;z&quot;, &quot;z&quot;], [1, 3], 0.5, 3)
8√ó8 Array{Complex{Float64},2}:
 0.5+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im
 0.0+0.0im  -0.5+0.0im  0.0+0.0im  -0.0+0.0im   0.0+0.0im  -0.0+0.0im   0.0+0.0im  -0.0+0.0im
 0.0+0.0im   0.0+0.0im  0.5+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im
 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -0.5+0.0im   0.0+0.0im  -0.0+0.0im   0.0+0.0im  -0.0+0.0im
 0.0+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im  -0.5+0.0im  -0.0+0.0im  -0.0+0.0im  -0.0+0.0im
 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -0.0+0.0im  -0.0+0.0im   0.5-0.0im  -0.0+0.0im   0.0-0.0im
 0.0+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im  -0.0+0.0im  -0.0+0.0im  -0.5+0.0im  -0.0+0.0im
 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -0.0+0.0im  -0.0+0.0im   0.0-0.0im  -0.0+0.0im   0.5-0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/matrix_util.jl#L35-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.standard_driver-Tuple{Any}" href="#QTBase.standard_driver-Tuple{Any}"><code>QTBase.standard_driver</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">standard_driver(num_qubit; sp=false)</code></pre><p>Construct the standard driver Hamiltonian for a system of <code>num_qubit</code> qubits. For example, a two qubits standard driver matrix is <span>$IX + XI$</span>. Generate sparse matrix when <code>sp</code> is set to true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/matrix_util.jl#L99-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.temperature_2_freq-Tuple{Any}" href="#QTBase.temperature_2_freq-Tuple{Any}"><code>QTBase.temperature_2_freq</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">temperature_2_freq(T)</code></pre><p>Convert temperature from mK to GHz.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/unit_util.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.temperature_2_Œ≤-Tuple{Any}" href="#QTBase.temperature_2_Œ≤-Tuple{Any}"><code>QTBase.temperature_2_Œ≤</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> temperature_2_Œ≤(T)</code></pre><p>Convert physical temperature <code>T</code> in mK to thermodynamic <code>Œ≤</code> in the unit of inverse angular frequency, that is to say <span>$Œ≤ = ƒß/kT$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/unit_util.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.two_local_term-Tuple{Any,Any,Any}" href="#QTBase.two_local_term-Tuple{Any,Any,Any}"><code>QTBase.two_local_term</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">two_local_term(j, idx, num_qubit; sp=false)</code></pre><p>Construct local Hamiltonian of the form <span>$‚àëJ·µ¢‚±ºœÉ·µ¢·∂ªœÉ‚±º·∂ª$</span>. <code>idx</code> is the index of all two local terms and <code>j</code> is a list of the corresponding weights. <code>num_qubit</code> is the total number of qubits. Generate sparse matrix when <code>sp</code> is set to true.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; two_local_term([1.0, 0.5], [[1,2], [1,3]], 3) == œÉz‚äóœÉz‚äóœÉi + 0.5œÉz‚äóœÉi‚äóœÉz
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/matrix_util.jl#L153-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.Œ≤_2_temperature-Tuple{Any}" href="#QTBase.Œ≤_2_temperature-Tuple{Any}"><code>QTBase.Œ≤_2_temperature</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Œ≤_2_temperature(Œ≤)</code></pre><p>Convert thermodynamic <code>Œ≤</code> in the unit of inverse angular frequency to physical temperature <code>T</code> in GHz.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/unit_util.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.Œ≥-Tuple{Any,OhmicBath}" href="#QTBase.Œ≥-Tuple{Any,OhmicBath}"><code>QTBase.Œ≥</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Œ≥(œâ, params)
</code></pre><p>Calculate Ohmic spectrum density, defined as a full Fourier transform on the bath correlation function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/bath/ohmic.jl#L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.œÑ_B-Tuple{Any,Any,Any}" href="#QTBase.œÑ_B-Tuple{Any,Any,Any}"><code>QTBase.œÑ_B</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">œÑ_B(cfun, lim, œÑsb; rtol, atol)
</code></pre><p>Calculate the bath correlation time <span>$œÑ_B$</span>. The upper limit <code>lim</code> and <code>œÑsb</code> need to be manually specified. <code>atol</code> and <code>rtol</code> are the absolute and relative error for the integration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/bath/bath_util.jl#L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QTBase.œÑ_SB-Tuple{Any}" href="#QTBase.œÑ_SB-Tuple{Any}"><code>QTBase.œÑ_SB</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">œÑ_SB(cfun; lim, rtol, atol)
</code></pre><p>Calculate <span>$œÑ_{SB}$</span> from the bath correlation function <code>cfun</code>. It is defined as the integration of the absolute value of bath correlation function from zero to <code>lim</code>. The default value of <code>lim</code> is <code>Inf</code>. <code>atol</code> and <code>rtol</code> are the absolute and relative error of the integration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/USCqserver/QTBase.jl/blob/d57ae0ac23e4d1a9af6f711697ae1f5a52b2f750/src/bath/bath_util.jl#L4">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../tutorials/solver/">¬´ Solver</a><a class="docs-footer-nextpage" href="../bath/">Bath ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 17 August 2020 06:37">Monday 17 August 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
