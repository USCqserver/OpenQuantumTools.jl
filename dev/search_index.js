var documenterSearchIndex = {"docs":
[{"location":"tutorials/couplings/#Couplings","page":"Coupling","title":"Couplings","text":"","category":"section"},{"location":"tutorials/couplings/","page":"Coupling","title":"Coupling","text":"We start with a general form of system bath interaction Hamiltonian","category":"page"},{"location":"tutorials/couplings/","page":"Coupling","title":"Coupling","text":"  H_SB = sum_alpha S_alphaotimes B_alpha","category":"page"},{"location":"tutorials/couplings/","page":"Coupling","title":"Coupling","text":"and define the set of S_alpha_alpha whose corresponding B_α_alpha are independent and identical(IID) as AbstractCouplings objects. Mathematically, every element in the same AbstractCouplings object shares the same bath correlation function. (For operators which couple to the same bath, they can be added together.) Two concrete types of AbstractCouplings are implemented – ConstantCouplings and TimeDependentCouplings. The former represents time-independent operators. For example, the following codes","category":"page"},{"location":"tutorials/couplings/","page":"Coupling","title":"Coupling","text":"julia> coupling = ConstantCouplings([\"ZI\", \"IZ\"])","category":"page"},{"location":"tutorials/couplings/","page":"Coupling","title":"Coupling","text":"creates a set of two constant operators: ZI and IZ. The corresponding interaction Hamiltonian is","category":"page"},{"location":"tutorials/couplings/","page":"Coupling","title":"Coupling","text":"  H_SB = ZIB_1 + IZB_2","category":"page"},{"location":"tutorials/couplings/","page":"Coupling","title":"Coupling","text":"where B_1 and B_2 are IID. On the other hand, TimeDependentCouplings can be constructed with a two-step procedure. First, single TimeDependentCoupling needs to be constructed","category":"page"},{"location":"tutorials/couplings/","page":"Coupling","title":"Coupling","text":"c1 = TimeDependentCoupling([(s)->cos(s)], [σx]; unit=:ħ)\nc2 = TimeDependentCoupling([(s)->sin(s)], [σz]; unit=:ħ)","category":"page"},{"location":"tutorials/couplings/","page":"Coupling","title":"Coupling","text":"The above codes creates two time dependent coupling operators cos(s) X and sin(s) Z. Then, c1 and c2 can be grouped together to create the coupling set","category":"page"},{"location":"tutorials/couplings/","page":"Coupling","title":"Coupling","text":"coupling = TimeDependentCouplings(c1, c2)","category":"page"},{"location":"tutorials/couplings/","page":"Coupling","title":"Coupling","text":"Only ConstantCouplings and TimeDependentCouplings can be used to create an annealing process.","category":"page"},{"location":"tutorials/math_symbol/#Math-Symbols","page":"Math Symbol","title":"Math Symbols","text":"","category":"section"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"The package defines some commonly used mathematical symbols and operators. Some of its features include:","category":"page"},{"location":"tutorials/math_symbol/#Pauli-Matrices","page":"Math Symbol","title":"Pauli Matrices","text":"","category":"section"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"Single qubit Pauli matrices are defined by σx, σy, σz and σi. One can simply calculate the tensor product of single qubits Pauli matrices by","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"julia> σx⊗σz\n4×4 Array{Complex{Float64},2}:\n 0.0+0.0im   0.0+0.0im  1.0+0.0im   0.0+0.0im\n 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -1.0+0.0im\n 1.0+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im\n 0.0+0.0im  -1.0+0.0im  0.0+0.0im  -0.0+0.0im","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"The eigenvectors of each Pauli matrices are also defined in constant PauliVec, where PauliVec[1],PauliVec[2],PauliVec[3] corresponds to eigenvectors of σx, σy, σz. Additionally, the first eigenvector is the one with positive eigenvalue","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"julia> σz*PauliVec[3][1] == PauliVec[3][1]\ntrue","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"Additionally, a sparse version of Pauli matrices are defined in spσx et al. They can be used to construct Hamiltonian in the form of sparse matrix.","category":"page"},{"location":"tutorials/math_symbol/#Construction-of-Multi-Qubits-Matrices","page":"Math Symbol","title":"Construction of Multi-Qubits Matrices","text":"","category":"section"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"The package provides various utility functions to construct multi-qubits matrices. For all the functions listed below, keyword argument sp can be set to generate sparse matrices.","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"The standard driver Hamiltonian in quantum annealing can be constructed with standard_driver","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"julia> standard_driver(2) == σx⊗σi + σi⊗σx\ntrue","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"and for sparse matrices","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"julia> standard_driver(2, sp=true) == spσx⊗spσi + spσi⊗spσx\ntrue","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"A multi-qubits matrix can be constructed from its string representation using q_translate","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"julia> q_translate(\"ZZ+0.5ZI-XZ\")\n4×4 Array{Complex{Float64},2}:\n  1.5+0.0im   0.0+0.0im  -1.0+0.0im   0.0+0.0im\n  0.0+0.0im  -0.5+0.0im   0.0+0.0im   1.0+0.0im\n -1.0+0.0im   0.0+0.0im  -1.5+0.0im  -0.0+0.0im\n  0.0+0.0im   1.0+0.0im  -0.0+0.0im   0.5+0.0im","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"Collective operators(same Pauli operator acting on each individual qubit) can be constructed with collective_operator","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"julia> collective_operator(\"z\", 3) == σz⊗σi⊗σi + σi⊗σz⊗σi + σi⊗σi⊗σz\ntrue","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"Single clause in multi-qubits Hamiltonian can be constructed by","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"julia> single_clause([\"z\",\"z\"], [2,3], -2, 4) == -2σi⊗σz⊗σz⊗σi\ntrue","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"Local field terms of the form ΣhᵢZᵢ can be constructed with local_field_term","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"julia> local_field_term([1.0, 0.5], [1, 2], 2) == σz⊗σi+0.5σi⊗σz\ntrue","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"Two local terms of the form JᵢⱼZᵢZⱼ can be constructed with two_local_term","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"julia> two_local_term([1.0, 0.5], [[1,2], [1,3]], 3) == σz⊗σz⊗σi + 0.5σz⊗σi⊗σz\ntrue","category":"page"},{"location":"tutorials/math_symbol/#Construction-of-Multi-Qubits-states","page":"Math Symbol","title":"Construction of Multi-Qubits states","text":"","category":"section"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"The quantum state of spin system can be construct with q_translate_state","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"julia> q_translate_state(\"001\")\n8-element Array{Complex{Float64},1}:\n 0.0 + 0.0im\n 1.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"In the string representation 0 and 1 represent the eigenstates of σ_z operator.","category":"page"},{"location":"lib/hamiltonian/#Hamiltonian","page":"Hamiltonian","title":"Hamiltonian","text":"","category":"section"},{"location":"lib/hamiltonian/#Hamiltonian-types","page":"Hamiltonian","title":"Hamiltonian types","text":"","category":"section"},{"location":"lib/hamiltonian/","page":"Hamiltonian","title":"Hamiltonian","text":"DenseHamiltonian\nDenseHamiltonian(funcs, mats; unit = :h, EIGS = EIGEN_DEFAULT)\nSparseHamiltonian\nSparseHamiltonian(funcs, mats; unit = :h, EIGS = EIGEN_DEFAULT)","category":"page"},{"location":"lib/hamiltonian/#QTBase.DenseHamiltonian","page":"Hamiltonian","title":"QTBase.DenseHamiltonian","text":"struct DenseHamiltonian{T<:Number} <: AbstractDenseHamiltonian{T<:Number}\n\nDefines a time dependent Hamiltonian object with dense Matrices.\n\nFields\n\nf\nList of time dependent functions\nm\nList of constant matrices\nu_cache\nInternal cache\nsize\nSize\nEIGS\nEigen decomposition routine\n\n\n\n\n\n","category":"type"},{"location":"lib/hamiltonian/#QTBase.DenseHamiltonian-Tuple{Any,Any}","page":"Hamiltonian","title":"QTBase.DenseHamiltonian","text":"DenseHamiltonian(funcs, mats; unit, EIGS)\n\n\nConstructor of DenseHamiltonian object. funcs and mats are a list of time dependent functions and the corresponding matrices. unit is the unit one – :h or :ħ. The mats will be scaled by 2π if unit is :h.\n\nEIGS is the initializer for the eigen decomposition routine for the Hamiltonian. It should return a function of signature: (H, s, lvl) -> (w, v). The default method EIGEN_DEFAULT will use LAPACK routine.\n\n\n\n\n\n","category":"method"},{"location":"lib/hamiltonian/#QTBase.SparseHamiltonian","page":"Hamiltonian","title":"QTBase.SparseHamiltonian","text":"struct SparseHamiltonian{T<:Number} <: AbstractSparseHamiltonian{T<:Number}\n\nDefines a time dependent Hamiltonian object with sparse Matrices.\n\nFields\n\nf\nList of time dependent functions\nm\nList of constant matrices\nu_cache\nInternal cache\nsize\nSize\nEIGS\nEigen decomposition routine\n\n\n\n\n\n","category":"type"},{"location":"lib/hamiltonian/#QTBase.SparseHamiltonian-Tuple{Any,Any}","page":"Hamiltonian","title":"QTBase.SparseHamiltonian","text":"SparseHamiltonian(funcs, mats; unit, EIGS)\n\n\nConstructor of SparseHamiltonian object. funcs and mats are a list of time dependent functions and the corresponding matrices. unit is the unit one – :h or :ħ. The mats will be scaled by 2π is unit is :h.\n\nEIGS is the initializer for the eigen decomposition routine for the Hamiltonian. It should return a function of signature: (H, s, lvl) -> (w, v). The default method EIGEN_DEFAULT will use LAPACK routine.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/solver/#Open-System-Solvers","page":"Solver","title":"Open System Solvers","text":"","category":"section"},{"location":"tutorials/solver/","page":"Solver","title":"Solver","text":"QuantumAnnealingTools.jl provides several open quantum system solvers:","category":"page"},{"location":"tutorials/solver/#Redfield-equation","page":"Solver","title":"Redfield equation","text":"","category":"section"},{"location":"tutorials/solver/","page":"Solver","title":"Solver","text":"The interface to Redfield equation is:","category":"page"},{"location":"tutorials/solver/#Basic-usage","page":"Solver","title":"Basic usage","text":"","category":"section"},{"location":"tutorials/solver/","page":"Solver","title":"Solver","text":"The basic usage of Redfield solver is","category":"page"},{"location":"tutorials/solver/","page":"Solver","title":"Solver","text":"solve_redfield(\n    A::Annealing,\n    tf::Real,\n    unitary;\n    vectorize::Bool = false,\n    span_unit::Bool = false,\n    tstops = Float64[],\n    positivity_check::Bool = false,\n    kwargs...,\n)","category":"page"},{"location":"tutorials/solver/#QuantumAnnealingTools.solve_redfield-Tuple{Annealing,Real,Any}","page":"Solver","title":"QuantumAnnealingTools.solve_redfield","text":"solve_redfield(A, tf, unitary; vectorize, int_atol, int_rtol, Ta, kwargs...)\n\n\nSolve the time dependent Redfield equation for Annealing defined by A with total annealing time tf.\n\n...\n\nArguments\n\nA::Annealing: the Annealing object.\ntf::Real: the total annealing time.\nunitary: precalculated unitary of close system evolution.\nvectorize::Bool = false: whether to vectorize the density matrix.\nint_atol = 1e-8: the absolute error tolerance for integration.\nint_rtol = 1e-6: the relative error tolerance for integration.\nTa = tf: the time scale for backward integration.\nkwargs: other keyword arguments supported by DifferentialEquations.jl.\n\n...\n\n\n\n\n\n","category":"method"},{"location":"tutorials/solver/#Adiabatic-master-equation(AME)","page":"Solver","title":"Adiabatic master equation(AME)","text":"","category":"section"},{"location":"tutorials/solver/","page":"Solver","title":"Solver","text":"A good reference to adiabatic master equation is Albash, Tameem, et al. QuantumAnnealingTools.jl provides the following interfaces for AME solver:","category":"page"},{"location":"tutorials/solver/#Basic-usage-2","page":"Solver","title":"Basic usage","text":"","category":"section"},{"location":"tutorials/solver/","page":"Solver","title":"Solver","text":"The basic usage of AME solver is","category":"page"},{"location":"tutorials/solver/","page":"Solver","title":"Solver","text":"solve_ame(\n    A::Annealing,\n    tf::Real;\n    span_unit::Bool = false,\n    ω_hint = [],\n    lambshift::Bool = true,\n    lvl = size(A.H, 1),\n    kwargs...,\n)","category":"page"},{"location":"tutorials/solver/#QuantumAnnealingTools.solve_ame-Tuple{Annealing,Real}","page":"Solver","title":"QuantumAnnealingTools.solve_ame","text":"solve_ame(A, tf; tspan, ω_hint, lambshift, lvl, vectorize, kwargs...)\n\n\nSolve the adiabatic master equation for Annealing defined by A with total annealing time tf.\n\n...\n\nArguments\n\nA::Annealing: the Annealing object.\ntf::Real: the total annealing time.\ntspan = (0, tf): time interval to solve.\nω_hint=[] : grid for precalculating the lambshift; skip the precalculation if empty.\n'lambshift::Bool=true' : whether to include Lambshift in the calculation.\nlvl::Int=size(A.H, 1) : number of levels to keep. The default value is the dimension for the Hamiltonian.\nvectorize::Bool = false: whether to vectorize the density matrix.\nkwargs : other keyword arguments supported by DifferentialEquations.jl.\n\n...\n\n\n\n\n\n","category":"method"},{"location":"tutorials/solver/#Additional-solver-options","page":"Solver","title":"Additional solver options","text":"","category":"section"},{"location":"tutorials/solver/","page":"Solver","title":"Solver","text":"The extra keyword arguments kwargs will be directly passed to ODE solve interface. So every solver option is supported. However, because of the current implementation, several keyword arguments are strongly recommended:","category":"page"},{"location":"tutorials/solver/","page":"Solver","title":"Solver","text":"alg=Tsit5(): This set the algorithm to Tsitouras 5/4 Runge-Kutta method, which performs well for most problems. You can find a list of the available solver algorithms here. The implicit methods are only supported when the vectorize is set to true.\nsaveat: This argument denotes specific times to save the solution at, during the solving phase. It overrides the save_everystep keyword argument.\ntstops: This argument denotes extra times that the timestepping algorithm must step to. It will increase the accuracy if the algorithm is instructed to step to the know singularities of the problem.\nsave_everystep: Whether to save the result at every step. You can save the memory by setting it to false.","category":"page"},{"location":"tutorials/solver/#Examples","page":"Solver","title":"Examples","text":"","category":"section"},{"location":"tutorials/solver/","page":"Solver","title":"Solver","text":"An tutorial notebook for solving both Redfield and adiabatic master equation can be found here.","category":"page"},{"location":"tutorials/annealing/#Annealing","page":"Annealing","title":"Annealing","text":"","category":"section"},{"location":"tutorials/annealing/","page":"Annealing","title":"Annealing","text":"This package implements AbstractFactory pattern for potential quantum annealing process via an abstract type AbstractAnnealing. A complete quantum annealing process is assembled from the following parts:","category":"page"},{"location":"tutorials/annealing/","page":"Annealing","title":"Annealing","text":"Hamiltonian: Any object implements the AbstractHamiltonian interface\nInitial state: A state vector/density matrix\n(Optional)System bath coupling – system part\n(Optional)System bath coupling – bath part\n(Optional)Additional control protocols","category":"page"},{"location":"tutorials/annealing/","page":"Annealing","title":"Annealing","text":"For example, the following code block construct a standard single qubit annealing process","category":"page"},{"location":"tutorials/annealing/","page":"Annealing","title":"Annealing","text":"H = DenseHamiltonian([(s)->1-s, (s)->s], -[σx, σz]/2, unit=:ħ)\nu0 = PauliVec[1][1]\ncoupling = ConstantCouplings([\"Z\"], unit=:ħ)\nbath = Ohmic(1e-4, 4, 16)\nannealing = Annealing(H, u0; coupling=coupling, bath=bath)","category":"page"},{"location":"tutorials/annealing/","page":"Annealing","title":"Annealing","text":"with total Hamiltonian","category":"page"},{"location":"tutorials/annealing/","page":"Annealing","title":"Annealing","text":"H(s) = -(1-s)fracsigma_x2 - sfracsigma_z2 + sigma_z otimes B + H_B","category":"page"},{"location":"tutorials/annealing/","page":"Annealing","title":"Annealing","text":"where B H_B forms an Ohmic bath.","category":"page"},{"location":"lib/coupling/#Couplings","page":"Coupling","title":"Couplings","text":"","category":"section"},{"location":"lib/coupling/#Constant-couplings","page":"Coupling","title":"Constant couplings","text":"","category":"section"},{"location":"lib/coupling/","page":"Coupling","title":"Coupling","text":"ConstantCouplings\nConstantCouplings(mats::Union{Vector{Matrix{T}},Vector{SparseMatrixCSC{T,Int}}}; unit=:h) where {T<:Number}\nConstantCouplings(c::Vector{T}; sp = false, unit=:h) where T <: AbstractString\ncollective_coupling(op, num_qubit; sp = false, unit = :h)","category":"page"},{"location":"lib/coupling/#QTBase.ConstantCouplings","page":"Coupling","title":"QTBase.ConstantCouplings","text":"struct ConstantCouplings <: AbstractCouplings\n\nDefines constant system bath coupling operators.\n\nFields\n\nmats\n1-D array for independent coupling operators\nstr_rep\nString representation for the coupling (for display purpose)\n\n\n\n\n\n","category":"type"},{"location":"lib/coupling/#QTBase.ConstantCouplings-Union{Tuple{Union{Array{Array{T,2},1}, Array{SparseMatrixCSC{T,Int64},1}}}, Tuple{T}} where T<:Number","page":"Coupling","title":"QTBase.ConstantCouplings","text":"function ConstantCouplings(mats::Union{Vector{Matrix{T}},Vector{SparseMatrixCSC{T,Int}}}; unit=:h) where {T<:Number}\n\nConstructor of ConstantCouplings object. mats is 1-D array of matrices. str_rep is the optional string representation of the coupling terms. unit is the unit one – :h or :ħ. The mats will be scaled by 2π is unit is :h.\n\n\n\n\n\n","category":"method"},{"location":"lib/coupling/#QTBase.ConstantCouplings-Union{Tuple{Array{T,1}}, Tuple{T}} where T<:AbstractString","page":"Coupling","title":"QTBase.ConstantCouplings","text":"function ConstantCouplings(c::Vector{T}; sp = false, unit=:h) where T <: AbstractString\n\nIf the first argument is a 1-D array of strings. The constructor will automatically construct the matrics represented by the string representations.\n\n\n\n\n\n","category":"method"},{"location":"lib/coupling/#QTBase.collective_coupling-Tuple{Any,Any}","page":"Coupling","title":"QTBase.collective_coupling","text":"function collective_coupling(op, num_qubit; sp = false, unit = :h)\n\nCreate ConstantCouplings object with operator op on each qubits. op is the string representation of one of the Pauli matrices. num_qubit is the total number of qubits. sp set whether to use sparse matrices. unit set the unit one – :h or :ħ.\n\n\n\n\n\n","category":"method"},{"location":"lib/coupling/#Time-dependent-couplings","page":"Coupling","title":"Time dependent couplings","text":"","category":"section"},{"location":"lib/coupling/","page":"Coupling","title":"Coupling","text":"TimeDependentCoupling\nTimeDependentCouplings","category":"page"},{"location":"lib/coupling/#QTBase.TimeDependentCoupling","page":"Coupling","title":"QTBase.TimeDependentCoupling","text":"struct TimeDependentCoupling\n\nDefines a single time dependent system bath coupling operator. It is defined as S(s)=f(s)M.  Keyword argument unit set the unit one – :h or :ħ.\n\nFields\n\nfuncs\n1-D array of time dependent functions\nmats\n1-D array of constant matrics\n\nExamples\n\njulia> TimeDependentCoupling([(s)->s], [σz], unit=:ħ)\n\n\n\n\n\n","category":"type"},{"location":"lib/coupling/#QTBase.TimeDependentCouplings","page":"Coupling","title":"QTBase.TimeDependentCouplings","text":"struct TimeDependentCouplings <: AbstractTimeDependentCouplings\n\nDefines an 1-D array of time dependent system bath coupling operators.\n\nFields\n\ncoupling\nA tuple of single TimeDependentCoupling operators\n\n\n\n\n\n","category":"type"},{"location":"tutorials/hamiltonians/#Hamiltonians","page":"Hamiltonian","title":"Hamiltonians","text":"","category":"section"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"A Hamiltonian is basically a time-dependent matrix. The package currently offers two ways to construct a Hamiltonian object. Before introducing those constructors, let's discuss the unit of Hamiltonian first.","category":"page"},{"location":"tutorials/hamiltonians/#Unit","page":"Hamiltonian","title":"Unit","text":"","category":"section"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"From the Schrodinger equation","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"  ihbar lvert Phi rangle = H lvert Phi rangle","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"we know the Hamiltonian can be normalized by H  hbar. If we set h=1, then what appears on the RHS of Schrodinger equation is 2pi H where H has the unit of frequency. We set this unit to the natural unit of superconducting qubits – GHz.","category":"page"},{"location":"tutorials/hamiltonians/#Construction","page":"Hamiltonian","title":"Construction","text":"","category":"section"},{"location":"tutorials/hamiltonians/#Affine-Operator","page":"Hamiltonian","title":"Affine Operator","text":"","category":"section"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"For fs = [f1,f2,...,fn] and Ms = [M1,M2,...,Mn] where each of the fi and Mi are Function(or callable object) and Matrix, the following constructor:","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"function TypeHamiltonian(fs,Ms)","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"builds an time dependent Hamiltonian H = f_1(t)M_1 + f_2(t)M_2 +  + f_n(t)M_n. The Type should be changed to a specific descriptor of the Hamiltonian. For example, a Hamiltonian consisted of dense matrices can be constructed with DenseHamiltonian","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"julia> H = DenseHamiltonian([(s)->1-s, (s)->s], [σx, σz])","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"The DenseHamiltonian constructor creates a standard single qubit annealing Hamiltonian of the form H(s)=(1-s)σ_x+sσ_z, whose default unit is GHz (h=1). Internally, this package always store the value of Hhbar. So any object created with default unit will be scaled by 2π. You can set the unit to ħ=1 by using the keyword argument unit","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"julia> H_ħ  = DenseHamiltonian([(s)->1-s, (s)->s], [σx, σz]; unit=:ħ)","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"(Setting unit to :ħ means the inputs of the constructor is already Hhbar.) To obtain the value of Hamiltonian at given s in consistent units, it is recommended to use function evaluate","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"julia> evaluate(H, 0.5)\n2×2 Array{Complex{Float64},2}:\n  0.5+0.0im  -0.5+0.0im\n -0.5+0.0im  -0.5+0.0im","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"It always returns the Hamiltonian value in GHz. Calling H directly like a Function will return numerical value of Hhbar","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"julia> H(0.5) == 2π*(σx + σz)/2\ntrue","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"There are two additional constructors: SparseHamiltonian and AdiabaticFrameHamiltonian, which construct sparse Hamiltonians and Hamiltonians in adiabatic frame respectively.","category":"page"},{"location":"tutorials/hamiltonians/#Interpolating","page":"Hamiltonian","title":"Interpolating","text":"","category":"section"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"The second method is to construct the Hamiltonian by interpolating gridded values","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"  H(s_1) H(s_2) ldots","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"Internally, the package rely on Interpolations.jl for fast interpolating. The syntax for constructing interpolation Hamiltonian object is","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"H_interp = InterpDenseHamiltonian(s_axis, H_list)\nH_interp = InterpSparseHamiltonian(s_axis, H_list)","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"where s_axis and H_list are the grid points and corresponding Hamiltonian values. The constructors also take keyword argument method, order and unit. method and order specify the internal interpolation method. For dense Hamiltonians, both BSpline of order 0-3 and Gridded of order 0-1 are supported. For sparse Hamiltonians, only Gridded of order 0-1 is supported.","category":"page"},{"location":"tutorials/hamiltonians/#Eigendecomposition","page":"Hamiltonian","title":"Eigendecomposition","text":"","category":"section"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"eigen_decomp can be used to perform eigendecomposition on the AbstractHamiltonian at a particular time. For example","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"w, v = eigen_decomp(H, 0.5, lvl=2)","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"calculate the lowest two energy eigenvalues and eigenvectors of H at s=05. w is returned in the unit of GHz and each column in v corresponds to one eigenvector.","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"In addition, a user-defined eigendecomposition function can be attached to the AbstractHamiltonian object if there is better eigendecomposition algorithm than the default LAPACK routine. The following code","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"function build_user_eigen(u_cache)\n    EIGS = function(H, t, lvl)\n        println(\"I am the user defined eigendecomposition routine.\")\n        w, v = eigen(Hermitian(H(t)))\n        w[1:lvl], v[:, 1:lvl]\n    end\nend\n\nH = DenseHamiltonian([(s)->1-s, (s)->s], [σx, σz], EIGS=build_user_eigen)\neigen_decomp(H, 0.5, lvl=2)","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"is a trivial example of replacing the default eigendecomposition routine with a user-defined one. More details can be found in this tutorial.","category":"page"},{"location":"tutorials/hamiltonians/#Plotting","page":"Hamiltonian","title":"Plotting","text":"","category":"section"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"This package can also interact with Plots.jl to provide convenient ways for visualizing the spectrum of any given Hamiltonians. For example","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"using Plots\nplot(H, 0:0.01:1, 2)","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"will produce the following figure. The second argument 0:0.01:1 is the x_axis values and the third argument 2 is the number of levels to plot. The third argument can also be a list of levels.","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"(Image: plot_hamiltonian_example)","category":"page"},{"location":"tutorials/bath/#Bath","page":"Bath","title":"Bath","text":"","category":"section"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"We start with a general form of system bath interaction Hamiltonian","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"  H_SB = sum_alpha S_alphaotimes B_alpha","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"and define each B_alpha (together with the bath Hamiltonian H_B) as an AbstractBath object. An important metric for any bath is its two point correlation function","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"  C(t_1 t_2) = langle mathcalB(t_1) mathcalB(t_2) rangle","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"where","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"  mathcalB(t) = U_B^dagger (t) B U_B(t)","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"and U_B(t) is the unitary generated by the pure bath Hamiltonian","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"  U_B(t) = mathcalTexpBig -iint_0^t H_B mathrmdtau Big","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"The spectrum density of the bath is defined as the Fourier transform of the correlation function and is usually denoted as S(omega). It is important to notice that, only for Gaussian bath(or bath which satisfies the Wick Theorem) does the correlation function uniquely determine the bath. Otherwise, high order correlation functions may be necessary. Nevertheless, it is still an area of active research on how to experimentally measure those high order correlation functions. So in most occasions, only two point correlation function is available to us and we treat the noise as Gaussian.","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"Currently, there are two build-in concrete types of the AbstractBath class – OhmicBath and HybridOhmicBath. More examples can be found in this notebook.","category":"page"},{"location":"tutorials/bath/#Ohmic-Bath","page":"Bath","title":"Ohmic Bath","text":"","category":"section"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"A self-consistent reference for Ohmic bath is Albash, Tameem, et al. We can use Ohmic function to construct OhmicBath object","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"η = 1e-4; fc=4; T=16\nbath = Ohmic(η, fc, T);","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"The correlation and spectrum function of the bath object can be calculated by","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"correlation(τ, bath)\nspectrum(ω, bath)","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"This interface is true for every concrete type of AbstractBath. However, the plotting system works differently for different bath models. For OhmicBath, you can use","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"ω = range(0, 20, length=200)\nplot(bath, :γ, ω)\nplot(bath, :S, ω)","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"to conveniently plot the spectrum and lamb shift.","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"(Image: plot_ohmic_spectrum) (Image: plot_ohmic_lamb)","category":"page"},{"location":"tutorials/bath/#Hybrid-Ohmic-Bath","page":"Bath","title":"Hybrid Ohmic Bath","text":"","category":"section"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"A good reference paper for the hybrid ohmic bath model is Lanting et al. The model is generalized in Smirnov and Amin. The basic idea is, the noise spectrum of this bath model can be split into the low frequency and high frequency parts","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"  S(omega) = S^L(ω) + S^H(ω)","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"The high frequency part of the bath is the Ohmic and the low frequency part can be something like the 1f noise. The benefit of this formalism is that, instead of the entire spectrum density, S^L(omega) can be parametrized by a single parameter in the macroscopic resonant tunneling(MRT) experiment.","category":"page"},{"location":"#HOME","page":"Home","title":"HOME","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is a quantum annealing toolbox for Julia programming language.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package is written in Julia programming language. To learn more about Julia, please check its excellent doc pages. If you want to learn more about quantum annealing/adiabatic quantum computing, this review paper is a good place to start.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package has a core component package QTBase.jl, both of which are currently unregistered. To install, just run the following command inside the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(PackageSpec(url=\"https://github.com/USCqserver/QTBase.jl\", rev=\"master\"))\nPkg.add(PackageSpec(url=\"https://github.com/USCqserver/QuantumAnnealingTools.jl\", rev=\"master\"))","category":"page"},{"location":"","page":"Home","title":"Home","text":"It will install the packages directly from their github repos. This can also be done in Julia's Pkg REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(1.2) pkg> add https://github.com/USCqserver/QTBase.jl\n(1.2) pkg> add https://github.com/USCqserver/QuantumAnnealingTools.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"More information about Julia's package manager can be found at Pkg.jl.","category":"page"},{"location":"#Useful-Packages","page":"Home","title":"Useful Packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"It is recommended to install the following external packages:  ","category":"page"},{"location":"#[Plots.jl](https://github.com/JuliaPlots/Plots.jl)","page":"Home","title":"Plots.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Plots is a visualization interface and toolset for Julia. QuantumAnnealingTools.jl provides several plotting functionality by recipes to Plots.jl.","category":"page"},{"location":"#[DifferentialEquations.jl](http://docs.juliadiffeq.org/latest/)","page":"Home","title":"DifferentialEquations.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Even though QuantumAnnealingTools.jl can function without DifferentialEquations.jl, it needs to be loaded in order for the master equation solvers to work properly. For low dependency usage, replacing DifferentialEquations by OrdinaryDiffEq.jl will also work.","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In the first example, we solve a standard single qubit annealing problem with Hamiltonian","category":"page"},{"location":"","page":"Home","title":"Home","text":"    H(s) = A(s)σ_x + B(s)σ_z","category":"page"},{"location":"","page":"Home","title":"Home","text":"where A(s)=1-s and B(s)=s are usually known as annealing schedules. The general workflow is to define the Hamiltonian, construct the annealing process and then solve the system dynamics. The full code for this example is","category":"page"},{"location":"","page":"Home","title":"Home","text":"using QuantumAnnealingTools\nusing DifferentialEquations\ntf = 20\nu0 = PauliVec[1][2]\nH = DenseHamiltonian([(s)->1-s, (s)->s], [σx, σz], unit=:ħ)\nannealing = Annealing(H, u0)\nsol = solve_schrodinger(annealing, tf)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where the pieces are explained below.","category":"page"},{"location":"","page":"Home","title":"Home","text":"First, we need to load the package DifferentialEquations.jl for ODE solvers. Then we define the Hamiltonian of the annealing process. In this package, a time dependent Hamiltonian can be specified by a list of time dependent functions and a list of constant matrices","category":"page"},{"location":"","page":"Home","title":"Home","text":"H = DenseHamiltonian([(s)->1-s, (s)->s], [σx, σz], unit=:ħ)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The resulting Hamiltonian is an affine combination of the corresponding functions and matrices (1-s)σ_x + sσ_z. Then we define the initial state u0. Together with Hamiltonian, an annealing object can be constructed","category":"page"},{"location":"","page":"Home","title":"Home","text":"annealing = Annealing(H, u0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The final step is to solve system dynamics. In this example, directly solve the Schrodinger equation for a total annealing time tf.","category":"page"},{"location":"#Tutorials","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following tutorials will introduce you to the functionality of QuantumAnnealingTools.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"tutorials/math_symbol.md\",\n    \"tutorials/hamiltonians.md\",\n    \"tutorials/couplings.md\",\n    \"tutorials/bath.md\",\n    \"tutorials/annealing.md\"\n    ]\nDepth = 1","category":"page"},{"location":"lib/bath/#Bath-Module","page":"Bath","title":"Bath Module","text":"","category":"section"},{"location":"lib/bath/#Ohmic-bath","page":"Bath","title":"Ohmic bath","text":"","category":"section"},{"location":"lib/bath/","page":"Bath","title":"Bath","text":"OhmicBath\nOhmic","category":"page"},{"location":"lib/bath/#QTBase.OhmicBath","page":"Bath","title":"QTBase.OhmicBath","text":"OhmicBath\n\nOhmic bath object to hold a particular parameter set.\n\nFields\n\nη – strength.\nωc – cutoff frequence.\nβ – inverse temperature.\n\n\n\n\n\n","category":"type"},{"location":"lib/bath/#QTBase.Ohmic","page":"Bath","title":"QTBase.Ohmic","text":"Ohmic(η, fc, T)\n\n\nConstruct OhmicBath from parameters with physical unit: η–unitless interaction strength; fc–cutoff frequency in GHz; T–temperature in mK.\n\n\n\n\n\n","category":"function"},{"location":"lib/bath/#Common-interface","page":"Bath","title":"Common interface","text":"","category":"section"},{"location":"lib/bath/","page":"Bath","title":"Bath","text":"correlation(τ, bath::OhmicBath)\nγ(ω, bath::OhmicBath)\nspectrum(ω, bath::OhmicBath)\nS(w, bath::OhmicBath; atol=1e-7)","category":"page"},{"location":"lib/bath/#QTBase.correlation-Tuple{Any,OhmicBath}","page":"Bath","title":"QTBase.correlation","text":"correlation(τ, bath)\n\n\nCalculate the two point correlation function C(τ) of bath.\n\n\n\n\n\n","category":"method"},{"location":"lib/bath/#QTBase.γ-Tuple{Any,OhmicBath}","page":"Bath","title":"QTBase.γ","text":"γ(ω, bath)\n\n\nCalculate spectrum density γ(ω) of bath.\n\n\n\n\n\n","category":"method"},{"location":"lib/bath/#QTBase.spectrum-Tuple{Any,OhmicBath}","page":"Bath","title":"QTBase.spectrum","text":"spectrum(ω, bath)\n\n\nCalculate spectrum density γ(ω) of bath.\n\n\n\n\n\n","category":"method"},{"location":"lib/bath/#QTBase.S-Tuple{Any,OhmicBath}","page":"Bath","title":"QTBase.S","text":"S(w, bath; atol)\n\n\nCalculate the Lamb shift of Ohmic spectrum. atol is the absolute tolerance for Cauchy principal value integral.\n\n\n\n\n\n","category":"method"}]
}
