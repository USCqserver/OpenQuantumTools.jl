var documenterSearchIndex = {"docs":
[{"location":"tutorials/couplings/#Couplings-1","page":"Coupling","title":"Couplings","text":"","category":"section"},{"location":"tutorials/couplings/#","page":"Coupling","title":"Coupling","text":"We start with a general form of system bath interaction Hamiltonian","category":"page"},{"location":"tutorials/couplings/#","page":"Coupling","title":"Coupling","text":"  H_SB = sum_alpha S_alphaotimes B_alpha","category":"page"},{"location":"tutorials/couplings/#","page":"Coupling","title":"Coupling","text":"and define the set of S_alpha_alpha whose corresponding B_α_alpha are independent and identical(IID) as AbstractCouplings objects. Mathematically, every element in the same AbstractCouplings object shares the same bath correlation function. (For operators which couple to the same bath, they can be added together.) Two concrete types of AbstractCouplings are implemented – ConstantCouplings and TimeDependentCouplings. The former represents time-independent operators. For example, the following codes","category":"page"},{"location":"tutorials/couplings/#","page":"Coupling","title":"Coupling","text":"julia> coupling = ConstantCouplings([\"ZI\", \"IZ\"])","category":"page"},{"location":"tutorials/couplings/#","page":"Coupling","title":"Coupling","text":"creates a set of two constant operators: ZI and IZ. The corresponding interaction Hamiltonian is","category":"page"},{"location":"tutorials/couplings/#","page":"Coupling","title":"Coupling","text":"  H_SB = ZIB_1 + IZB_2","category":"page"},{"location":"tutorials/couplings/#","page":"Coupling","title":"Coupling","text":"where B_1 and B_2 are IID. On the other hand, TimeDependentCouplings can be constructed with a two-step procedure. First, single TimeDependentCoupling needs to be constructed","category":"page"},{"location":"tutorials/couplings/#","page":"Coupling","title":"Coupling","text":"c1 = TimeDependentCoupling([(s)->cos(s)], [σx]; unit=:ħ)\nc2 = TimeDependentCoupling([(s)->sin(s)], [σz]; unit=:ħ)","category":"page"},{"location":"tutorials/couplings/#","page":"Coupling","title":"Coupling","text":"The above codes creates two time dependent coupling operators cos(s) X and sin(s) Z. Then, c1 and c2 can be grouped together to create the coupling set","category":"page"},{"location":"tutorials/couplings/#","page":"Coupling","title":"Coupling","text":"coupling = TimeDependentCouplings(c1, c2)","category":"page"},{"location":"tutorials/couplings/#","page":"Coupling","title":"Coupling","text":"Only ConstantCouplings and TimeDependentCouplings can be used to create an annealing process.","category":"page"},{"location":"tutorials/math_symbol/#Math-Symbols-1","page":"Math Symbol","title":"Math Symbols","text":"","category":"section"},{"location":"tutorials/math_symbol/#","page":"Math Symbol","title":"Math Symbol","text":"The package defines some commonly used mathematical symbols and operators. Some of its features include:","category":"page"},{"location":"tutorials/math_symbol/#Pauli-Matrices-1","page":"Math Symbol","title":"Pauli Matrices","text":"","category":"section"},{"location":"tutorials/math_symbol/#","page":"Math Symbol","title":"Math Symbol","text":"Single qubit Pauli matrices are defined by σx, σy, σz and σi. One can simply calculate the tensor product of single qubits Pauli matrices by","category":"page"},{"location":"tutorials/math_symbol/#","page":"Math Symbol","title":"Math Symbol","text":"julia> σx⊗σz\n4×4 Array{Complex{Float64},2}:\n 0.0+0.0im   0.0+0.0im  1.0+0.0im   0.0+0.0im\n 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -1.0+0.0im\n 1.0+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im\n 0.0+0.0im  -1.0+0.0im  0.0+0.0im  -0.0+0.0im","category":"page"},{"location":"tutorials/math_symbol/#","page":"Math Symbol","title":"Math Symbol","text":"The eigenvectors of each Pauli matrices are also defined in constant PauliVec, where PauliVec[1],PauliVec[2],PauliVec[3] corresponds to eigenvectors of σx, σy, σz. Additionally, the first eigenvector is the one with positive eigenvalue","category":"page"},{"location":"tutorials/math_symbol/#","page":"Math Symbol","title":"Math Symbol","text":"julia> σz*PauliVec[3][1] == PauliVec[3][1]\ntrue","category":"page"},{"location":"tutorials/math_symbol/#","page":"Math Symbol","title":"Math Symbol","text":"Additionally, a sparse version of Pauli matrices are defined in spσx et al. They can be used to construct Hamiltonian in the form of sparse matrix.","category":"page"},{"location":"tutorials/math_symbol/#Construction-of-Multi-Qubits-Matrices-1","page":"Math Symbol","title":"Construction of Multi-Qubits Matrices","text":"","category":"section"},{"location":"tutorials/math_symbol/#","page":"Math Symbol","title":"Math Symbol","text":"The package provides various utility functions to construct multi-qubits matrices. For all the functions listed below, keyword argument sp can be set to generate sparse matrices.","category":"page"},{"location":"tutorials/math_symbol/#","page":"Math Symbol","title":"Math Symbol","text":"The standard driver Hamiltonian in quantum annealing can be constructed with standard_driver","category":"page"},{"location":"tutorials/math_symbol/#","page":"Math Symbol","title":"Math Symbol","text":"julia> standard_driver(2) == σx⊗σi + σi⊗σx\ntrue","category":"page"},{"location":"tutorials/math_symbol/#","page":"Math Symbol","title":"Math Symbol","text":"and for sparse matrices","category":"page"},{"location":"tutorials/math_symbol/#","page":"Math Symbol","title":"Math Symbol","text":"julia> standard_driver(2, sp=true) == spσx⊗spσi + spσi⊗spσx\ntrue","category":"page"},{"location":"tutorials/math_symbol/#","page":"Math Symbol","title":"Math Symbol","text":"A multi-qubits matrix can be constructed from its string representation using q_translate","category":"page"},{"location":"tutorials/math_symbol/#","page":"Math Symbol","title":"Math Symbol","text":"julia> q_translate(\"ZZ+0.5ZI-XZ\")\n4×4 Array{Complex{Float64},2}:\n  1.5+0.0im   0.0+0.0im  -1.0+0.0im   0.0+0.0im\n  0.0+0.0im  -0.5+0.0im   0.0+0.0im   1.0+0.0im\n -1.0+0.0im   0.0+0.0im  -1.5+0.0im  -0.0+0.0im\n  0.0+0.0im   1.0+0.0im  -0.0+0.0im   0.5+0.0im","category":"page"},{"location":"tutorials/math_symbol/#","page":"Math Symbol","title":"Math Symbol","text":"Collective operators(same Pauli operator acting on each individual qubit) can be constructed with collective_operator","category":"page"},{"location":"tutorials/math_symbol/#","page":"Math Symbol","title":"Math Symbol","text":"julia> collective_operator(\"z\", 3) == σz⊗σi⊗σi + σi⊗σz⊗σi + σi⊗σi⊗σz\ntrue","category":"page"},{"location":"tutorials/math_symbol/#","page":"Math Symbol","title":"Math Symbol","text":"Single clause in multi-qubits Hamiltonian can be constructed by","category":"page"},{"location":"tutorials/math_symbol/#","page":"Math Symbol","title":"Math Symbol","text":"julia> single_clause([\"z\",\"z\"], [2,3], -2, 4) == -2σi⊗σz⊗σz⊗σi\ntrue","category":"page"},{"location":"tutorials/math_symbol/#","page":"Math Symbol","title":"Math Symbol","text":"Local field terms of the form ΣhᵢZᵢ can be constructed with local_field_term","category":"page"},{"location":"tutorials/math_symbol/#","page":"Math Symbol","title":"Math Symbol","text":"julia> local_field_term([1.0, 0.5], [1, 2], 2) == σz⊗σi+0.5σi⊗σz\ntrue","category":"page"},{"location":"tutorials/math_symbol/#","page":"Math Symbol","title":"Math Symbol","text":"Two local terms of the form JᵢⱼZᵢZⱼ can be constructed with two_local_term","category":"page"},{"location":"tutorials/math_symbol/#","page":"Math Symbol","title":"Math Symbol","text":"julia> two_local_term([1.0, 0.5], [[1,2], [1,3]], 3) == σz⊗σz⊗σi + 0.5σz⊗σi⊗σz\ntrue","category":"page"},{"location":"tutorials/math_symbol/#Construction-of-Multi-Qubits-states-1","page":"Math Symbol","title":"Construction of Multi-Qubits states","text":"","category":"section"},{"location":"tutorials/math_symbol/#","page":"Math Symbol","title":"Math Symbol","text":"The quantum state of spin system can be construct with q_translate_state","category":"page"},{"location":"tutorials/math_symbol/#","page":"Math Symbol","title":"Math Symbol","text":"julia> q_translate_state(\"001\")\n8-element Array{Complex{Float64},1}:\n 0.0 + 0.0im\n 1.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im","category":"page"},{"location":"tutorials/math_symbol/#","page":"Math Symbol","title":"Math Symbol","text":"In the string representation 0 and 1 represent the eigenstates of σ_z operator.","category":"page"},{"location":"tutorials/annealing/#Annealing-1","page":"Annealing","title":"Annealing","text":"","category":"section"},{"location":"tutorials/annealing/#","page":"Annealing","title":"Annealing","text":"This package implements AbstractFactory pattern for potential quantum annealing process via an abstract type AbstractAnnealing. A complete quantum annealing process is assembled from the following parts:","category":"page"},{"location":"tutorials/annealing/#","page":"Annealing","title":"Annealing","text":"Hamiltonian: Any object implements the AbstractHamiltonian interface\nInitial state: A state vector/density matrix\n(Optional)System bath coupling – system part\n(Optional)System bath coupling – bath part\n(Optional)Additional control protocols","category":"page"},{"location":"tutorials/annealing/#","page":"Annealing","title":"Annealing","text":"For example, the following code block construct a standard single qubit annealing process","category":"page"},{"location":"tutorials/annealing/#","page":"Annealing","title":"Annealing","text":"H = DenseHamiltonian([(s)->1-s, (s)->s], -[σx, σz]/2)\nu0 = PauliVec[1][1]\ncoupling = ConstantCouplings([\"Z\"])\nbath = Ohmic(1e-4, 4, 16)\nannealing = Annealing(H, u0; coupling=coupling, bath=bath)","category":"page"},{"location":"tutorials/annealing/#","page":"Annealing","title":"Annealing","text":"with Hamiltonian","category":"page"},{"location":"tutorials/annealing/#","page":"Annealing","title":"Annealing","text":"H(s) = -(1-s)fracsigma_x2 - sfracsigma_z2 + sigma_z otimes B + H_B","category":"page"},{"location":"tutorials/hamiltonians/#Hamiltonians-1","page":"Hamiltonian","title":"Hamiltonians","text":"","category":"section"},{"location":"tutorials/hamiltonians/#","page":"Hamiltonian","title":"Hamiltonian","text":"The Hamiltonian object implements AffineDiffEqOperator interface.","category":"page"},{"location":"tutorials/hamiltonians/#Note:-this-functionality-in-[DifferentialEquations.jl](http://docs.juliadiffeq.org/latest/)-is-still-under-heavy-development.-The-interface-of-this-package-may-change-accordingly-in-the-future.-1","page":"Hamiltonian","title":"Note: this functionality in DifferentialEquations.jl is still under heavy development. The interface of this package may change accordingly in the future.","text":"","category":"section"},{"location":"tutorials/hamiltonians/#Construction-1","page":"Hamiltonian","title":"Construction","text":"","category":"section"},{"location":"tutorials/hamiltonians/#","page":"Hamiltonian","title":"Hamiltonian","text":"For fs = [f1,f2,...,fn] and Ms = [M1,M2,...,Mn] where each of the fi and Mi are Function(or callable object) and Matrix, the following constructor:","category":"page"},{"location":"tutorials/hamiltonians/#","page":"Hamiltonian","title":"Hamiltonian","text":"function TypeHamiltonian(fs,Ms)","category":"page"},{"location":"tutorials/hamiltonians/#","page":"Hamiltonian","title":"Hamiltonian","text":"builds an time dependent H = f_1(t)M_1 + f_2(t)M_2 +  + f_n(t)M_n. The Type should be changed to a specific descriptor of the Hamiltonian. For example, a Hamiltonian consisted of dense matrices can be constructed with DenseHamiltonian","category":"page"},{"location":"tutorials/hamiltonians/#","page":"Hamiltonian","title":"Hamiltonian","text":"julia> H = DenseHamiltonian([(s)->1-s, (s)->s], [σx, σz])","category":"page"},{"location":"tutorials/hamiltonians/#","page":"Hamiltonian","title":"Hamiltonian","text":"The DenseHamiltonian constructor creates a standard single qubit annealing Hamiltonian of the form H(s)=(1-s)σ_x+sσ_z, whose default unit is GHz (h=1). Internally, this package always uses the unit system of ħ=1. So any object created with default unit will be scaled by 2π. You can set the unit to ħ=1 by using the keyword argument unit","category":"page"},{"location":"tutorials/hamiltonians/#","page":"Hamiltonian","title":"Hamiltonian","text":"julia> H_ħ  = DenseHamiltonian([(s)->1-s, (s)->s], [σx, σz]; unit=:ħ)","category":"page"},{"location":"tutorials/hamiltonians/#","page":"Hamiltonian","title":"Hamiltonian","text":"To obtain the value of Hamiltonian at given s in consistent units, it is recommended to use function evaluate","category":"page"},{"location":"tutorials/hamiltonians/#","page":"Hamiltonian","title":"Hamiltonian","text":"julia> evaluate(H, 0.5)\n2×2 Array{Complex{Float64},2}:\n  0.5+0.0im  -0.5+0.0im\n -0.5+0.0im  -0.5+0.0im","category":"page"},{"location":"tutorials/hamiltonians/#","page":"Hamiltonian","title":"Hamiltonian","text":"It always returns the Hamiltonian value in GHz (h=1). Calling H directly like a Function will produce the raw numerical value","category":"page"},{"location":"tutorials/hamiltonians/#","page":"Hamiltonian","title":"Hamiltonian","text":"julia> H(0.5) == 2π*(σx + σz)/2\ntrue","category":"page"},{"location":"tutorials/hamiltonians/#","page":"Hamiltonian","title":"Hamiltonian","text":"There are two additional constructors: SparseHamiltonian and AdiabaticFrameHamiltonian, which construct sparse Hamiltonians and Hamiltonians in adiabatic frame respectively.","category":"page"},{"location":"tutorials/hamiltonians/#Plotting-1","page":"Hamiltonian","title":"Plotting","text":"","category":"section"},{"location":"tutorials/hamiltonians/#","page":"Hamiltonian","title":"Hamiltonian","text":"This package can also interact with Plots.jl to provide convenient ways for visualizing the objects. For AbstractHamiltonians, plot function can be used to plot the its energy structure.","category":"page"},{"location":"tutorials/hamiltonians/#","page":"Hamiltonian","title":"Hamiltonian","text":"using Plots\nplot(H, 0:0.01:1, 2)","category":"page"},{"location":"tutorials/hamiltonians/#","page":"Hamiltonian","title":"Hamiltonian","text":"The above code will produce the following figure","category":"page"},{"location":"tutorials/hamiltonians/#","page":"Hamiltonian","title":"Hamiltonian","text":"(Image: plot_hamiltonian_example)","category":"page"},{"location":"lib/QTBase/#","page":"Base","title":"Base","text":"Modules = [QTBase]\nPrivate = false","category":"page"},{"location":"lib/QTBase/#QTBase.PauliVec","page":"Base","title":"QTBase.PauliVec","text":"PauliVec\n\nConstants for the eigenvectors of single qubit Pauli matrices. Indices 1, 2 and 3 corresponds to the eigenvectors of σ_x, σ_y and σ_z.\n\nExamples\n\njulia> σx*PauliVec[1][1] == PauliVec[1][1]\ntrue\n\n\n\n\n\n","category":"constant"},{"location":"lib/QTBase/#QTBase.AbstractAnnealingControl","page":"Base","title":"QTBase.AbstractAnnealingControl","text":"abstract type AbstractAnnealingControl\n\nBase for types defining various control protocols in quantum annealing process.\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.AbstractAnnealingParams","page":"Base","title":"QTBase.AbstractAnnealingParams","text":"abstract type AbstractAnnealingParams\n\nBase for types defining parameters for annealing ODEs.\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.AbstractCouplings","page":"Base","title":"QTBase.AbstractCouplings","text":"abstract type AbstractCouplings\n\nBase for types defining system bath coupling operators in open quantum system models.\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.AbstractDenseHamiltonian","page":"Base","title":"QTBase.AbstractDenseHamiltonian","text":"abstract type AbstractDenseHamiltonian <: AbstractHamiltonian{T<:Number}\n\nBase for types defining Hamiltonians using dense matrices.\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.AbstractHamiltonian","page":"Base","title":"QTBase.AbstractHamiltonian","text":"abstract type AbstractHamiltonian\n\nSuptertype for Hamiltonians with elements of type T. Any Hamiltonian object should implement two interfaces: H(t) and H(du, u, p, t).\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.AbstractOpenSys","page":"Base","title":"QTBase.AbstractOpenSys","text":"abstract type AbstractOpenSys\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.AbstractSparseHamiltonian","page":"Base","title":"QTBase.AbstractSparseHamiltonian","text":"abstract type AbstractSparseHamiltonian <: AbstractHamiltonian{T<:Number}\n\nBase for types defining Hamiltonians using sparse matrices.\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.AdiabaticFrameHamiltonian","page":"Base","title":"QTBase.AdiabaticFrameHamiltonian","text":"struct AdiabaticFrameHamiltonian{T} <: AbstractDenseHamiltonian{T}\n\nDefines a time dependent Hamiltonian in adiabatic frame.\n\nFields\n\ngeometric\nGeometric part\ndiagonal\nAdiabatic part\nsize\nSize of the Hamiltonian\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.AdiabaticFrameHamiltonian-Tuple{Any,Any}","page":"Base","title":"QTBase.AdiabaticFrameHamiltonian","text":"function AdiabaticFrameHamiltonian(ωfuns, geofuns)\n\nConstructor of adiabatic frame Hamiltonian. ωfuns is a 1-D array of functions which specify the eigen energies (in GHz) of the Hamiltonian. geofuns is a 1-D array of functions which specifies the geometric phases of the Hamiltonian. geofuns can be thought as a flattened lower triangular matrix (without diagonal elements) in column-major order.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.Annealing","page":"Base","title":"QTBase.Annealing","text":"struct Annealing{hType, uType} <: QTBase.AbstractAnnealing{hType,uType}\n\nDefines a quantum annealing process.\n\nFields\n\nH\nHamiltonian for the annealing.\nu0\nInitial state for the annealing.\nsspan\nRange of annealing parameter.\ncoupling\nA list of system bath coupling operators(system part).\nbath\nA list of system bath coupling operators(bath part).\ncontrol\nAdditional control protocols for the annealing.\ntstops\nExtra times that the timestepping algorithm must step to.\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.AnnealingParams","page":"Base","title":"QTBase.AnnealingParams","text":"struct AnnealingParams{T<:Union{AbstractFloat, UnitTime}} <: AbstractAnnealingParams\n\nDefines a complete set of parameters, which includes Hamiltonian, total annealing time, open system and control objects.\n\nFields\n\nH\nHamiltonian\ntf\nTotal annealing time\nopensys\nOpen system object\ncontrol\nAnnealing control object\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.ConstantCouplings","page":"Base","title":"QTBase.ConstantCouplings","text":"struct ConstantCouplings <: AbstractCouplings\n\nDefines constant system bath coupling operators.\n\nFields\n\nmats\n1-D array for independent coupling operators\nstr_rep\nString representation for the coupling (for display purpose)\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.ConstantCouplings-Union{Tuple{Array{T,1}}, Tuple{T}} where T<:AbstractString","page":"Base","title":"QTBase.ConstantCouplings","text":"function ConstantCouplings(c::Vector{T}; sp = false, unit=:h) where T <: AbstractString\n\nIf the first argument is a 1-D array of strings. The constructor will automatically construct the matrics represented by the string representations.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.ConstantCouplings-Union{Tuple{Union{Array{Array{T,2},1}, Array{SparseMatrixCSC{T,Int64},1}}}, Tuple{T}} where T<:Number","page":"Base","title":"QTBase.ConstantCouplings","text":"function ConstantCouplings(mats; str_rep=nothing, unit=:h)\n\nConstructor of ConstantCouplings object. mats is 1-D array of matrices. str_rep is the optional string representation of the coupling terms. unit is the unit one – :h or :ħ. The mats will be scaled by 2π is unit is :h.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.DaviesGenerator","page":"Base","title":"QTBase.DaviesGenerator","text":"struct DaviesGenerator <: AbstractOpenSys\n\nDefines Davies generator\n\nFields\n\ncoupling\nSystem bath coupling operators\nγ\nSpectrum density\nS\nLambshift spectrum density\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.DenseHamiltonian","page":"Base","title":"QTBase.DenseHamiltonian","text":"struct DenseHamiltonian{T<:Number} <: AbstractDenseHamiltonian{T<:Number}\n\nDefines a time dependent Hamiltonian object with dense Matrices.\n\nFields\n\nf\nList of time dependent functions\nm\nList of constant matrices\nu_cache\nInternal cache\nsize\nSize\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.DenseHamiltonian-Tuple{Any,Any}","page":"Base","title":"QTBase.DenseHamiltonian","text":"function DenseHamiltonian(funcs, mats; unit = :h)\n\nConstructor of DenseHamiltonian object. funcs and mats are a list of time dependent functions and the corresponding matrices. unit is the unit one – :h or :ħ. The mats will be scaled by 2π if unit is :h.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.DenseHamiltonian-Tuple{Real}","page":"Base","title":"QTBase.DenseHamiltonian","text":"function (h::DenseHamiltonian)(t::Real)\n\nCalling the Hamiltonian returns the value 2πH(t).\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.LightAnnealingParams","page":"Base","title":"QTBase.LightAnnealingParams","text":"struct LightAnnealingParams{T<:Union{AbstractFloat, UnitTime}} <: AbstractAnnealingParams\n\nDefines a light version of parameters for annealing ODEs.\n\nFields\n\ntf\nTotal annealing time\ncontrol\nAnnealing control object\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.OpenSysSets","page":"Base","title":"QTBase.OpenSysSets","text":"abstract type OpenSysSets <: AbstractOpenSys\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.ProjectedCoupling","page":"Base","title":"QTBase.ProjectedCoupling","text":"struct ProjectedCoupling\n\nObject for a projected coupling parameterized by NIBA parameters. This object holds the numerical values at gridded points.\n\nFields\n\ns\nTime grid (unitless) for projection\na\n(σ_m - σ_n)^2\nb\nσ_mn^2\nc\nσ_mn(σ_m-σ_n)\nd\nσ_mn(σ_m+σ_n)\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.ProjectedSystem","page":"Base","title":"QTBase.ProjectedSystem","text":"struct ProjectedSystem\n\nObject for a projected low level system. The projection is only valid for real Hamiltonians.\n\nFields\n\ns\nTime grid (unitless) for projection\nev\nEnergy values for different levels\ndθ\nGeometric terms\nop\nProjected system bath interaction operators\nref\nEnergy eigenstates at the final time\nlvl\nNumber of levels being kept\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.ProjectedTG","page":"Base","title":"QTBase.ProjectedTG","text":"struct ProjectedTG\n\nObject for a projected system Hamiltonian parameterized by NIBA parameters. This object holds the numerical values at gridded points.\n\nFields\n\ns\nTime grid (unitless) for projection\nω\nFrequencies of given basis states\nT\nAdiabatic part\nG\nGeometric phase\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.SparseHamiltonian","page":"Base","title":"QTBase.SparseHamiltonian","text":"struct SparseHamiltonian{T<:Number} <: AbstractSparseHamiltonian{T<:Number}\n\nDefines a time dependent Hamiltonian object with sparse Matrices.\n\nFields\n\nf\nList of time dependent functions\nm\nList of constant matrices\nu_cache\nInternal cache\nsize\nSize\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.SparseHamiltonian-Tuple{Any,Any}","page":"Base","title":"QTBase.SparseHamiltonian","text":"function SparseHamiltonian(funcs, mats; unit=:h)\n\nConstructor of SparseHamiltonian object. funcs and mats are a list of time dependent functions and the corresponding matrices. unit is the unit one – :h or :ħ. The mats will be scaled by 2π is unit is :h.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.SparseHamiltonian-Tuple{Real}","page":"Base","title":"QTBase.SparseHamiltonian","text":"function (h::SparseHamiltonian)(t::Real)\n\nCalling the Hamiltonian returns the value 2πH(t).\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.TimeDependentCoupling","page":"Base","title":"QTBase.TimeDependentCoupling","text":"struct TimeDependentCoupling\n\nDefines a single time dependent system bath coupling operator. It is defined as S(s)=f(s)M.  Keyword argument unit set the unit one – h or ħ.\n\nFields\n\nfuncs\n1-D array of time dependent functions\nmats\n1-D array of constant matrics\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.TimeDependentCouplings","page":"Base","title":"QTBase.TimeDependentCouplings","text":"struct TimeDependentCouplings <: AbstractCouplings\n\nDefines an 1-D array of time dependent system bath coupling operators.\n\nFields\n\ncoupling\nA tuple of single TimeDependentCoupling operators\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.UnitTime","page":"Base","title":"QTBase.UnitTime","text":"struct UnitTime{T<:AbstractFloat}\n\nA speical time object to tell the solver that physical time should be used instead of the unitless time.\n\nFields\n\nt\nTime in physical unit\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.:⊗","page":"Base","title":"QTBase.:⊗","text":"⊗(A, B)\n\nCalculate the tensor product of A and B.\n\nExamples\n\njulia> σx⊗σz\n4×4 Array{Complex{Float64},2}:\n 0.0+0.0im   0.0+0.0im  1.0+0.0im   0.0+0.0im\n 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -1.0+0.0im\n 1.0+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im\n 0.0+0.0im  -1.0+0.0im  0.0+0.0im  -0.0+0.0im\n\n\n\n\n\n","category":"function"},{"location":"lib/QTBase/#QTBase.beta_2_temperature-Tuple{Any}","page":"Base","title":"QTBase.beta_2_temperature","text":"beta_2_temperature(β)\n\nConvert thermodynamic β in the unit of inverse angular frequency to physical temperature T in GHz.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.check_positivity-Union{Tuple{Array{T,2}}, Tuple{T}} where T<:Number","page":"Base","title":"QTBase.check_positivity","text":"check_positivity(m)\n\nCheck if matrix m is positive. Internally it compares the minimum eigen value of m to 0.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.check_unitary-Union{Tuple{Array{T,2}}, Tuple{T}} where T<:Number","page":"Base","title":"QTBase.check_unitary","text":"check_unitary(𝐔; rtol=1e-6, atol=1e-8)\n\nTest if 𝐔 is a unitary matrix. The function checks how close both 𝐔𝐔^ and 𝐔^𝐔 are to I, with relative and absolute error given by rtol, atol.\n\nExamples\n\njulia> check_unitary(exp(-1.0im*5*0.5*σx))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.collective_coupling-Tuple{Any,Any}","page":"Base","title":"QTBase.collective_coupling","text":"function collective_coupling(op, num_qubit; sp=false)\n\nCreate ConstantCouplings object with operator op on each qubits. op can be the string representation of one of the Pauli matrices. num_qubit is the total number of qubits. sp set whether to use sparse matrices. unit set the unit one – h or ħ.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.collective_operator-Tuple{Any,Any}","page":"Base","title":"QTBase.collective_operator","text":"collective_operator(op, num_qubit; sp=false)\n\nConstruct the collective operator for a system of num_qubit qubits. op is the name of the collective Pauli matrix. For example, the following code construct an IZ + ZI matrix. Generate sparse matrix when sp is set to true.\n\nExamples\n\njulia> collective_operator(\"z\", 2)\n4×4 Array{Complex{Float64},2}:\n 2.0+0.0im  0.0+0.0im  0.0+0.0im   0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im   0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im   0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  -2.0+0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.concatenate-Tuple","page":"Base","title":"QTBase.concatenate","text":"function concatenate(args...)\n\nConcatenate multiple ProjectedSystem objects into a single one. The arguments need to be in time order. The ref field of the new object will have the same value as the last input arguments.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.construct_hamming_weight_op-Tuple{Int64,String}","page":"Base","title":"QTBase.construct_hamming_weight_op","text":"construct_hamming_weight_op(num_qubit::Int64, op::String; sp=false)\n\nConstruct the Hamming weight operator for system of size num_qubit. The type of the Hamming weight operator is specified by op: \"x\", \"y\" or \"z\". Generate sparse matrix when sp is set to true.\n\nExamples\n\njulia> construct_hamming_weight_op(2,\"z\")\n4×4 Array{Complex{Float64},2}:\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  2.0+0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.cpvagk","page":"Base","title":"QTBase.cpvagk","text":"cpvagk(f, t, a, b, tol=256*eps())\n\nCalculate the Cauchy principle value integration of the form 𝒫_a^b f(x)(x-t) dx. The algorithm is adapted from P. Keller, 02.01.2015\n\n\n\n\n\n","category":"function"},{"location":"lib/QTBase/#QTBase.eigen_decomp-Tuple{AbstractDenseHamiltonian,Any}","page":"Base","title":"QTBase.eigen_decomp","text":"function eigen_decomp(h::AbstractDenseHamiltonian, t; level = 2) -> (w, v)\n\nCalculate the eigen value decomposition of the Hamiltonian h at time t. Keyword argument level specifies the number of levels to keep in the output. w is a vector of eigenvalues and v is a matrix of the eigenvectors in the columns. (The kth eigenvector can be obtained from the slice w[:, k].) w will be in unit of GHz.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.eigen_decomp-Tuple{AbstractSparseHamiltonian,Any}","page":"Base","title":"QTBase.eigen_decomp","text":"function eigen_decomp(h::AbstractSparseHamiltonian, t; level = 2) -> (w, v)\n\nCalculate the eigen value decomposition of the Hamiltonian h at time t. Keyword argument level specifies the number of levels to keep in the output. w is a vector of eigenvalues and v is a matrix of the eigenvectors in the columns. (The kth eigenvector can be obtained from the slice w[:, k].) w will be in unit of GHz. Arpack.jl is used internally for solving eigensystems of sparse matrices. Any keyword arguments of eigs function is supported here.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.eigen_sys-Tuple{Any,AbstractArray{Float64,1}}","page":"Base","title":"QTBase.eigen_sys","text":"eigen_sys(hfun, t; levels=2, tol=1e-4)\n\nCalculate the eigen values and eigen states of Hamiltonian hfun at each points of vector t. The output keeps the lowest levels eigenstates and their corresponding eigenvalues. tol specifies the error tolerance for sparse matrices decomposition. Output (vals, vecs) whose dimensions are (levels, tdim) and (hdim, levels, tdim) respectively.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.evaluate-Tuple{AbstractHamiltonian,Any}","page":"Base","title":"QTBase.evaluate","text":"evaluate(H::AbstractHamiltonian, s)\n\nEvaluate the time dependent Hamiltonian at time s with the unit of GHz\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.evaluate-Tuple{AdiabaticFrameHamiltonian,Any,Any}","page":"Base","title":"QTBase.evaluate","text":"function evaluate(H::AdiabaticFrameHamiltonian, s, tf)\n\nEvaluate the adiabatic frame Hamiltonian at (unitless) time s, with total annealing time tf (in the unit of ns). The final result is given in unit of GHz.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.freq_2_temperature-Tuple{Any}","page":"Base","title":"QTBase.freq_2_temperature","text":"freq_2_temperature(freq)\n\nConvert frequency in GHz to temperature in mK.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.get_dθ","page":"Base","title":"QTBase.get_dθ","text":"get_dθ(sys::ProjectedSystem, i=1, j=2)\n\nGet the geometric terms between i, j energy levels from ProjectedSystem.\n\n\n\n\n\n","category":"function"},{"location":"lib/QTBase/#QTBase.gibbs_state-Tuple{Any,Any}","page":"Base","title":"QTBase.gibbs_state","text":"gibbs_state(h, β)\n\nCalculate the Gibbs state of the matrix h at temperature T (mK).\n\nExamples\n\njulia> gibbs_state(σz, 10)\n2×2 Array{Complex{Float64},2}:\n 0.178338+0.0im       0.0+0.0im\n      0.0+0.0im  0.821662+0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.inst_population-Tuple{Any,Any,Any}","page":"Base","title":"QTBase.inst_population","text":"function inst_population(t, states, hamiltonian; level=1)\n\nFor a time series quantum states given by states, whose time points are given by t, calculate the population of instantaneous eigenstates of hamiltonian. The levels of the instantaneous eigenstates are specified by level, which can be any slice index.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.local_field_term-Tuple{Any,Any,Any}","page":"Base","title":"QTBase.local_field_term","text":"local_field_term(h, idx, num_qubit; sp=false)\n\nConstruct local Hamiltonian of the form hᵢσᵢᶻ. idx is the index of all local field terms and h is a list of the corresponding weights. num_qubit is the total number of qubits. Generate sparse matrix when sp is set to true.\n\nExamples\n\njulia> local_field_term([1.0, 0.5], [1, 2], 2) == σz⊗σi+0.5σi⊗σz\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.low_level_hamiltonian-Tuple{Any,Any}","page":"Base","title":"QTBase.low_level_hamiltonian","text":"low_level_hamiltonian(h, levels)\n\nCalculate the Hamiltonian h projected to lower energy subspace containing levels energy levels.\n\nExamples\n\njulia> low_level_hamiltonian(σx⊗σx, 2)\n4×4 Array{Complex{Float64},2}:\n -0.5+0.0im   0.0+0.0im   0.0+0.0im   0.5+0.0im\n  0.0+0.0im  -0.5+0.0im   0.5+0.0im   0.0+0.0im\n  0.0+0.0im   0.5+0.0im  -0.5+0.0im   0.0+0.0im\n  0.5+0.0im   0.0+0.0im   0.0+0.0im  -0.5+0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.matrix_decompose-Union{Tuple{T}, Tuple{Array{T,2},Array{Array{T,2},1}}} where T<:Number","page":"Base","title":"QTBase.matrix_decompose","text":"matrix_decompose(mat::Matrix{T}, basis::Array{Matrix{T},1})\n\nDecompse matrix mat onto matrix basis basis\n\nExamples\n\njulia> matrix_decompose(1.0*σx+2.0*σy+3.0*σz, [σx,σy,σz])\n3-element Array{Complex{Float64},1}:\n 1.0 + 0.0im\n 2.0 + 0.0im\n 3.0 + 0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.project_to_lowlevel-Union{Tuple{T}, Tuple{AbstractHamiltonian{T},Any,Any,AbstractArray{T,1}}} where T<:Real","page":"Base","title":"QTBase.project_to_lowlevel","text":"project_to_lowlevel(H::AbstractHamiltonian{T}, dH, coupling, s_axis; ref=zeros((0,2)), tol=1e-4, lvl=2)\n\nProject a Hamiltonian H to the lowest lvl level subspace. dH is the derivative of Hamiltonian and coupling is the system-bath interaction operator. They should be callable with a single argument – annealing parameter s. s_axis is the (unitless) times to calculate the projection.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.q_translate-Tuple{String}","page":"Base","title":"QTBase.q_translate","text":"q_translate(h::String)\n\nConvert a string h representing multi-qubits Pauli matrices summation into its numerical form.\n\nExamples\n\njulia> q_translate(\"X+2.0Z\")\n2×2 Array{Complex{Float64},2}:\n 2.0+0.0im   1.0+0.0im\n 1.0+0.0im  -2.0+0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.q_translate_state-Tuple{String}","page":"Base","title":"QTBase.q_translate_state","text":"q_translate_state(h::String; normal=false)\n\nConvert a string representation of quantum state to a vector. The keyword argument normal indicates whether to normalize the output vector. (Currently only '0' and '1' are supported)\n\nExamples\n\nSingle term:\n\njulia> q_translate_state(\"001\")\n8-element Array{Complex{Float64},1}:\n 0.0 + 0.0im\n 1.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n\nMultiple terms:\n\njulia> q_translate_state(\"(101)+(001)\", normal=true)\n8-element Array{Complex{Float64},1}:\n                0.0 + 0.0im\n 0.7071067811865475 + 0.0im\n                0.0 + 0.0im\n                0.0 + 0.0im\n                0.0 + 0.0im\n 0.7071067811865475 + 0.0im\n                0.0 + 0.0im\n                0.0 + 0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.single_clause-NTuple{4,Any}","page":"Base","title":"QTBase.single_clause","text":"single_clause(ops, q_ind, weight, num_qubit; sp=false)\n\nConstruct a single clause of the multi-qubits Hamiltonian. ops is a list of Pauli operator names which appears in this clause. q_ind is the list of indices corresponding to the Pauli matrices in ops. weight is the constant factor of this clause. num_qubit is the total number of qubits. A sparse matrix can be construct by setting sp to true. The following example construct a clause of Z_1 I Z_32.\n\nExamples\n\njulia> single_clause([\"z\", \"z\"], [1, 3], 0.5, 3)\n8×8 Array{Complex{Float64},2}:\n 0.5+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im\n 0.0+0.0im  -0.5+0.0im  0.0+0.0im  -0.0+0.0im   0.0+0.0im  -0.0+0.0im   0.0+0.0im  -0.0+0.0im\n 0.0+0.0im   0.0+0.0im  0.5+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im\n 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -0.5+0.0im   0.0+0.0im  -0.0+0.0im   0.0+0.0im  -0.0+0.0im\n 0.0+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im  -0.5+0.0im  -0.0+0.0im  -0.0+0.0im  -0.0+0.0im\n 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -0.0+0.0im  -0.0+0.0im   0.5-0.0im  -0.0+0.0im   0.0-0.0im\n 0.0+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im  -0.0+0.0im  -0.0+0.0im  -0.5+0.0im  -0.0+0.0im\n 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -0.0+0.0im  -0.0+0.0im   0.0-0.0im  -0.0+0.0im   0.5-0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.standard_driver-Tuple{Any}","page":"Base","title":"QTBase.standard_driver","text":"standard_driver(num_qubit; sp=false)\n\nConstruct the standard driver Hamiltonian for a system of num_qubit qubits. For example, a two qubits standard driver matrix is IX + XI. Generate sparse matrix when sp is set to true.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.temperature_2_beta-Tuple{Any}","page":"Base","title":"QTBase.temperature_2_beta","text":"temperature_2_beta(T)\n\nConvert physical temperature T in mK to thermodynamic β in the unit of inverse angular frequency, that is to say β = ħkT.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.temperature_2_freq-Tuple{Any}","page":"Base","title":"QTBase.temperature_2_freq","text":"temperature_2_freq(T)\n\nConvert temperature from mK to GHz.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.to_dense-Tuple{SparseHamiltonian}","page":"Base","title":"QTBase.to_dense","text":"function to_dense(H::SparseHamiltonian)\n\nConvert SparseHamiltonian to DenseHamiltonian.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.to_sparse-Tuple{DenseHamiltonian}","page":"Base","title":"QTBase.to_sparse","text":"function to_sparse(H::DenseHamiltonian)\n\nConvert DenseHamiltonian to SparseHamiltonian.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.two_local_term-Tuple{Any,Any,Any}","page":"Base","title":"QTBase.two_local_term","text":"two_local_term(j, idx, num_qubit; sp=false)\n\nConstruct local Hamiltonian of the form Jᵢⱼσᵢᶻσⱼᶻ. idx is the index of all two local terms and j is a list of the corresponding weights. num_qubit is the total number of qubits. Generate sparse matrix when sp is set to true.\n\nExamples\n\njulia> two_local_term([1.0, 0.5], [[1,2], [1,3]], 3) == σz⊗σz⊗σi + 0.5σz⊗σi⊗σz\ntrue\n\n\n\n\n\n","category":"method"},{"location":"tutorials/bath/#Bath-1","page":"Bath","title":"Bath","text":"","category":"section"},{"location":"tutorials/bath/#","page":"Bath","title":"Bath","text":"We start with a general form of system bath interaction Hamiltonian","category":"page"},{"location":"tutorials/bath/#","page":"Bath","title":"Bath","text":"  H_SB = sum_alpha S_alphaotimes B_alpha","category":"page"},{"location":"tutorials/bath/#","page":"Bath","title":"Bath","text":"and define each B_alpha (together with the bath Hamiltonian H_B) as an AbstractBath object. An important metric for any bath is its two point correlation function","category":"page"},{"location":"tutorials/bath/#","page":"Bath","title":"Bath","text":"  C(t_1 t_2) = langle mathcalB(t_1) mathcalB(t_2) rangle","category":"page"},{"location":"tutorials/bath/#","page":"Bath","title":"Bath","text":"where","category":"page"},{"location":"tutorials/bath/#","page":"Bath","title":"Bath","text":"  mathcalB(t) = U_B^dagger (t) B U_B(t)","category":"page"},{"location":"tutorials/bath/#","page":"Bath","title":"Bath","text":"and U_B(t) is the unitary generated by the pure bath Hamiltonian","category":"page"},{"location":"tutorials/bath/#","page":"Bath","title":"Bath","text":"  U_B(t) = mathcalTexpBig -iint_0^t H_B mathrmdtau Big","category":"page"},{"location":"tutorials/bath/#","page":"Bath","title":"Bath","text":"The spectrum density of the bath is defined as the Fourier transform of the correlation function and is usually denoted as S(omega). It is important to notice that, only for Gaussian bath(or bath which satisfies the Wick Theorem) does the correlation function uniquely determine the bath. Otherwise, high order correlation functions may be necessary. Nevertheless, it is still an area of active research on how to experimentally measure those high order correlation functions. So in most occasions, only two point correlation function is available to us and we treat the noise as Gaussian.","category":"page"},{"location":"tutorials/bath/#","page":"Bath","title":"Bath","text":"Currently, there are two build-in concrete types of the AbstractBath class – OhmicBath and HybridOhmicBath.","category":"page"},{"location":"tutorials/bath/#Ohmic-Bath-1","page":"Bath","title":"Ohmic Bath","text":"","category":"section"},{"location":"tutorials/bath/#","page":"Bath","title":"Bath","text":"A self-consistent reference for Ohmic bath is Albash, Tameem, et al. We can use Ohmic function to construct OhmicBath object","category":"page"},{"location":"tutorials/bath/#","page":"Bath","title":"Bath","text":"η = 1e-4; fc=4; T=16\nbath = Ohmic(η, fc, T);","category":"page"},{"location":"tutorials/bath/#Hybrid-Ohmic-Bath-1","page":"Bath","title":"Hybrid Ohmic Bath","text":"","category":"section"},{"location":"tutorials/bath/#","page":"Bath","title":"Bath","text":"A good reference paper for the hybrid ohmic bath model is Lanting et al. The model is generalized in Smirnov and Amin. The basic idea is, the noise spectrum of this bath model can be split into the low frequency and high frequency parts","category":"page"},{"location":"tutorials/bath/#","page":"Bath","title":"Bath","text":"  S(omega) = S^L(ω) + S^H(ω)","category":"page"},{"location":"tutorials/bath/#","page":"Bath","title":"Bath","text":"The high frequency part of the bath is the Ohmic and the low frequency part can be something like the 1f noise. The benefit of this formalism is that, instead of the entire spectrum density, S^L(omega) can be parametrized by a single parameter in the macroscopic resonant tunneling(MRT) experiment.","category":"page"},{"location":"#HOME-1","page":"Home","title":"HOME","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This is a quantum annealing toolbox for Julia programming language.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This package is written in Julia programming language. To learn more about Julia, please check its excellent doc pages. If you want to learn more about quantum annealing/adiabatic quantum computing, this review paper is a good place to start.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This package has a core component package QTBase.jl, both of which are currently unregistered. To install, just run the following command inside the Julia REPL:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using Pkg\nPkg.add(PackageSpec(url=\"https://github.com/USCqserver/QTBase.jl\", rev=\"master\"))\nPkg.add(PackageSpec(url=\"https://github.com/USCqserver/QuantumAnnealingTools.jl\", rev=\"master\"))","category":"page"},{"location":"#","page":"Home","title":"Home","text":"It will install the packages directly from their github repos.","category":"page"},{"location":"#Quick-Start-1","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"In the first example, we solve a standard single qubit annealing problem with Hamiltonian","category":"page"},{"location":"#","page":"Home","title":"Home","text":"    H(s) = A(s)σx + B(s)σz","category":"page"},{"location":"#","page":"Home","title":"Home","text":"where A(s)=1-s and B(s)=s are usually known as annealing schedules. The general workflow is to define the Hamiltonian, construct the annealing process and then solve the system dynamics. The full code for this example is","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using QuantumAnnealingTools\nusing DifferentialEquations\ntf = 20\nu0 = PauliVec[1][2]\nH = DenseHamiltonian([(s)->1-s, (s)->s], [σx, σz], unit=:ħ)\nannealing = Annealing(H, u0)\nsol = solve_schrodinger(annealing, tf)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"where the pieces are explained below.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"First, we need to load the package DifferentialEquations.jl for ODE solvers. Then we define the Hamiltonian of the annealing process. In this package, a time dependent Hamiltonian can be specified by a list of time dependent functions and a list of constant matrices","category":"page"},{"location":"#","page":"Home","title":"Home","text":"H = DenseHamiltonian([(s)->1-s, (s)->s], [σx, σz], unit=:ħ)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The resulting Hamiltonian is an affine combination of the corresponding functions and matrices (1-s)σx + sσ_z. Then we define the initial state u0. Together with Hamiltonian, an annealing object can be constructed","category":"page"},{"location":"#","page":"Home","title":"Home","text":"annealing = Annealing(H, u0)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The final step is to solve system dynamics. In this example, directly solve the Schrodinger equation for a total annealing time tf.","category":"page"},{"location":"#Tutorials-1","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The following tutorials will introduce you to the functionality of QuantumAnnealingTools.jl.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\n    \"tutorials/math_symbol.md\",\n    \"tutorials/hamiltonians.md\",\n    \"tutorials/couplings.md\",\n    \"tutorials/bath.md\",\n    \"tutorials/annealing.md\"\n    ]\nDepth = 1","category":"page"},{"location":"lib/bath/#Bath-Module-1","page":"Bath","title":"Bath Module","text":"","category":"section"},{"location":"lib/bath/#Ohmic-Bath-Object-1","page":"Bath","title":"Ohmic Bath Object","text":"","category":"section"},{"location":"lib/bath/#","page":"Bath","title":"Bath","text":"OhmicBath\nOhmic(η, fc, T)\ncorrelation(τ, params::OhmicBath)\npolaron_correlation(τ, params::OhmicBath)\nγ(w, params::OhmicBath)\nS(w, params::OhmicBath; atol=1e-7)\ninterpolate_spectral_density(ω_grid::AbstractRange{T}, params::OhmicBath) where T<:Number","category":"page"},{"location":"lib/bath/#QuantumAnnealingTools.OhmicBath","page":"Bath","title":"QuantumAnnealingTools.OhmicBath","text":"OhmicBath\n\nOhmic bath object to hold a particular parameter set.\n\nFields\n\nη – strength.\nωc – cutoff frequence.\nβ – inverse temperature.\n\n\n\n\n\n","category":"type"},{"location":"lib/bath/#QuantumAnnealingTools.Ohmic-Tuple{Any,Any,Any}","page":"Bath","title":"QuantumAnnealingTools.Ohmic","text":"Ohmic(η, fc, T)\n\nConstruct OhmicBath from parameters with physical unit: η–unitless interaction strength; fc–cutoff frequency in GHz; T–temperature in mK.\n\n\n\n\n\n","category":"method"},{"location":"lib/bath/#QuantumAnnealingTools.correlation-Tuple{Any,OhmicBath}","page":"Bath","title":"QuantumAnnealingTools.correlation","text":"correlation(τ, params::OhmicBath)\n\nCalculate the correlation function of Ohmic bath.\n\n\n\n\n\n","category":"method"},{"location":"lib/bath/#QuantumAnnealingTools.γ-Tuple{Any,OhmicBath}","page":"Bath","title":"QuantumAnnealingTools.γ","text":"γ(ω, params::OhmicBath)\n\nCalculate Ohmic spectrum density, defined as a full Fourier transform on the bath correlation function.\n\n\n\n\n\n","category":"method"},{"location":"lib/bath/#QuantumAnnealingTools.S-Tuple{Any,OhmicBath}","page":"Bath","title":"QuantumAnnealingTools.S","text":"S(w, params::OhmicBath; atol=1e-7)\n\nCalculate the Lamb shift of Ohmic spectrum. atol is the absolute tolerance for Cauchy principal value integral.\n\n\n\n\n\n","category":"method"},{"location":"lib/bath/#QuantumAnnealingTools.interpolate_spectral_density-Union{Tuple{T}, Tuple{AbstractRange{T},OhmicBath}} where T<:Number","page":"Bath","title":"QuantumAnnealingTools.interpolate_spectral_density","text":"interpolate_spectral_density(ω_grid::AbstractRange{T}, params::OhmicBath) where T<:Number\n\nCalculate the Ohmic bath spectral density S on grid ω_grid, and construct interpolation objects for it. A separate function for γ is also returned without doing interpolation.\n\n\n\n\n\n","category":"method"},{"location":"lib/bath/#Hybrid-Ohmic-Bath-1","page":"Bath","title":"Hybrid Ohmic Bath","text":"","category":"section"},{"location":"lib/bath/#","page":"Bath","title":"Bath","text":"HybridOhmicBath\nHybridOhmic(W, η, fc, T)\npolaron_correlation(τ, bath::HybridOhmicBath, a=1)\nGₕ(ω, bath::HybridOhmicBath, a=1)\nGₗ(ω, bath::HybridOhmicBath, a=1)","category":"page"},{"location":"lib/bath/#QuantumAnnealingTools.HybridOhmicBath","page":"Bath","title":"QuantumAnnealingTools.HybridOhmicBath","text":"struct HybridOhmicBath\n\nA hybrid noise model with both low and high frequency noise. The high frequency noise is characterized by Ohmic bath and the low frequence noise is characterized by the MRT width W.\n\nW\nMRT width (2π GHz)\nϵl\nlow spectrum reorganization energy (2π GHz)\nϵ\ntotal reorganization energy (2π GHz)\nη\nstrength of high frequency Ohmic bath\nωc\ncutoff frequency\nβ\ninverse temperature\nwidth_h\nhalf width at half maximum for high frequency Ohmic bath\nwidth_l\nhalf width at half maximum for low frequency bath\n\n\n\n\n\n","category":"type"},{"location":"lib/bath/#QuantumAnnealingTools.HybridOhmic-NTuple{4,Any}","page":"Bath","title":"QuantumAnnealingTools.HybridOhmic","text":"HybridOhmic(W, η, fc, T)\n\nConstruct HybridOhmicBath object with parameters in physical units. W: MRT width (mK); η: interaction strength (unitless); fc: Ohmic cutoff frequency (GHz); T: temperature (mK).\n\n\n\n\n\n","category":"method"},{"location":"lib/bath/#QuantumAnnealingTools.polaron_correlation","page":"Bath","title":"QuantumAnnealingTools.polaron_correlation","text":"polaron_correlation(τ, bath::HybridOhmicBath, a=1)\n\nCalculate polaron transformed correlation function of HybridOhmicBath 'bath' at time 'τ' with relative strength a. The effective strength will be a * W^2 and a * η.\n\n\n\n\n\n","category":"function"},{"location":"lib/bath/#QuantumAnnealingTools.Gₕ","page":"Bath","title":"QuantumAnnealingTools.Gₕ","text":"Gₕ(ω, bath::HybridOhmicBath, a=1)\n\nHigh frequency noise spectrum of the HybridOhmicBath bath with relative strength a.\n\n\n\n\n\n","category":"function"},{"location":"lib/bath/#QuantumAnnealingTools.Gₗ","page":"Bath","title":"QuantumAnnealingTools.Gₗ","text":"Gₗ(ω, bath::HybridOhmicBath, a=1)\n\nLow frequency noise specturm of the HybridOhmicBath bath with relative strength a.\n\n\n\n\n\n","category":"function"}]
}
