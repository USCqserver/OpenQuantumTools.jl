var documenterSearchIndex = {"docs":
[{"location":"#HOME-1","page":"Home","title":"HOME","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This is a quantum annealing toolbox for Julia programming language.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This package has the following features","category":"page"},{"location":"#Math-Symbols-1","page":"Home","title":"Math Symbols","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The package defines some commonly used mathematical symbols and operators. Some of its features include:","category":"page"},{"location":"#Pauli-Matrices-1","page":"Home","title":"Pauli Matrices","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Single qubit Pauli matrices are defined by Ïƒx, Ïƒy, Ïƒz and Ïƒi. One can simply calculate the tensor product of single qubits Pauli matrices by","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> ÏƒxâŠ—Ïƒz\n4Ã—4 Array{Complex{Float64},2}:\n 0.0+0.0im   0.0+0.0im  1.0+0.0im   0.0+0.0im\n 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -1.0+0.0im\n 1.0+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im\n 0.0+0.0im  -1.0+0.0im  0.0+0.0im  -0.0+0.0im","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The eigenvectors of each Pauli matrices are also defined in constant PauliVec, where PauliVec[1],PauliVec[2],PauliVec[3] corresponds to eigenvectors of Ïƒx, Ïƒy, Ïƒz. Additionally, the first eigenvector is the one with positive eigenvalue","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> Ïƒz*PauliVec[3][1] == PauliVec[3][1]\ntrue","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Additionally, a sparse version of Pauli matrices are defined in spÏƒx et al. They can be used to construct Hamiltonian in the form of sparse matrix.","category":"page"},{"location":"#Construction-of-Multi-Qubits-Matrices-1","page":"Home","title":"Construction of Multi-Qubits Matrices","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The package provides various utility functions to construct multi-qubits matrices. For all the functions listed below, keyword argument sp can be set to generate sparse matrices.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The standard driver Hamiltonian in quantum annealing can be constructed with standard_driver","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> standard_driver(2) == ÏƒxâŠ—Ïƒi + ÏƒiâŠ—Ïƒx\ntrue","category":"page"},{"location":"#","page":"Home","title":"Home","text":"and for sparse matrices","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> standard_driver(2, sp=true) == spÏƒxâŠ—spÏƒi + spÏƒiâŠ—spÏƒx\ntrue","category":"page"},{"location":"#","page":"Home","title":"Home","text":"A multi-qubits matrix can be constructed from its string representation using q_translate function.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> q_translate(\"ZZ+0.5ZI-XZ\")\n4Ã—4 Array{Complex{Float64},2}:\n  1.5+0.0im   0.0+0.0im  -1.0+0.0im   0.0+0.0im\n  0.0+0.0im  -0.5+0.0im   0.0+0.0im   1.0+0.0im\n -1.0+0.0im   0.0+0.0im  -1.5+0.0im  -0.0+0.0im\n  0.0+0.0im   1.0+0.0im  -0.0+0.0im   0.5+0.0im","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Collective operators(same Pauli operator acting on each individual qubit) can be constructed with collective_operator","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> collective_operator(\"z\", 3) == ÏƒzâŠ—ÏƒiâŠ—Ïƒi + ÏƒiâŠ—ÏƒzâŠ—Ïƒi + ÏƒiâŠ—ÏƒiâŠ—Ïƒz\ntrue","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Single clause in multi-qubits Hamiltonian can be constructed by","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> single_clause([\"z\",\"z\"], [2,3], -2, 4) == -2ÏƒiâŠ—ÏƒzâŠ—ÏƒzâŠ—Ïƒi\ntrue","category":"page"},{"location":"#Hamiltonians-1","page":"Home","title":"Hamiltonians","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The Hamiltonian object implements AffineDiffEqOperator interface. It can be constructed from a unified hamiltonian_factory interface. For example","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> H = hamiltonian_factory([(s)->1-s, (s)->s], [Ïƒx, Ïƒz])","category":"page"},{"location":"#","page":"Home","title":"Home","text":"create a standard single qubit annealing Hamiltonian of the form H(s)=(1-s)Ïƒ_x+sÏƒ_z. The value of the Hamiltonian at time can be obtained by","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> H(0.5)\n2Ã—2 Array{Complex{Float64},2}:\n 0.5+0.0im   0.5+0.0im\n 0.5+0.0im  -0.5+0.0im","category":"page"},{"location":"#Adiabatic-Master-Equation-1","page":"Home","title":"Adiabatic Master Equation","text":"","category":"section"},{"location":"#Hamiltonian-1","page":"Home","title":"Hamiltonian","text":"","category":"section"},{"location":"lib/QTBase/#","page":"Base","title":"Base","text":"Modules = [QTBase]\nPrivate = false","category":"page"},{"location":"lib/QTBase/#QTBase.PauliVec","page":"Base","title":"QTBase.PauliVec","text":"PauliVec\n\nConstants for the eigenvectors of single qubit Pauli matrices. Indices 1, 2 and 3 corresponds to the eigenvectors of Ïƒ_x, Ïƒ_y and Ïƒ_z.\n\nExamples\n\njulia> Ïƒx*PauliVec[1][1] == PauliVec[1][1]\ntrue\n\n\n\n\n\n","category":"constant"},{"location":"lib/QTBase/#QTBase.:âŠ—","page":"Base","title":"QTBase.:âŠ—","text":"âŠ—(A, B)\n\nCalculate the tensor product of A and B.\n\nExamples\n\njulia> ÏƒxâŠ—Ïƒz\n4Ã—4 Array{Complex{Float64},2}:\n 0.0+0.0im   0.0+0.0im  1.0+0.0im   0.0+0.0im\n 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -1.0+0.0im\n 1.0+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im\n 0.0+0.0im  -1.0+0.0im  0.0+0.0im  -0.0+0.0im\n\n\n\n\n\n","category":"function"},{"location":"lib/QTBase/#QTBase.beta_2_temperature-Tuple{Any}","page":"Base","title":"QTBase.beta_2_temperature","text":"beta_2_temperature(Î²)\n\nConvert inverse temperature Î² in Ä§ to physical temperature T in GHz.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.calculate_unitary-Tuple{Any,Any}","page":"Base","title":"QTBase.calculate_unitary","text":"calculate_unitary(H, tf; rtol=1e-6, atol=1e-8)\n\nCalculate the unitary operator generated by Hamiltonian H. H is a callable object whose only argument is unitless time s = t  t_f.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.check_positivity-Union{Tuple{Array{T,2}}, Tuple{T}} where T<:Number","page":"Base","title":"QTBase.check_positivity","text":"check_positivity(m)\n\nCheck if matrix m is positive. Internally it compares the minimum eigen value of m to 0.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.check_unitary-Union{Tuple{Array{T,2}}, Tuple{T}} where T<:Number","page":"Base","title":"QTBase.check_unitary","text":"check_unitary(ð”; rtol=1e-6, atol=1e-8)\n\nTest if ð” is a unitary matrix. The function checks how close both ð”ð”^ and ð”^ð” are to I, with relative and absolute error given by rtol, atol.\n\nExamples\n\njulia> check_unitary(exp(-1.0im*5*0.5*Ïƒx))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.collective_operator-Tuple{Any,Any}","page":"Base","title":"QTBase.collective_operator","text":"collective_operator(op, num_qubit; sp=false)\n\nConstruct the collective operator for a system of num_qubit qubits. op is the name of the collective Pauli matrix. For example, the following code construct an IZ + ZI matrix. Generate sparse matrix when sp is set to true.\n\nExamples\n\njulia> collective_operator(\"z\", 2)\n4Ã—4 Array{Complex{Float64},2}:\n 2.0+0.0im  0.0+0.0im  0.0+0.0im   0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im   0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im   0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  -2.0+0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.construct_hamming_weight_op-Tuple{Int64,String}","page":"Base","title":"QTBase.construct_hamming_weight_op","text":"construct_hamming_weight_op(num_qubit::Int64, op::String; sp=false)\n\nConstruct the Hamming weight operator for system of size num_qubit. The type of the Hamming weight operator is specified by op: \"x\", \"y\" or \"z\". Generate sparse matrix when sp is set to true.\n\nExamples\n\njulia> construct_hamming_weight_op(2,\"z\")\n4Ã—4 Array{Complex{Float64},2}:\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  2.0+0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.cpvagk","page":"Base","title":"QTBase.cpvagk","text":"cpvagk(f, t, a, b, tol=256*eps())\n\nCalculate the Cauchy principle value integration of the form ð’«_a^b f(x)(x-t) dx. The algorithm is adapted from P. Keller, 02.01.2015\n\n\n\n\n\n","category":"function"},{"location":"lib/QTBase/#QTBase.eigen_eval-Tuple{Any,AbstractArray{Float64,1}}","page":"Base","title":"QTBase.eigen_eval","text":"eigen_eval(hfun, t; levels=2, tol=1e-4)\n\nCalculate the eigen values and eigen states of Hamiltonian hfun at each points of t. The output keeps the lowest levels eigenstates and their corresponding eigenvalues. tol specifies the error tolerance for sparse matrices decomposition.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.freq_2_temperature-Tuple{Any}","page":"Base","title":"QTBase.freq_2_temperature","text":"freq_2_temperature(freq)\n\nConvert frequency in GHz to temperature in mK.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.gibbs_state-Tuple{Any,Any}","page":"Base","title":"QTBase.gibbs_state","text":"gibbs_state(h, Î²)\n\nCalculate the Gibbs state of the matrix h at temperature T (mK).\n\nExamples\n\njulia> gibbs_state(Ïƒz, 10)\n2Ã—2 Array{Complex{Float64},2}:\n 0.178338+0.0im       0.0+0.0im\n      0.0+0.0im  0.821662+0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.inst_population-Tuple{Any,Any,Any}","page":"Base","title":"QTBase.inst_population","text":"function inst_population(t, states, hamiltonian; level=1)\n\nFor a time series quantum states given by states, whose time points are given by t, calculate the population of instantaneous eigenstates of hamiltonian. The levels of the instantaneous eigenstates are specified by level, which can be any slice index.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.low_level_hamiltonian-Tuple{Any,Any}","page":"Base","title":"QTBase.low_level_hamiltonian","text":"low_level_hamiltonian(h, levels)\n\nCalculate the Hamiltonian h projected to lower energy subspace containing levels energy levels.\n\nExamples\n\njulia> low_level_hamiltonian(ÏƒxâŠ—Ïƒx, 2)\n4Ã—4 Array{Complex{Float64},2}:\n -0.5+0.0im   0.0+0.0im   0.0+0.0im   0.5+0.0im\n  0.0+0.0im  -0.5+0.0im   0.5+0.0im   0.0+0.0im\n  0.0+0.0im   0.5+0.0im  -0.5+0.0im   0.0+0.0im\n  0.5+0.0im   0.0+0.0im   0.0+0.0im  -0.5+0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.matrix_decompose-Union{Tuple{T}, Tuple{Array{T,2},Array{Array{T,2},1}}} where T<:Number","page":"Base","title":"QTBase.matrix_decompose","text":"matrix_decompose(mat::Matrix{T}, basis::Array{Matrix{T},1})\n\nDecompse matrix mat onto matrix basis basis\n\nExamples\n\njulia> matrix_decompose(1.0*Ïƒx+2.0*Ïƒy+3.0*Ïƒz, [Ïƒx,Ïƒy,Ïƒz])\n3-element Array{Complex{Float64},1}:\n 1.0 + 0.0im\n 2.0 + 0.0im\n 3.0 + 0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.minimum_gap-Tuple{Any}","page":"Base","title":"QTBase.minimum_gap","text":"minimum_gap(h)\n\nCalculate the minimum gap of Hamiltonian h using Optim.jl package.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.q_translate-Tuple{String}","page":"Base","title":"QTBase.q_translate","text":"q_translate(h::String)\n\nConvert a string h representing multi-qubits Pauli matrices summation into its numerical form.\n\nExamples\n\njulia> q_translate(\"X+2.0Z\")\n2Ã—2 Array{Complex{Float64},2}:\n 2.0+0.0im   1.0+0.0im\n 1.0+0.0im  -2.0+0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.single_clause-NTuple{4,Any}","page":"Base","title":"QTBase.single_clause","text":"single_clause(ops, q_ind, weight, num_qubit; sp=false)\n\nConstruct a single clause of the multi-qubits Hamiltonian. ops is a list of Pauli operator names which appears in this clause. q_ind is the list of indices corresponding to the Pauli matrices in ops. weight is the constant factor of this clause. num_qubit is the total number of qubits. A sparse matrix can be construct by setting sp to true. The following example construct a clause of Z_1 I Z_32.\n\nExamples\n\njulia> single_clause([\"z\", \"z\"], [1, 3], 0.5, 3)\n8Ã—8 Array{Complex{Float64},2}:\n 0.5+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im\n 0.0+0.0im  -0.5+0.0im  0.0+0.0im  -0.0+0.0im   0.0+0.0im  -0.0+0.0im   0.0+0.0im  -0.0+0.0im\n 0.0+0.0im   0.0+0.0im  0.5+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im\n 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -0.5+0.0im   0.0+0.0im  -0.0+0.0im   0.0+0.0im  -0.0+0.0im\n 0.0+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im  -0.5+0.0im  -0.0+0.0im  -0.0+0.0im  -0.0+0.0im\n 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -0.0+0.0im  -0.0+0.0im   0.5-0.0im  -0.0+0.0im   0.0-0.0im\n 0.0+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im  -0.0+0.0im  -0.0+0.0im  -0.5+0.0im  -0.0+0.0im\n 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -0.0+0.0im  -0.0+0.0im   0.0-0.0im  -0.0+0.0im   0.5-0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.standard_driver-Tuple{Any}","page":"Base","title":"QTBase.standard_driver","text":"standard_driver(num_qubit; sp=false)\n\nConstruct the standard driver Hamiltonian for a system of num_qubit qubits. For example, a two qubits standard driver matrix is IX + XI. Generate sparse matrix when sp is set to true.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.temperature_2_beta-Tuple{Any}","page":"Base","title":"QTBase.temperature_2_beta","text":"temperature_2_beta(T; unit=:Ä§)\n\nConvert physical temperature T in mK to inverse temperature Î² in unit.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.temperature_2_freq-Tuple{Any}","page":"Base","title":"QTBase.temperature_2_freq","text":"temperature_2_freq(T)\n\nConvert temperature from mK to GHz.\n\n\n\n\n\n","category":"method"},{"location":"lib/Proj/#Projection-Tools-1","page":"Projection","title":"Projection Tools","text":"","category":"section"},{"location":"lib/Proj/#","page":"Projection","title":"Projection","text":"LowLevelSystem\nget_dÎ¸(sys::LowLevelSystem, i=1, j=2)\nRotatedTwoLevelSystem\nproj_low_lvl(hfun, dhfun, interaction, s_axis::AbstractArray{T, 1}; ref=nothing, tol=1e-4, lvl=2) where T<:Number","category":"page"},{"location":"lib/Proj/#QuantumAnnealingTools.LowLevelSystem","page":"Projection","title":"QuantumAnnealingTools.LowLevelSystem","text":"LowLevelSystem\n\nObject for a projected low level system. The projection is only valid for real Hamiltonians.\n\nFields\n\ns â€“ unitless time grid.\nev â€“ energy values for different levels.\ndÎ¸ â€“ geometric terms.\nop â€“ projected system bath interaction operators\nref â€“ energy eigenstates at the final time\nlvl â€“ number of levels being kept.\n\n\n\n\n\n","category":"type"},{"location":"lib/Proj/#QuantumAnnealingTools.get_dÎ¸","page":"Projection","title":"QuantumAnnealingTools.get_dÎ¸","text":"get_dÎ¸(sys::LowLevelSystem, i=1, j=2)\n\nGet the geometric terms between i, j energy levels from LowLevelSystem.\n\n\n\n\n\n","category":"function"},{"location":"lib/Proj/#QuantumAnnealingTools.RotatedTwoLevelSystem","page":"Projection","title":"QuantumAnnealingTools.RotatedTwoLevelSystem","text":"RotatedTwoLevelSystem\n\nObject for a rotated two level system.\n\nFields\n\ns â€“ unitless time grid.\nÏ‰ â€“ Ï‰â‚â‚‚.\nT â€“ off diagonal element of the Hamiltonian.\nG â€“ geometric term.\na, b, c, d â€“ projected system bath parameters\nÎ¸ â€“ rotation angle\n\n\n\n\n\n","category":"type"},{"location":"lib/Proj/#QuantumAnnealingTools.proj_low_lvl-Union{Tuple{T}, Tuple{Any,Any,Any,AbstractArray{T,1}}} where T<:Number","page":"Projection","title":"QuantumAnnealingTools.proj_low_lvl","text":"proj_low_lvl(hfun, dhfun, interaction, s_axis::AbstractArray{T, 1}; ref=nothing, tol=1e-4, lvl=2) where T<:Number\n\nProject a multi-level quantum system to the lowest lvl levels. hfun and dhfun are the Hamiltonian and its derivative. interaction is a list of system bath interaction operators. s_axis is the grid for the computation. ref is the reference for the initial eigenstates. tol specify the error tolerance for eigen-decomposition if sparse matrix is used.\n\n\n\n\n\n","category":"method"},{"location":"lib/bath/#Bath-Module-1","page":"Bath","title":"Bath Module","text":"","category":"section"},{"location":"lib/bath/#Ohmic-Bath-Object-1","page":"Bath","title":"Ohmic Bath Object","text":"","category":"section"},{"location":"lib/bath/#","page":"Bath","title":"Bath","text":"OhmicBath\nOhmic(Î·, fc, T)\ncorrelation(Ï„, params::OhmicBath)\npolaron_correlation(Ï„, params::OhmicBath)\nÎ³(w, params::OhmicBath)\nS(w, params::OhmicBath; atol=1e-7)\ninterpolate_spectral_density(Ï‰_grid::AbstractRange{T}, params::OhmicBath) where T<:Number","category":"page"},{"location":"lib/bath/#QuantumAnnealingTools.OhmicBath","page":"Bath","title":"QuantumAnnealingTools.OhmicBath","text":"OhmicBath\n\nOhmic bath object to hold a particular parameter set.\n\nFields\n\nÎ· â€“ strength.\nÏ‰c â€“ cutoff frequence.\nÎ² â€“ inverse temperature.\n\n\n\n\n\n","category":"type"},{"location":"lib/bath/#QuantumAnnealingTools.Ohmic-Tuple{Any,Any,Any}","page":"Bath","title":"QuantumAnnealingTools.Ohmic","text":"Ohmic(Î·, fc, T)\n\nConstruct OhmicBath from parameters with physical unit: Î·â€“unitless interaction strength; fcâ€“cutoff frequency in GHz; Tâ€“temperature in mK.\n\n\n\n\n\n","category":"method"},{"location":"lib/bath/#QuantumAnnealingTools.correlation-Tuple{Any,OhmicBath}","page":"Bath","title":"QuantumAnnealingTools.correlation","text":"correlation(Ï„, params::OhmicBath)\n\nCalculate the correlation function of Ohmic bath.\n\n\n\n\n\n","category":"method"},{"location":"lib/bath/#QuantumAnnealingTools.polaron_correlation-Tuple{Any,OhmicBath}","page":"Bath","title":"QuantumAnnealingTools.polaron_correlation","text":"polaron_correlation(Ï„, params::OhmicBath)\n\nCalculate the polaron transformed correlation function of Ohmic bath.\n\n\n\n\n\n","category":"method"},{"location":"lib/bath/#QuantumAnnealingTools.Î³-Tuple{Any,OhmicBath}","page":"Bath","title":"QuantumAnnealingTools.Î³","text":"Î³(Ï‰, params::OhmicBath)\n\nCalculate Ohmic spectrum density, defined as a full Fourier transform on the bath correlation function.\n\n\n\n\n\n","category":"method"},{"location":"lib/bath/#QuantumAnnealingTools.S-Tuple{Any,OhmicBath}","page":"Bath","title":"QuantumAnnealingTools.S","text":"S(w, params::OhmicBath; atol=1e-7)\n\nCalculate the Lamb shift of Ohmic spectrum. atol is the absolute tolerance for Cauchy principal value integral.\n\n\n\n\n\n","category":"method"},{"location":"lib/bath/#QuantumAnnealingTools.interpolate_spectral_density-Union{Tuple{T}, Tuple{AbstractRange{T},OhmicBath}} where T<:Number","page":"Bath","title":"QuantumAnnealingTools.interpolate_spectral_density","text":"interpolate_spectral_density(Ï‰_grid::AbstractRange{T}, params::OhmicBath) where T<:Number\n\nCalculate the Ohmic bath spectral density S on grid Ï‰_grid, and construct interpolation objects for it. A separate function for Î³ is also returned without doing interpolation.\n\n\n\n\n\n","category":"method"},{"location":"lib/bath/#Hybrid-Ohmic-Bath-1","page":"Bath","title":"Hybrid Ohmic Bath","text":"","category":"section"},{"location":"lib/bath/#","page":"Bath","title":"Bath","text":"HybridOhmicBath\nHybridOhmic(W, Î·, fc, T)\npolaron_correlation(Ï„, bath::HybridOhmicBath, a=1)\nGâ‚•(Ï‰, bath::HybridOhmicBath, a=1)\nGâ‚—(Ï‰, bath::HybridOhmicBath, a=1)","category":"page"},{"location":"lib/bath/#QuantumAnnealingTools.HybridOhmicBath","page":"Bath","title":"QuantumAnnealingTools.HybridOhmicBath","text":"HybridOhmicBath\n\nA hybrid noise model with both low and high frequency noise. The high frequency noise is characterized by Ohmic bath and the low frequence noise is characterized by the MRT width W.\n\nFields\n\nW â€“ MRT width (2Ï€ GHz)\nÏµl â€“ low spectrum reorganization energy (2Ï€ GHz)\nÏµ â€“ total reorganization energy (2Ï€ GHz)\nÎ· â€“ strength of high frequency Ohmic bath\nÏ‰c â€“ cutoff frequence\nÎ² â€“ inverse temperature\nwidth_h â€“ half width at half maximum for high frequency Ohmic bath\nwidth_l â€“ half width at half maximu for low frequency slow bath\n\n\n\n\n\n","category":"type"},{"location":"lib/bath/#QuantumAnnealingTools.HybridOhmic-NTuple{4,Any}","page":"Bath","title":"QuantumAnnealingTools.HybridOhmic","text":"HybridOhmic(W, Î·, fc, T)\n\nConstruct HybridOhmicBath object with parameters in physical units. W: MRT width (mK); Î·: interaction strength (unitless); fc: Ohmic cutoff frequency (GHz); T: temperature (mK).\n\n\n\n\n\n","category":"method"},{"location":"lib/bath/#QuantumAnnealingTools.polaron_correlation","page":"Bath","title":"QuantumAnnealingTools.polaron_correlation","text":"polaron_correlation(Ï„, bath::HybridOhmicBath, a=1)\n\nCalculate polaron transformed correlation function of HybridOhmicBath 'bath' at time 'Ï„' with relative strength a. The effective strength will be a * W^2 and a * Î·.\n\n\n\n\n\n","category":"function"},{"location":"lib/bath/#QuantumAnnealingTools.Gâ‚•","page":"Bath","title":"QuantumAnnealingTools.Gâ‚•","text":"Gâ‚•(Ï‰, bath::HybridOhmicBath, a=1)\n\nHigh frequency noise spectrum of the HybridOhmicBath bath with relative strength a.\n\n\n\n\n\n","category":"function"},{"location":"lib/bath/#QuantumAnnealingTools.Gâ‚—","page":"Bath","title":"QuantumAnnealingTools.Gâ‚—","text":"Gâ‚—(Ï‰, bath::HybridOhmicBath, a=1)\n\nLow frequency noise specturm of the HybridOhmicBath bath with relative strength a.\n\n\n\n\n\n","category":"function"}]
}
