var documenterSearchIndex = {"docs":
[{"location":"tutorials/couplings/#Couplings","page":"Coupling","title":"Couplings","text":"","category":"section"},{"location":"tutorials/couplings/","page":"Coupling","title":"Coupling","text":"We start with a general form of system bath interaction Hamiltonian","category":"page"},{"location":"tutorials/couplings/","page":"Coupling","title":"Coupling","text":"  H_SB = sum_alpha S_alphaotimes B_alpha","category":"page"},{"location":"tutorials/couplings/","page":"Coupling","title":"Coupling","text":"and define the set of S_alpha_alpha whose corresponding B_α_alpha are independent and identical(IID) as AbstractCouplings objects. Mathematically, every element in the same AbstractCouplings object shares the same bath correlation function. (For operators which couple to the same bath, they can be added together.) Two concrete types of AbstractCouplings are implemented – ConstantCouplings and TimeDependentCouplings. The former represents time-independent operators. For example, the following codes","category":"page"},{"location":"tutorials/couplings/","page":"Coupling","title":"Coupling","text":"julia> coupling = ConstantCouplings([\"ZI\", \"IZ\"])","category":"page"},{"location":"tutorials/couplings/","page":"Coupling","title":"Coupling","text":"creates a set of two constant operators: ZI and IZ. The corresponding interaction Hamiltonian is","category":"page"},{"location":"tutorials/couplings/","page":"Coupling","title":"Coupling","text":"  H_SB = ZIB_1 + IZB_2","category":"page"},{"location":"tutorials/couplings/","page":"Coupling","title":"Coupling","text":"where B_1 and B_2 are IID. On the other hand, TimeDependentCouplings can be constructed with a two-step procedure. First, single TimeDependentCoupling needs to be constructed","category":"page"},{"location":"tutorials/couplings/","page":"Coupling","title":"Coupling","text":"c1 = TimeDependentCoupling([(s)->cos(s)], [σx]; unit=:ħ)\nc2 = TimeDependentCoupling([(s)->sin(s)], [σz]; unit=:ħ)","category":"page"},{"location":"tutorials/couplings/","page":"Coupling","title":"Coupling","text":"The above codes creates two time dependent coupling operators cos(s) X and sin(s) Z. Then, c1 and c2 can be grouped together to create the coupling set","category":"page"},{"location":"tutorials/couplings/","page":"Coupling","title":"Coupling","text":"coupling = TimeDependentCouplings(c1, c2)","category":"page"},{"location":"tutorials/couplings/","page":"Coupling","title":"Coupling","text":"Only ConstantCouplings and TimeDependentCouplings can be used to create an annealing process.","category":"page"},{"location":"tutorials/math_symbol/#Math-Symbols","page":"Math Symbol","title":"Math Symbols","text":"","category":"section"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"The package defines some commonly used mathematical symbols and operators. Some of its features include:","category":"page"},{"location":"tutorials/math_symbol/#Pauli-Matrices","page":"Math Symbol","title":"Pauli Matrices","text":"","category":"section"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"Single qubit Pauli matrices are defined by σx, σy, σz and σi. One can simply calculate the tensor product of single qubits Pauli matrices by","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"julia> σx⊗σz\n4×4 Array{Complex{Float64},2}:\n 0.0+0.0im   0.0+0.0im  1.0+0.0im   0.0+0.0im\n 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -1.0+0.0im\n 1.0+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im\n 0.0+0.0im  -1.0+0.0im  0.0+0.0im  -0.0+0.0im","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"The eigenvectors of each Pauli matrices are also defined in constant PauliVec, where PauliVec[1],PauliVec[2],PauliVec[3] corresponds to eigenvectors of σx, σy, σz. Additionally, the first eigenvector is the one with positive eigenvalue","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"julia> σz*PauliVec[3][1] == PauliVec[3][1]\ntrue","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"Additionally, a sparse version of Pauli matrices are defined in spσx et al. They can be used to construct Hamiltonian in the form of sparse matrix.","category":"page"},{"location":"tutorials/math_symbol/#Construction-of-Multi-Qubits-Matrices","page":"Math Symbol","title":"Construction of Multi-Qubits Matrices","text":"","category":"section"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"The package provides various utility functions to construct multi-qubits matrices. For all the functions listed below, keyword argument sp can be set to generate sparse matrices.","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"The standard driver Hamiltonian in quantum annealing can be constructed with standard_driver","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"julia> standard_driver(2) == σx⊗σi + σi⊗σx\ntrue","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"and for sparse matrices","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"julia> standard_driver(2, sp=true) == spσx⊗spσi + spσi⊗spσx\ntrue","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"A multi-qubits matrix can be constructed from its string representation using q_translate","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"julia> q_translate(\"ZZ+0.5ZI-XZ\")\n4×4 Array{Complex{Float64},2}:\n  1.5+0.0im   0.0+0.0im  -1.0+0.0im   0.0+0.0im\n  0.0+0.0im  -0.5+0.0im   0.0+0.0im   1.0+0.0im\n -1.0+0.0im   0.0+0.0im  -1.5+0.0im  -0.0+0.0im\n  0.0+0.0im   1.0+0.0im  -0.0+0.0im   0.5+0.0im","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"Collective operators(same Pauli operator acting on each individual qubit) can be constructed with collective_operator","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"julia> collective_operator(\"z\", 3) == σz⊗σi⊗σi + σi⊗σz⊗σi + σi⊗σi⊗σz\ntrue","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"Single clause in multi-qubits Hamiltonian can be constructed by","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"julia> single_clause([\"z\",\"z\"], [2,3], -2, 4) == -2σi⊗σz⊗σz⊗σi\ntrue","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"Local field terms of the form ΣhᵢZᵢ can be constructed with local_field_term","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"julia> local_field_term([1.0, 0.5], [1, 2], 2) == σz⊗σi+0.5σi⊗σz\ntrue","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"Two local terms of the form JᵢⱼZᵢZⱼ can be constructed with two_local_term","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"julia> two_local_term([1.0, 0.5], [[1,2], [1,3]], 3) == σz⊗σz⊗σi + 0.5σz⊗σi⊗σz\ntrue","category":"page"},{"location":"tutorials/math_symbol/#Construction-of-Multi-Qubits-states","page":"Math Symbol","title":"Construction of Multi-Qubits states","text":"","category":"section"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"The quantum state of spin system can be construct with q_translate_state","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"julia> q_translate_state(\"001\")\n8-element Array{Complex{Float64},1}:\n 0.0 + 0.0im\n 1.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"In the string representation 0 and 1 represent the eigenstates of σ_z operator.","category":"page"},{"location":"tutorials/solver/#Open-System-Solvers","page":"Solver","title":"Open System Solvers","text":"","category":"section"},{"location":"tutorials/solver/","page":"Solver","title":"Solver","text":"QuantumAnnealingTools.jl provides several open quantum system solvers:","category":"page"},{"location":"tutorials/solver/#Redfield-equation","page":"Solver","title":"Redfield equation","text":"","category":"section"},{"location":"tutorials/solver/","page":"Solver","title":"Solver","text":"The interface to Redfield equation is:","category":"page"},{"location":"tutorials/solver/#Basic-usage","page":"Solver","title":"Basic usage","text":"","category":"section"},{"location":"tutorials/solver/","page":"Solver","title":"Solver","text":"The basic usage of Redfield solver is","category":"page"},{"location":"tutorials/solver/","page":"Solver","title":"Solver","text":"solve_redfield(\n    A::Annealing,\n    tf::Real,\n    unitary;\n    vectorize::Bool = false,\n    span_unit::Bool = false,\n    tstops = Float64[],\n    positivity_check::Bool = false,\n    kwargs...,\n)","category":"page"},{"location":"tutorials/solver/#QuantumAnnealingTools.solve_redfield-Tuple{Annealing,Real,Any}","page":"Solver","title":"QuantumAnnealingTools.solve_redfield","text":"solve_redfield(A, tf, unitary; vectorize, int_atol, int_rtol, Ta, kwargs...)\n\n\nSolve the time dependent Redfield equation for Annealing defined by A with total annealing time tf.\n\n...\n\nArguments\n\nA::Annealing: the Annealing object.\ntf::Real: the total annealing time.\nunitary: precalculated unitary of close system evolution.\nvectorize::Bool = false: whether to vectorize the density matrix.\nint_atol = 1e-8: the absolute error tolerance for integration.\nint_rtol = 1e-6: the relative error tolerance for integration.\nTa = tf: the time scale for backward integration.\nkwargs: other keyword arguments supported by DifferentialEquations.jl.\n\n...\n\n\n\n\n\n","category":"method"},{"location":"tutorials/solver/#Adiabatic-master-equation(AME)","page":"Solver","title":"Adiabatic master equation(AME)","text":"","category":"section"},{"location":"tutorials/solver/","page":"Solver","title":"Solver","text":"A good reference to adiabatic master equation is Albash, Tameem, et al. QuantumAnnealingTools.jl provides the following interfaces for AME solver:","category":"page"},{"location":"tutorials/solver/#Basic-usage-2","page":"Solver","title":"Basic usage","text":"","category":"section"},{"location":"tutorials/solver/","page":"Solver","title":"Solver","text":"The basic usage of AME solver is","category":"page"},{"location":"tutorials/solver/","page":"Solver","title":"Solver","text":"solve_ame(\n    A::Annealing,\n    tf::Real;\n    span_unit::Bool = false,\n    ω_hint = [],\n    lambshift::Bool = true,\n    lvl = size(A.H, 1),\n    kwargs...,\n)","category":"page"},{"location":"tutorials/solver/#QuantumAnnealingTools.solve_ame-Tuple{Annealing,Real}","page":"Solver","title":"QuantumAnnealingTools.solve_ame","text":"solve_ame(A, tf; tspan, ω_hint, lambshift, lvl, vectorize, kwargs...)\n\n\nSolve the adiabatic master equation for Annealing defined by A with total annealing time tf.\n\n...\n\nArguments\n\nA::Annealing: the Annealing object.\ntf::Real: the total annealing time.\ntspan = (0, tf): time interval to solve.\nω_hint=[] : grid for precalculating the lambshift; skip the precalculation if empty.\n'lambshift::Bool=true' : whether to include Lambshift in the calculation.\nlvl::Int=size(A.H, 1) : number of levels to keep. The default value is the dimension for the Hamiltonian.\nvectorize::Bool = false: whether to vectorize the density matrix.\nkwargs : other keyword arguments supported by DifferentialEquations.jl.\n\n...\n\n\n\n\n\n","category":"method"},{"location":"tutorials/solver/#Additional-solver-options","page":"Solver","title":"Additional solver options","text":"","category":"section"},{"location":"tutorials/solver/","page":"Solver","title":"Solver","text":"The extra keyword arguments kwargs will be directly passed to ODE solve interface. So every solver option is supported. However, because of the current implementation, several keyword arguments are strongly recommended:","category":"page"},{"location":"tutorials/solver/","page":"Solver","title":"Solver","text":"alg=Tsit5(): This set the algorithm to Tsitouras 5/4 Runge-Kutta method, which performs well for most problems. You can find a list of the available solver algorithms here. The implicit methods are only supported when the vectorize is set to true.\nsaveat: This argument denotes specific times to save the solution at, during the solving phase. It overrides the save_everystep keyword argument.\ntstops: This argument denotes extra times that the timestepping algorithm must step to. It will increase the accuracy if the algorithm is instructed to step to the know singularities of the problem.\nsave_everystep: Whether to save the result at every step. You can save the memory by setting it to false.","category":"page"},{"location":"tutorials/solver/#Examples","page":"Solver","title":"Examples","text":"","category":"section"},{"location":"tutorials/solver/","page":"Solver","title":"Solver","text":"An tutorial notebook for solving both Redfield and adiabatic master equation can be found here.","category":"page"},{"location":"tutorials/annealing/#Annealing","page":"Annealing","title":"Annealing","text":"","category":"section"},{"location":"tutorials/annealing/","page":"Annealing","title":"Annealing","text":"This package implements AbstractFactory pattern for potential quantum annealing process via an abstract type AbstractAnnealing. A complete quantum annealing process is assembled from the following parts:","category":"page"},{"location":"tutorials/annealing/","page":"Annealing","title":"Annealing","text":"Hamiltonian: Any object implements the AbstractHamiltonian interface\nInitial state: A state vector/density matrix\n(Optional)System bath coupling – system part\n(Optional)System bath coupling – bath part\n(Optional)Additional control protocols","category":"page"},{"location":"tutorials/annealing/","page":"Annealing","title":"Annealing","text":"For example, the following code block construct a standard single qubit annealing process","category":"page"},{"location":"tutorials/annealing/","page":"Annealing","title":"Annealing","text":"H = DenseHamiltonian([(s)->1-s, (s)->s], -[σx, σz]/2, unit=:ħ)\nu0 = PauliVec[1][1]\ncoupling = ConstantCouplings([\"Z\"], unit=:ħ)\nbath = Ohmic(1e-4, 4, 16)\nannealing = Annealing(H, u0; coupling=coupling, bath=bath)","category":"page"},{"location":"tutorials/annealing/","page":"Annealing","title":"Annealing","text":"with total Hamiltonian","category":"page"},{"location":"tutorials/annealing/","page":"Annealing","title":"Annealing","text":"H(s) = -(1-s)fracsigma_x2 - sfracsigma_z2 + sigma_z otimes B + H_B","category":"page"},{"location":"tutorials/annealing/","page":"Annealing","title":"Annealing","text":"where B H_B forms an Ohmic bath.","category":"page"},{"location":"tutorials/hamiltonians/#Hamiltonians","page":"Hamiltonian","title":"Hamiltonians","text":"","category":"section"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"A Hamiltonian is basically a time-dependent matrix. The package currently offers two ways to construct a Hamiltonian object. Before introducing those constructors, let's discuss the unit of Hamiltonian first.","category":"page"},{"location":"tutorials/hamiltonians/#Unit","page":"Hamiltonian","title":"Unit","text":"","category":"section"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"From the Schrodinger equation","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"  ihbar lvert Phi rangle = H lvert Phi rangle","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"we know the Hamiltonian can be normalized by H  hbar. If we set h=1, then what appears on the RHS of Schrodinger equation is 2pi H where H has the unit of frequency. We set this unit to the natural unit of superconducting qubits – GHz.","category":"page"},{"location":"tutorials/hamiltonians/#Construction","page":"Hamiltonian","title":"Construction","text":"","category":"section"},{"location":"tutorials/hamiltonians/#Affine-Operator","page":"Hamiltonian","title":"Affine Operator","text":"","category":"section"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"For fs = [f1,f2,...,fn] and Ms = [M1,M2,...,Mn] where each of the fi and Mi are Function(or callable object) and Matrix, the following constructor:","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"function TypeHamiltonian(fs,Ms)","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"builds an time dependent Hamiltonian H = f_1(t)M_1 + f_2(t)M_2 +  + f_n(t)M_n. The Type should be changed to a specific descriptor of the Hamiltonian. For example, a Hamiltonian consisted of dense matrices can be constructed with DenseHamiltonian","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"julia> H = DenseHamiltonian([(s)->1-s, (s)->s], [σx, σz])","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"The DenseHamiltonian constructor creates a standard single qubit annealing Hamiltonian of the form H(s)=(1-s)σ_x+sσ_z, whose default unit is GHz (h=1). Internally, this package always store the value of Hhbar. So any object created with default unit will be scaled by 2π. You can set the unit to ħ=1 by using the keyword argument unit","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"julia> H_ħ  = DenseHamiltonian([(s)->1-s, (s)->s], [σx, σz]; unit=:ħ)","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"(Setting unit to :ħ means the inputs of the constructor is already Hhbar.) To obtain the value of Hamiltonian at given s in consistent units, it is recommended to use function evaluate","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"julia> evaluate(H, 0.5)\n2×2 Array{Complex{Float64},2}:\n  0.5+0.0im  -0.5+0.0im\n -0.5+0.0im  -0.5+0.0im","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"It always returns the Hamiltonian value in GHz. Calling H directly like a Function will return numerical value of Hhbar","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"julia> H(0.5) == 2π*(σx + σz)/2\ntrue","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"There are two additional constructors: SparseHamiltonian and AdiabaticFrameHamiltonian, which construct sparse Hamiltonians and Hamiltonians in adiabatic frame respectively.","category":"page"},{"location":"tutorials/hamiltonians/#Interpolating","page":"Hamiltonian","title":"Interpolating","text":"","category":"section"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"The second method is to construct the Hamiltonian by interpolating gridded values","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"  H(s_1) H(s_2) ldots","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"Internally, the package rely on Interpolations.jl for fast interpolating. The syntax for constructing interpolation Hamiltonian object is","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"H_interp = InterpDenseHamiltonian(s_axis, H_list)\nH_interp = InterpSparseHamiltonian(s_axis, H_list)","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"where s_axis and H_list are the grid points and corresponding Hamiltonian values. The constructors also take keyword argument method, order and unit. method and order specify the internal interpolation method. For dense Hamiltonians, both BSpline of order 0-3 and Gridded of order 0-1 are supported. For sparse Hamiltonians, only Gridded of order 0-1 is supported.","category":"page"},{"location":"tutorials/hamiltonians/#Eigendecomposition","page":"Hamiltonian","title":"Eigendecomposition","text":"","category":"section"},{"location":"tutorials/hamiltonians/#Plotting","page":"Hamiltonian","title":"Plotting","text":"","category":"section"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"This package can also interact with Plots.jl to provide convenient ways for visualizing the spectrum of any given Hamiltonians. For example","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"using Plots\nplot(H, 0:0.01:1, 2)","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"will produce the following figure. The second argument 0:0.01:1 is the x_axis values and the third argument 2 is the number of levels to plot. The third argument can also be a list of levels.","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"(Image: plot_hamiltonian_example)","category":"page"},{"location":"lib/QTBase/","page":"Base","title":"Base","text":"Modules = [QTBase]\nPrivate = false","category":"page"},{"location":"lib/QTBase/#QTBase.PauliVec","page":"Base","title":"QTBase.PauliVec","text":"PauliVec\n\nConstants for the eigenvectors of single qubit Pauli matrices. Indices 1, 2 and 3 corresponds to the eigenvectors of σ_x, σ_y and σ_z.\n\nExamples\n\njulia> σx*PauliVec[1][1] == PauliVec[1][1]\ntrue\n\n\n\n\n\n","category":"constant"},{"location":"lib/QTBase/#QTBase.AbstractAnnealing","page":"Base","title":"QTBase.AbstractAnnealing","text":"abstract type AbstractAnnealing\n\nBase for types defining quantum annealing process.\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.AbstractBath","page":"Base","title":"QTBase.AbstractBath","text":"abstract type AbstractBath\n\nBase for types defining bath object.\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.AbstractCouplings","page":"Base","title":"QTBase.AbstractCouplings","text":"abstract type AbstractCouplings\n\nBase for types defining system bath coupling operators in open quantum system models.\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.AbstractDenseHamiltonian","page":"Base","title":"QTBase.AbstractDenseHamiltonian","text":"abstract type AbstractDenseHamiltonian <: AbstractHamiltonian{T<:Number}\n\nBase for types defining Hamiltonians using dense matrices.\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.AbstractHamiltonian","page":"Base","title":"QTBase.AbstractHamiltonian","text":"abstract type AbstractHamiltonian\n\nSuptertype for Hamiltonians with elements of type T. Any Hamiltonian object should implement two interfaces: H(t) and H(du, u, p, t).\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.AbstractLiouvillian","page":"Base","title":"QTBase.AbstractLiouvillian","text":"abstract type AbstractLiouvillian\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.AbstractSparseHamiltonian","page":"Base","title":"QTBase.AbstractSparseHamiltonian","text":"abstract type AbstractSparseHamiltonian <: AbstractHamiltonian{T<:Number}\n\nBase for types defining Hamiltonians using sparse matrices.\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.AdiabaticFrameHamiltonian","page":"Base","title":"QTBase.AdiabaticFrameHamiltonian","text":"struct AdiabaticFrameHamiltonian{T} <: AbstractDenseHamiltonian{T}\n\nDefines a time dependent Hamiltonian in adiabatic frame.\n\nFields\n\ngeometric\nGeometric part\ndiagonal\nAdiabatic part\nsize\nSize of the Hamiltonian\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.AdiabaticFrameHamiltonian-Tuple{Any,Any}","page":"Base","title":"QTBase.AdiabaticFrameHamiltonian","text":"function AdiabaticFrameHamiltonian(ωfuns, geofuns)\n\nConstructor of adiabatic frame Hamiltonian. ωfuns is a 1-D array of functions which specify the eigen energies (in GHz) of the Hamiltonian. geofuns is a 1-D array of functions which specifies the geometric phases of the Hamiltonian. geofuns can be thought as a flattened lower triangular matrix (without diagonal elements) in column-major order.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.Annealing","page":"Base","title":"QTBase.Annealing","text":"mutable struct Annealing{hType, uType} <: AbstractAnnealing{hType,uType}\n\nDefines a quantum annealing process.\n\nFields\n\nH\nHamiltonian for the annealing.\nu0\nInitial state for the annealing.\nannealing_parameter\nFunction of annealing parameter s wrt to t\ninteractions\nA system bath interaction set.\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.ConstantCouplings","page":"Base","title":"QTBase.ConstantCouplings","text":"struct ConstantCouplings <: AbstractCouplings\n\nDefines constant system bath coupling operators.\n\nFields\n\nmats\n1-D array for independent coupling operators\nstr_rep\nString representation for the coupling (for display purpose)\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.ConstantCouplings-Union{Tuple{Array{T,1}}, Tuple{T}} where T<:AbstractString","page":"Base","title":"QTBase.ConstantCouplings","text":"function ConstantCouplings(c::Vector{T}; sp = false, unit=:h) where T <: AbstractString\n\nIf the first argument is a 1-D array of strings. The constructor will automatically construct the matrics represented by the string representations.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.ConstantCouplings-Union{Tuple{Union{Array{Array{T,2},1}, Array{SparseMatrixCSC{T,Int64},1}}}, Tuple{T}} where T<:Number","page":"Base","title":"QTBase.ConstantCouplings","text":"function ConstantCouplings(mats; str_rep=nothing, unit=:h)\n\nConstructor of ConstantCouplings object. mats is 1-D array of matrices. str_rep is the optional string representation of the coupling terms. unit is the unit one – :h or :ħ. The mats will be scaled by 2π is unit is :h.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.CustomBath","page":"Base","title":"QTBase.CustomBath","text":"mutable struct CustomBath <: AbstractBath\n\nAn custum bath object defined by the two-point correlation function and the corresponding spectrum.\n\ncfun\ncorrelation function\nγ\nspectrum\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.CustomCouplings","page":"Base","title":"QTBase.CustomCouplings","text":"struct CustomCouplings <: AbstractTimeDependentCouplings\n\nCustomCouplings is a container for any user defined coupling operators.\n\nFields\n\ncoupling\nA 1-D array of callable objects that returns coupling matrices\nsize\nSize of the coupling operator\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.CustomDenseHamiltonian","page":"Base","title":"QTBase.CustomDenseHamiltonian","text":"struct CustomDenseHamiltonian{T<:Number, in_place} <: AbstractDenseHamiltonian{T<:Number}\n\nDefines a time dependent Hamiltonian object with custom function.\n\nFields\n\nf\nFunction for the Hamiltonian H(s)\nu_cache\nInternal cache\nsize\nSize\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.DaviesGenerator","page":"Base","title":"QTBase.DaviesGenerator","text":"struct DaviesGenerator <: AbstractLiouvillian\n\nDefines Davies generator\n\nFields\n\ncoupling\nSystem bath coupling operators\nγ\nSpectrum density\nS\nLambshift spectrum density\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.DenseHamiltonian","page":"Base","title":"QTBase.DenseHamiltonian","text":"struct DenseHamiltonian{T<:Number} <: AbstractDenseHamiltonian{T<:Number}\n\nDefines a time dependent Hamiltonian object with dense Matrices.\n\nFields\n\nf\nList of time dependent functions\nm\nList of constant matrices\nu_cache\nInternal cache\nsize\nSize\nEIGS\nEigen decomposition routine\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.DenseHamiltonian-Tuple{Any,Any}","page":"Base","title":"QTBase.DenseHamiltonian","text":"DenseHamiltonian(funcs, mats; unit, EIGS)\n\n\nConstructor of DenseHamiltonian object. funcs and mats are a list of time dependent functions and the corresponding matrices. unit is the unit one – :h or :ħ. The mats will be scaled by 2π if unit is :h.\n\nEIGS is the initializer for the eigen decomposition routine for the Hamiltonian. It should return a function of signature: (H, s, lvl) -> (w, v). The default method EIGEN_DEFAULT will use LAPACK routine.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.DenseHamiltonian-Tuple{Real}","page":"Base","title":"QTBase.DenseHamiltonian","text":"function (h::DenseHamiltonian)(s::Real)\n\nCalling the Hamiltonian returns the value 2πH(s). The argument s is in the unitless time. The returned matrix is in angular frequency.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.EnsembleFluctuator","page":"Base","title":"QTBase.EnsembleFluctuator","text":"struct EnsembleFluctuator{T} <: AbstractBath\n\nAn ensemble of random telegraph noise.\n\nf\nA list of RTNs\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.Fluctuators","page":"Base","title":"QTBase.Fluctuators","text":"mutable struct Fluctuators <: AbstractLiouvillian\n\nDefines a fluctuator ensemble controller\n\nFields\n\ncoupling\nsystem-bath coupling operator\ndist\nwaitting time distribution for every fluctuators\nb0\ncache for each fluctuator value\nnext_idx\nindex of the fluctuator to be flipped next\nnext_τ\ntime interval for next flip event\nn\nnoise value\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.InplaceUnitary","page":"Base","title":"QTBase.InplaceUnitary","text":"struct InplaceUnitary\n\nA tag for inplace unitary function. func(cache, t) is the actual inplace update function.\n\nFields\n\nfunc\ninplace update function\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.Interaction","page":"Base","title":"QTBase.Interaction","text":"struct Interaction\n\nAn object to hold system operator and the corresponding bath object.\n\ncoupling\nsystem operator\nbath\nbath coupling to the system operator\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.InteractionSet","page":"Base","title":"QTBase.InteractionSet","text":"struct InteractionSet{T<:Tuple}\n\nAn container for different system-bath interactions.\n\ninteractions\nA tuple of Interaction\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.InterpDenseHamiltonian","page":"Base","title":"QTBase.InterpDenseHamiltonian","text":"struct InterpDenseHamiltonian{T} <: AbstractDenseHamiltonian{T}\n\nDefines interpolating DenseHamiltonian object\n\nFields\n\ninterp_obj\nInterpolating object\nsize\nSize\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.InterpSparseHamiltonian","page":"Base","title":"QTBase.InterpSparseHamiltonian","text":"struct InterpSparseHamiltonian{T} <: AbstractSparseHamiltonian{T}\n\nDefines interpolating SparseHamiltonian object\n\nFields\n\ninterp_obj\nInterpolating object\nsize\nSize\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.ODEParams","page":"Base","title":"QTBase.ODEParams","text":"struct ODEParams\n\nDefines a complete set of ODE parameters, which includes Hamiltonian, total annealing time, open system and control objects.\n\nFields\n\nL\nHamiltonian\ntf\nTotal annealing time\nannealing_parameter\nFunction to convert physical time to annealing parameter\ncontrol\nAnnealing control object\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.OhmicBath","page":"Base","title":"QTBase.OhmicBath","text":"OhmicBath\n\nOhmic bath object to hold a particular parameter set.\n\nFields\n\nη – strength.\nωc – cutoff frequence.\nβ – inverse temperature.\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.OpenSysOp","page":"Base","title":"QTBase.OpenSysOp","text":"struct OpenSysOp{diagonalization, adiabatic_frame}\n\nDefines an open system DiffEqOperator in the specific basis.\n\nFields\n\nH\nHamiltonian\nopensys\nOpen system part\nlvl\nLevels to truncate\nu_cache\nInternal cache\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.ProjectedCoupling","page":"Base","title":"QTBase.ProjectedCoupling","text":"struct ProjectedCoupling\n\nObject for a projected coupling parameterized by NIBA parameters. This object holds the numerical values at gridded points.\n\nFields\n\ns\nTime grid (unitless) for projection\na\n(σ_m - σ_n)^2\nb\nσ_mn^2\nc\nσ_mn(σ_m-σ_n)\nd\nσ_mn(σ_m+σ_n)\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.ProjectedSystem","page":"Base","title":"QTBase.ProjectedSystem","text":"struct ProjectedSystem\n\nObject for a projected low level system. The projection is only valid for real Hamiltonians.\n\nFields\n\ns\nTime grid (unitless) for projection\nev\nEnergy values for different levels\ndθ\nGeometric terms\nop\nProjected system bath interaction operators\nref\nEnergy eigenstates at the final time\nlvl\nNumber of levels being kept\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.ProjectedTG","page":"Base","title":"QTBase.ProjectedTG","text":"struct ProjectedTG\n\nObject for a projected system Hamiltonian parameterized by NIBA parameters. This object holds the numerical values at gridded points.\n\nFields\n\ns\nTime grid (unitless) for projection\nω\nFrequencies of given basis states\nT\nAdiabatic part\nG\nGeometric phase\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.RedfieldGenerator","page":"Base","title":"QTBase.RedfieldGenerator","text":"struct RedfieldGenerator <: AbstractLiouvillian\n\nDefines RedfieldGenerator.\n\nFields\n\nops\nsystem-bath coupling operator\nunitary\nclose system unitary\ncfun\nbath correlation function\natol\nabsolute error tolerance for integration\nrtol\nrelative error tolerance for integration\nUt\ncache matrix for inplace unitary\nUτ\ncache matrix for inplace unitary\nΛ\ncache matrix for integration\nTa\ntf minus coarse grain time scale\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.SparseHamiltonian","page":"Base","title":"QTBase.SparseHamiltonian","text":"struct SparseHamiltonian{T<:Number} <: AbstractSparseHamiltonian{T<:Number}\n\nDefines a time dependent Hamiltonian object with sparse Matrices.\n\nFields\n\nf\nList of time dependent functions\nm\nList of constant matrices\nu_cache\nInternal cache\nsize\nSize\nEIGS\nEigen decomposition routine\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.SparseHamiltonian-Tuple{Any,Any}","page":"Base","title":"QTBase.SparseHamiltonian","text":"SparseHamiltonian(funcs, mats; unit, EIGS)\n\n\nConstructor of SparseHamiltonian object. funcs and mats are a list of time dependent functions and the corresponding matrices. unit is the unit one – :h or :ħ. The mats will be scaled by 2π is unit is :h.\n\nEIGS is the initializer for the eigen decomposition routine for the Hamiltonian. It should return a function of signature: (H, s, lvl) -> (w, v). The default method EIGEN_DEFAULT will use LAPACK routine.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.SparseHamiltonian-Tuple{Real}","page":"Base","title":"QTBase.SparseHamiltonian","text":"function (h::SparseHamiltonian)(t::Real)\n\nCalling the Hamiltonian returns the value 2πH(t).\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.TimeDependentCoupling","page":"Base","title":"QTBase.TimeDependentCoupling","text":"struct TimeDependentCoupling\n\nDefines a single time dependent system bath coupling operator. It is defined as S(s)=f(s)M.  Keyword argument unit set the unit one – h or ħ.\n\nFields\n\nfuncs\n1-D array of time dependent functions\nmats\n1-D array of constant matrics\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.TimeDependentCouplings","page":"Base","title":"QTBase.TimeDependentCouplings","text":"struct TimeDependentCouplings <: AbstractTimeDependentCouplings\n\nDefines an 1-D array of time dependent system bath coupling operators.\n\nFields\n\ncoupling\nA tuple of single TimeDependentCoupling operators\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.ΓMatrix","page":"Base","title":"QTBase.ΓMatrix","text":"struct ΓMatrix\n\nDefines rates of Davies form ME acting on the diagonal elements.\n\nFields\n\nm\ninterpolated Γ matrix\nlvl\nlevels of the system\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.:⊗","page":"Base","title":"QTBase.:⊗","text":"⊗(A, B)\n\nCalculate the tensor product of A and B.\n\nExamples\n\njulia> σx⊗σz\n4×4 Array{Complex{Float64},2}:\n 0.0+0.0im   0.0+0.0im  1.0+0.0im   0.0+0.0im\n 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -1.0+0.0im\n 1.0+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im\n 0.0+0.0im  -1.0+0.0im  0.0+0.0im  -0.0+0.0im\n\n\n\n\n\n","category":"function"},{"location":"lib/QTBase/#QTBase.EIGEN_DEFAULT-Tuple{AbstractDenseHamiltonian}","page":"Base","title":"QTBase.EIGEN_DEFAULT","text":"function EIGEN_DEFAULT(H)\n\nThe default initializer for eigen factorization method. It returns a function of signature: (H, s, lvl) -> (w, v). H is the Hamiltonian object, s is the dimensionless time and lvl is the energy levels to keep. This default initializer will use LAPACK routine for both dense and sparse matrices.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.EIGEN_DEFAULT-Tuple{Any}","page":"Base","title":"QTBase.EIGEN_DEFAULT","text":"function EIGEN_DEFAULT(u_cache)\n\nThe default initializer for eigen factorization method. It returns a function of signature: (H, s, lvl) -> (w, v). u_cache is the cache for Hamiltonian object, s is the time argument for the Hamiltonian and lvl is the energy levels to keep. This default initializer will use LAPACK routine for both dense and sparse matrices.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.Ohmic-Tuple{Any,Any,Any}","page":"Base","title":"QTBase.Ohmic","text":"Ohmic(η, fc, T)\n\n\nConstruct OhmicBath from parameters with physical unit: η–unitless interaction strength; fc–cutoff frequency in GHz; T–temperature in mK.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.S-Tuple{Any,OhmicBath}","page":"Base","title":"QTBase.S","text":"S(w, bath; atol)\n\n\nCalculate the Lamb shift of Ohmic spectrum. atol is the absolute tolerance for Cauchy principal value integral.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.ame_jump-Tuple{OpenSysOp{true,false},Any,Any,Real}","page":"Base","title":"QTBase.ame_jump","text":"ame_jump(A::OpenSysOp, u, p, t::Real)\n\nCalculate the jump operator for the OpenSysOp at time t.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.check_positivity-Tuple{AbstractArray{T,2} where T}","page":"Base","title":"QTBase.check_positivity","text":"check_positivity(m)\n\nCheck if matrix m is positive. Return true is the minimum eigenvalue of m is greater than or equal to 0.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.check_unitary-Tuple{AbstractArray{T,2} where T}","page":"Base","title":"QTBase.check_unitary","text":"check_unitary(𝐔; rtol, atol)\n\n\nTest if 𝐔 is a unitary matrix. The function checks how close both 𝐔𝐔^ and 𝐔^𝐔 are to I, with relative and absolute error given by rtol, atol.\n\nExamples\n\njulia> check_unitary(exp(-1.0im*5*0.5*σx))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.coarse_grain_timescale-Tuple{AbstractBath,Any}","page":"Base","title":"QTBase.coarse_grain_timescale","text":"coarse_grain_timescale(bath, lim; rtol, atol)\n\n\nCalculate the optimal coarse grain time scale T_a for a total evolution time lim. atol and rtol are the absolute and relative error for the integration.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.collective_coupling-Tuple{Any,Any}","page":"Base","title":"QTBase.collective_coupling","text":"function collective_coupling(op, num_qubit; sp=false)\n\nCreate ConstantCouplings object with operator op on each qubits. op is the string representation of one of the Pauli matrices. num_qubit is the total number of qubits. sp set whether to use sparse matrices. unit set the unit one – h or ħ.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.collective_operator-Tuple{Any,Any}","page":"Base","title":"QTBase.collective_operator","text":"collective_operator(op, num_qubit; sp=false)\n\nConstruct the collective operator for a system of num_qubit qubits. op is the name of the collective Pauli matrix. For example, the following code construct an IZ + ZI matrix. Generate sparse matrix when sp is set to true.\n\nExamples\n\njulia> collective_operator(\"z\", 2)\n4×4 Array{Complex{Float64},2}:\n 2.0+0.0im  0.0+0.0im  0.0+0.0im   0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im   0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im   0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  -2.0+0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.concatenate-Tuple","page":"Base","title":"QTBase.concatenate","text":"function concatenate(args...)\n\nConcatenate multiple ProjectedSystem objects into a single one. The arguments need to be in time order. The ref field of the new object will have the same value as the last input arguments.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.construct_interpolations-Union{Tuple{N}, Tuple{T}, Tuple{S}, Tuple{AbstractRange{S},AbstractArray{T,N}}} where N where T<:Number where S<:Real","page":"Base","title":"QTBase.construct_interpolations","text":"function construct_interpolations(x, y; method = \"BSpline\", order = 2, extrapolation = \"line\")\n\nConstruct interpolation of N-D array y along its last dimension on grid x. method specifies the interpolation algorithm, which can be either \"BSpline\" or \"Gridded\". If x is an AbstractRange, the default method is \"BSpline\", otherwise the default method is \"Gridded\". order is the interpolation order. If x is AbstractRange, the default order is 2, otherwise the default order is 1. extrapolation specifies the extrapolation methods.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.eigen_decomp-Tuple{AbstractHamiltonian,AbstractArray{Float64,1}}","page":"Base","title":"QTBase.eigen_decomp","text":"eigen_decomp(H, s; lvl)\n\n\nCalculate the eigen value decomposition of the Hamiltonian H at an array of time points s. The output keeps the lowest lvl eigenstates and their corresponding eigenvalues. Output (vals, vecs) have the dimensions of (lvl, length(s)) and (size(H, 1), lvl, length(s)) respectively.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.eigen_decomp-Tuple{AbstractHamiltonian,Any}","page":"Base","title":"QTBase.eigen_decomp","text":"eigen_decomp(H, s; lvl)\n\n\nCalculate the eigen value decomposition of the Hamiltonian H at time s. Keyword argument lvl specifies the number of levels to keep in the output. w is a vector of eigenvalues and v is a matrix of the eigenvectors in the columns. (The kth eigenvector can be obtained from the slice v[:, k].) w will be in unit of GHz.\n\neig_init is the initializer for eigen factorization routine. It returns a function of signature: (H, s, lvl) -> (w, v). The default initializer EIGEN_DEFAULT will use LAPACK routine for both dense and sparse matrices.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.evaluate-Tuple{AbstractHamiltonian,Any}","page":"Base","title":"QTBase.evaluate","text":"evaluate(H::AbstractHamiltonian, s)\n\nEvaluate the time dependent Hamiltonian at time s with the unit of GHz\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.evaluate-Tuple{AdiabaticFrameHamiltonian,Any,Any}","page":"Base","title":"QTBase.evaluate","text":"function evaluate(H::AdiabaticFrameHamiltonian, s, tf)\n\nEvaluate the adiabatic frame Hamiltonian at (unitless) time s, with total annealing time tf (in the unit of ns). The final result is given in unit of GHz.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.freq_2_temperature-Tuple{Any}","page":"Base","title":"QTBase.freq_2_temperature","text":"freq_2_temperature(freq)\n\nConvert frequency in GHz to temperature in mK.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.get_dθ","page":"Base","title":"QTBase.get_dθ","text":"get_dθ(sys::ProjectedSystem, i=1, j=2)\n\nGet the geometric terms between i, j energy levels from ProjectedSystem.\n\n\n\n\n\n","category":"function"},{"location":"lib/QTBase/#QTBase.gibbs_state-Tuple{Any,Any}","page":"Base","title":"QTBase.gibbs_state","text":"gibbs_state(h, β)\n\nCalculate the Gibbs state of the matrix h at temperature T (mK).\n\nExamples\n\njulia> gibbs_state(σz, 10)\n2×2 Array{Complex{Float64},2}:\n 0.178338+0.0im       0.0+0.0im\n      0.0+0.0im  0.821662+0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.gradient-Tuple{Any,Number}","page":"Base","title":"QTBase.gradient","text":"function gradient(itp, s)\n\nCalculate the gradient of itp at s.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.hamming_weight_operator-Tuple{Int64,String}","page":"Base","title":"QTBase.hamming_weight_operator","text":"hamming_weight_operator(num_qubit::Int64, op::String; sp=false)\n\nConstruct the Hamming weight operator for system of size num_qubit. The type of the Hamming weight operator is specified by op: \"x\", \"y\" or \"z\". Generate sparse matrix when sp is set to true.\n\nExamples\n\njulia> hamming_weight_operator(2,\"z\")\n4×4 Array{Complex{Float64},2}:\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  2.0+0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.inst_population-Tuple{Any,Any,AbstractHamiltonian}","page":"Base","title":"QTBase.inst_population","text":"inst_population(s, states, H; lvl)\n\n\nFor a time series quantum states given by states, whose time points are given by s, calculate the population of instantaneous eigenstates of H. The levels of the instantaneous eigenstates are specified by lvl, which can be any slice index.\n\neig_init is the initializer for eigen factorization routine. It returns a function of signature: (H, s, lvl) -> (w, v). The default initializer EIGEN_DEFAULT will use LAPACK routine for both dense and sparse matrices.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.local_field_term-Tuple{Any,Any,Any}","page":"Base","title":"QTBase.local_field_term","text":"local_field_term(h, idx, num_qubit; sp=false)\n\nConstruct local Hamiltonian of the form hᵢσᵢᶻ. idx is the index of all local field terms and h is a list of the corresponding weights. num_qubit is the total number of qubits. Generate sparse matrix when sp is set to true.\n\nExamples\n\njulia> local_field_term([1.0, 0.5], [1, 2], 2) == σz⊗σi+0.5σi⊗σz\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.log_uniform-Tuple{Any,Any,Any}","page":"Base","title":"QTBase.log_uniform","text":"log_uniform(a, b, num; base)\n\n\nGenerate a log-uniformly distributed array with num elements between a and b. The base of log is base with default value 10.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.low_level_matrix-Tuple{Any,Any}","page":"Base","title":"QTBase.low_level_matrix","text":"low_level_matrix(M, lvl)\n\nCalculate the matrix M projected to lower energy subspace containing lvl energy lvl.\n\nExamples\n\njulia> low_level_matrix(σx⊗σx, 2)\n4×4 Array{Complex{Float64},2}:\n -0.5+0.0im   0.0+0.0im   0.0+0.0im   0.5+0.0im\n  0.0+0.0im  -0.5+0.0im   0.5+0.0im   0.0+0.0im\n  0.0+0.0im   0.5+0.0im  -0.5+0.0im   0.0+0.0im\n  0.5+0.0im   0.0+0.0im   0.0+0.0im  -0.5+0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.matrix_decompose-Tuple{AbstractArray{T,2} where T,Array{#s16,1} where #s16<:(AbstractArray{T,2} where T)}","page":"Base","title":"QTBase.matrix_decompose","text":"matrix_decompose(mat, basis)\n\n\nDecompse matrix mat onto matrix basis basis\n\nExamples\n\njulia> matrix_decompose(1.0*σx+2.0*σy+3.0*σz, [σx,σy,σz])\n3-element Array{Complex{Float64},1}:\n 1.0 + 0.0im\n 2.0 + 0.0im\n 3.0 + 0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.partial_trace-Tuple{Array{T,2} where T,Any}","page":"Base","title":"QTBase.partial_trace","text":"partial_trace(ρ, qubit_2_keep)\n\n\nCalculate the partial trace of the density matrix ρ. qubit_2_keep is an array of qubit indices to keep.\n\nExamples\n\njulia> ρ1 = [0.4 0.5; 0.5 0.6]; ρ2 = [0.5 0; 0 0.5];\njulia> partial_trace(ρ1⊗ρ2, [1])\n2×2 Array{Float64,2}:\n 0.4  0.5\n 0.5  0.6\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.project_to_lowlevel-Union{Tuple{S}, Tuple{T}, Tuple{AbstractHamiltonian{T},Any,Any,AbstractArray{S,1}}} where S<:Real where T<:Real","page":"Base","title":"QTBase.project_to_lowlevel","text":"project_to_lowlevel(H::AbstractHamiltonian{T}, dH, coupling, s_axis; lvl=2, eig_init = EIGEN_DEFAULT)\n\nProject a Hamiltonian H to the lowest lvl level subspace. dH is the derivative of Hamiltonian and coupling is the system-bath interaction operator. They should be callable with a single argument – annealing parameter s. s_axis is the (unitless) times to calculate the projection.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.q_translate-Tuple{String}","page":"Base","title":"QTBase.q_translate","text":"q_translate(h::String)\n\nConvert a string h representing multi-qubits Pauli matrices summation into its numerical form.\n\nExamples\n\njulia> q_translate(\"X+2.0Z\")\n2×2 Array{Complex{Float64},2}:\n 2.0+0.0im   1.0+0.0im\n 1.0+0.0im  -2.0+0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.q_translate_state-Tuple{String}","page":"Base","title":"QTBase.q_translate_state","text":"q_translate_state(h::String; normal=false)\n\nConvert a string representation of quantum state to a vector. The keyword argument normal indicates whether to normalize the output vector. (Currently only '0' and '1' are supported)\n\nExamples\n\nSingle term:\n\njulia> q_translate_state(\"001\")\n8-element Array{Complex{Float64},1}:\n 0.0 + 0.0im\n 1.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n\nMultiple terms:\n\njulia> q_translate_state(\"(101)+(001)\", normal=true)\n8-element Array{Complex{Float64},1}:\n                0.0 + 0.0im\n 0.7071067811865475 + 0.0im\n                0.0 + 0.0im\n                0.0 + 0.0im\n                0.0 + 0.0im\n 0.7071067811865475 + 0.0im\n                0.0 + 0.0im\n                0.0 + 0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.single_clause-NTuple{4,Any}","page":"Base","title":"QTBase.single_clause","text":"single_clause(ops, q_ind, weight, num_qubit; sp=false)\n\nConstruct a single clause of the multi-qubits Hamiltonian. ops is a list of Pauli operator names which appears in this clause. q_ind is the list of indices corresponding to the Pauli matrices in ops. weight is the constant factor of this clause. num_qubit is the total number of qubits. A sparse matrix can be construct by setting sp to true. The following example construct a clause of Z_1 I Z_32.\n\nExamples\n\njulia> single_clause([\"z\", \"z\"], [1, 3], 0.5, 3)\n8×8 Array{Complex{Float64},2}:\n 0.5+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im\n 0.0+0.0im  -0.5+0.0im  0.0+0.0im  -0.0+0.0im   0.0+0.0im  -0.0+0.0im   0.0+0.0im  -0.0+0.0im\n 0.0+0.0im   0.0+0.0im  0.5+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im\n 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -0.5+0.0im   0.0+0.0im  -0.0+0.0im   0.0+0.0im  -0.0+0.0im\n 0.0+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im  -0.5+0.0im  -0.0+0.0im  -0.0+0.0im  -0.0+0.0im\n 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -0.0+0.0im  -0.0+0.0im   0.5-0.0im  -0.0+0.0im   0.0-0.0im\n 0.0+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im  -0.0+0.0im  -0.0+0.0im  -0.5+0.0im  -0.0+0.0im\n 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -0.0+0.0im  -0.0+0.0im   0.0-0.0im  -0.0+0.0im   0.5-0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.standard_driver-Tuple{Any}","page":"Base","title":"QTBase.standard_driver","text":"standard_driver(num_qubit; sp=false)\n\nConstruct the standard driver Hamiltonian for a system of num_qubit qubits. For example, a two qubits standard driver matrix is IX + XI. Generate sparse matrix when sp is set to true.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.temperature_2_freq-Tuple{Any}","page":"Base","title":"QTBase.temperature_2_freq","text":"temperature_2_freq(T)\n\nConvert temperature from mK to GHz.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.temperature_2_β-Tuple{Any}","page":"Base","title":"QTBase.temperature_2_β","text":" temperature_2_β(T)\n\nConvert physical temperature T in mK to thermodynamic β in the unit of inverse angular frequency, that is to say β = ħkT.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.two_local_term-Tuple{Any,Any,Any}","page":"Base","title":"QTBase.two_local_term","text":"two_local_term(j, idx, num_qubit; sp=false)\n\nConstruct local Hamiltonian of the form Jᵢⱼσᵢᶻσⱼᶻ. idx is the index of all two local terms and j is a list of the corresponding weights. num_qubit is the total number of qubits. Generate sparse matrix when sp is set to true.\n\nExamples\n\njulia> two_local_term([1.0, 0.5], [[1,2], [1,3]], 3) == σz⊗σz⊗σi + 0.5σz⊗σi⊗σz\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.β_2_temperature-Tuple{Any}","page":"Base","title":"QTBase.β_2_temperature","text":"β_2_temperature(β)\n\nConvert thermodynamic β in the unit of inverse angular frequency to physical temperature T in GHz.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.γ-Tuple{Any,OhmicBath}","page":"Base","title":"QTBase.γ","text":"γ(ω, params)\n\n\nCalculate Ohmic spectrum density, defined as a full Fourier transform on the bath correlation function.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.τ_B-Tuple{Any,Any,Any}","page":"Base","title":"QTBase.τ_B","text":"τ_B(cfun, lim, τsb; rtol, atol)\n\n\nCalculate the bath correlation time τ_B. The upper limit lim and τsb need to be manually specified. atol and rtol are the absolute and relative error for the integration.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.τ_SB-Tuple{Any}","page":"Base","title":"QTBase.τ_SB","text":"τ_SB(cfun; lim, rtol, atol)\n\n\nCalculate τ_SB from the bath correlation function cfun. It is defined as the integration of the absolute value of bath correlation function from zero to lim. The default value of lim is Inf. atol and rtol are the absolute and relative error of the integration.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/bath/#Bath","page":"Bath","title":"Bath","text":"","category":"section"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"We start with a general form of system bath interaction Hamiltonian","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"  H_SB = sum_alpha S_alphaotimes B_alpha","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"and define each B_alpha (together with the bath Hamiltonian H_B) as an AbstractBath object. An important metric for any bath is its two point correlation function","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"  C(t_1 t_2) = langle mathcalB(t_1) mathcalB(t_2) rangle","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"where","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"  mathcalB(t) = U_B^dagger (t) B U_B(t)","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"and U_B(t) is the unitary generated by the pure bath Hamiltonian","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"  U_B(t) = mathcalTexpBig -iint_0^t H_B mathrmdtau Big","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"The spectrum density of the bath is defined as the Fourier transform of the correlation function and is usually denoted as S(omega). It is important to notice that, only for Gaussian bath(or bath which satisfies the Wick Theorem) does the correlation function uniquely determine the bath. Otherwise, high order correlation functions may be necessary. Nevertheless, it is still an area of active research on how to experimentally measure those high order correlation functions. So in most occasions, only two point correlation function is available to us and we treat the noise as Gaussian.","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"Currently, there are two build-in concrete types of the AbstractBath class – OhmicBath and HybridOhmicBath. More examples can be found in this notebook.","category":"page"},{"location":"tutorials/bath/#Ohmic-Bath","page":"Bath","title":"Ohmic Bath","text":"","category":"section"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"A self-consistent reference for Ohmic bath is Albash, Tameem, et al. We can use Ohmic function to construct OhmicBath object","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"η = 1e-4; fc=4; T=16\nbath = Ohmic(η, fc, T);","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"The correlation and spectrum function of the bath object can be calculated by","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"correlation(τ, bath)\nspectrum(ω, bath)","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"This interface is true for every concrete type of AbstractBath. However, the plotting system works differently for different bath models. For OhmicBath, you can use","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"ω = range(0, 20, length=200)\nplot(bath, :γ, ω)\nplot(bath, :S, ω)","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"to conveniently plot the spectrum and lamb shift.","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"(Image: plot_ohmic_spectrum) (Image: plot_ohmic_lamb)","category":"page"},{"location":"tutorials/bath/#Hybrid-Ohmic-Bath","page":"Bath","title":"Hybrid Ohmic Bath","text":"","category":"section"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"A good reference paper for the hybrid ohmic bath model is Lanting et al. The model is generalized in Smirnov and Amin. The basic idea is, the noise spectrum of this bath model can be split into the low frequency and high frequency parts","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"  S(omega) = S^L(ω) + S^H(ω)","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"The high frequency part of the bath is the Ohmic and the low frequency part can be something like the 1f noise. The benefit of this formalism is that, instead of the entire spectrum density, S^L(omega) can be parametrized by a single parameter in the macroscopic resonant tunneling(MRT) experiment.","category":"page"},{"location":"#HOME","page":"Home","title":"HOME","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is a quantum annealing toolbox for Julia programming language.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package is written in Julia programming language. To learn more about Julia, please check its excellent doc pages. If you want to learn more about quantum annealing/adiabatic quantum computing, this review paper is a good place to start.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package has a core component package QTBase.jl, both of which are currently unregistered. To install, just run the following command inside the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(PackageSpec(url=\"https://github.com/USCqserver/QTBase.jl\", rev=\"master\"))\nPkg.add(PackageSpec(url=\"https://github.com/USCqserver/QuantumAnnealingTools.jl\", rev=\"master\"))","category":"page"},{"location":"","page":"Home","title":"Home","text":"It will install the packages directly from their github repos. This can also be done in Julia's Pkg REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(1.2) pkg> add https://github.com/USCqserver/QTBase.jl\n(1.2) pkg> add https://github.com/USCqserver/QuantumAnnealingTools.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"More information about Julia's package manager can be found at Pkg.jl.","category":"page"},{"location":"#Useful-Packages","page":"Home","title":"Useful Packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"It is recommended to install the following external packages:  ","category":"page"},{"location":"#[Plots.jl](https://github.com/JuliaPlots/Plots.jl)","page":"Home","title":"Plots.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Plots is a visualization interface and toolset for Julia. QuantumAnnealingTools.jl provides several plotting functionality by recipes to Plots.jl.","category":"page"},{"location":"#[DifferentialEquations.jl](http://docs.juliadiffeq.org/latest/)","page":"Home","title":"DifferentialEquations.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Even though QuantumAnnealingTools.jl can function without DifferentialEquations.jl, it needs to be loaded in order for the master equation solvers to work properly. For low dependency usage, replacing DifferentialEquations by OrdinaryDiffEq.jl will also work.","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In the first example, we solve a standard single qubit annealing problem with Hamiltonian","category":"page"},{"location":"","page":"Home","title":"Home","text":"    H(s) = A(s)σ_x + B(s)σ_z","category":"page"},{"location":"","page":"Home","title":"Home","text":"where A(s)=1-s and B(s)=s are usually known as annealing schedules. The general workflow is to define the Hamiltonian, construct the annealing process and then solve the system dynamics. The full code for this example is","category":"page"},{"location":"","page":"Home","title":"Home","text":"using QuantumAnnealingTools\nusing DifferentialEquations\ntf = 20\nu0 = PauliVec[1][2]\nH = DenseHamiltonian([(s)->1-s, (s)->s], [σx, σz], unit=:ħ)\nannealing = Annealing(H, u0)\nsol = solve_schrodinger(annealing, tf)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where the pieces are explained below.","category":"page"},{"location":"","page":"Home","title":"Home","text":"First, we need to load the package DifferentialEquations.jl for ODE solvers. Then we define the Hamiltonian of the annealing process. In this package, a time dependent Hamiltonian can be specified by a list of time dependent functions and a list of constant matrices","category":"page"},{"location":"","page":"Home","title":"Home","text":"H = DenseHamiltonian([(s)->1-s, (s)->s], [σx, σz], unit=:ħ)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The resulting Hamiltonian is an affine combination of the corresponding functions and matrices (1-s)σ_x + sσ_z. Then we define the initial state u0. Together with Hamiltonian, an annealing object can be constructed","category":"page"},{"location":"","page":"Home","title":"Home","text":"annealing = Annealing(H, u0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The final step is to solve system dynamics. In this example, directly solve the Schrodinger equation for a total annealing time tf.","category":"page"},{"location":"#Tutorials","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following tutorials will introduce you to the functionality of QuantumAnnealingTools.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"tutorials/math_symbol.md\",\n    \"tutorials/hamiltonians.md\",\n    \"tutorials/couplings.md\",\n    \"tutorials/bath.md\",\n    \"tutorials/annealing.md\"\n    ]\nDepth = 1","category":"page"},{"location":"lib/bath/#Bath-Module","page":"Bath","title":"Bath Module","text":"","category":"section"},{"location":"lib/bath/#Ohmic-Bath-Object","page":"Bath","title":"Ohmic Bath Object","text":"","category":"section"},{"location":"lib/bath/","page":"Bath","title":"Bath","text":"OhmicBath\nOhmic(η, fc, T)\ncorrelation(τ, params::OhmicBath)\npolaron_correlation(τ, a, params::OhmicBath)\nγ(w, params::OhmicBath)\nS(w, params::OhmicBath; atol=1e-7)\ninterpolate_spectral_density(ω_grid::AbstractRange{T}, params::OhmicBath) where T<:Number","category":"page"},{"location":"lib/bath/#Hybrid-Ohmic-Bath","page":"Bath","title":"Hybrid Ohmic Bath","text":"","category":"section"},{"location":"lib/bath/","page":"Bath","title":"Bath","text":"HybridOhmicBath\nHybridOhmic(W, η, fc, T)\npolaron_correlation(τ, bath::HybridOhmicBath, a=1)\nGₕ(ω, bath::HybridOhmicBath, a=1)\nGₗ(ω, bath::HybridOhmicBath, a=1)","category":"page"}]
}
