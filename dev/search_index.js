var documenterSearchIndex = {"docs":
[{"location":"tutorials/couplings/#Couplings","page":"Coupling","title":"Couplings","text":"","category":"section"},{"location":"tutorials/couplings/","page":"Coupling","title":"Coupling","text":"We start with a general form of system bath interaction Hamiltonian","category":"page"},{"location":"tutorials/couplings/","page":"Coupling","title":"Coupling","text":"  H_SB = sum_alpha S_alphaotimes B_alpha","category":"page"},{"location":"tutorials/couplings/","page":"Coupling","title":"Coupling","text":"and define the set of S_alpha_alpha whose corresponding B_Œ±_alpha are independent and identical(IID) as AbstractCouplings objects. Mathematically, every element in the same AbstractCouplings object shares the same bath correlation function. (For operators which couple to the same bath, they can be added together.) Two concrete types of AbstractCouplings are implemented ‚Äì ConstantCouplings and TimeDependentCouplings. The former represents time-independent operators. For example, the following codes","category":"page"},{"location":"tutorials/couplings/","page":"Coupling","title":"Coupling","text":"julia> coupling = ConstantCouplings([\"ZI\", \"IZ\"])","category":"page"},{"location":"tutorials/couplings/","page":"Coupling","title":"Coupling","text":"creates a set of two constant operators: ZI and IZ. The corresponding interaction Hamiltonian is","category":"page"},{"location":"tutorials/couplings/","page":"Coupling","title":"Coupling","text":"  H_SB = ZIB_1 + IZB_2","category":"page"},{"location":"tutorials/couplings/","page":"Coupling","title":"Coupling","text":"where B_1 and B_2 are IID. On the other hand, TimeDependentCouplings can be constructed with a two-step procedure. First, single TimeDependentCoupling needs to be constructed","category":"page"},{"location":"tutorials/couplings/","page":"Coupling","title":"Coupling","text":"c1 = TimeDependentCoupling([(s)->cos(s)], [œÉx]; unit=:ƒß)\nc2 = TimeDependentCoupling([(s)->sin(s)], [œÉz]; unit=:ƒß)","category":"page"},{"location":"tutorials/couplings/","page":"Coupling","title":"Coupling","text":"The above codes creates two time dependent coupling operators cos(s) X and sin(s) Z. Then, c1 and c2 can be grouped together to create the coupling set","category":"page"},{"location":"tutorials/couplings/","page":"Coupling","title":"Coupling","text":"coupling = TimeDependentCouplings(c1, c2)","category":"page"},{"location":"tutorials/couplings/","page":"Coupling","title":"Coupling","text":"Only ConstantCouplings and TimeDependentCouplings can be used to create an annealing process.","category":"page"},{"location":"tutorials/math_symbol/#Math-Symbols","page":"Math Symbol","title":"Math Symbols","text":"","category":"section"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"The package defines some commonly used mathematical symbols and operators. Some of its features include:","category":"page"},{"location":"tutorials/math_symbol/#Pauli-Matrices","page":"Math Symbol","title":"Pauli Matrices","text":"","category":"section"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"Single qubit Pauli matrices are defined by œÉx, œÉy, œÉz and œÉi. One can simply calculate the tensor product of single qubits Pauli matrices by","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"julia> œÉx‚äóœÉz\n4√ó4 Array{Complex{Float64},2}:\n 0.0+0.0im   0.0+0.0im  1.0+0.0im   0.0+0.0im\n 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -1.0+0.0im\n 1.0+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im\n 0.0+0.0im  -1.0+0.0im  0.0+0.0im  -0.0+0.0im","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"The eigenvectors of each Pauli matrices are also defined in constant PauliVec, where PauliVec[1],PauliVec[2],PauliVec[3] corresponds to eigenvectors of œÉx, œÉy, œÉz. Additionally, the first eigenvector is the one with positive eigenvalue","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"julia> œÉz*PauliVec[3][1] == PauliVec[3][1]\ntrue","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"Additionally, a sparse version of Pauli matrices are defined in spœÉx et al. They can be used to construct Hamiltonian in the form of sparse matrix.","category":"page"},{"location":"tutorials/math_symbol/#Construction-of-Multi-Qubits-Matrices","page":"Math Symbol","title":"Construction of Multi-Qubits Matrices","text":"","category":"section"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"The package provides various utility functions to construct multi-qubits matrices. For all the functions listed below, keyword argument sp can be set to generate sparse matrices.","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"The standard driver Hamiltonian in quantum annealing can be constructed with standard_driver","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"julia> standard_driver(2) == œÉx‚äóœÉi + œÉi‚äóœÉx\ntrue","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"and for sparse matrices","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"julia> standard_driver(2, sp=true) == spœÉx‚äóspœÉi + spœÉi‚äóspœÉx\ntrue","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"A multi-qubits matrix can be constructed from its string representation using q_translate","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"julia> q_translate(\"ZZ+0.5ZI-XZ\")\n4√ó4 Array{Complex{Float64},2}:\n  1.5+0.0im   0.0+0.0im  -1.0+0.0im   0.0+0.0im\n  0.0+0.0im  -0.5+0.0im   0.0+0.0im   1.0+0.0im\n -1.0+0.0im   0.0+0.0im  -1.5+0.0im  -0.0+0.0im\n  0.0+0.0im   1.0+0.0im  -0.0+0.0im   0.5+0.0im","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"Collective operators(same Pauli operator acting on each individual qubit) can be constructed with collective_operator","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"julia> collective_operator(\"z\", 3) == œÉz‚äóœÉi‚äóœÉi + œÉi‚äóœÉz‚äóœÉi + œÉi‚äóœÉi‚äóœÉz\ntrue","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"Single clause in multi-qubits Hamiltonian can be constructed by","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"julia> single_clause([\"z\",\"z\"], [2,3], -2, 4) == -2œÉi‚äóœÉz‚äóœÉz‚äóœÉi\ntrue","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"Local field terms of the form Œ£h·µ¢Z·µ¢ can be constructed with local_field_term","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"julia> local_field_term([1.0, 0.5], [1, 2], 2) == œÉz‚äóœÉi+0.5œÉi‚äóœÉz\ntrue","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"Two local terms of the form J·µ¢‚±ºZ·µ¢Z‚±º can be constructed with two_local_term","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"julia> two_local_term([1.0, 0.5], [[1,2], [1,3]], 3) == œÉz‚äóœÉz‚äóœÉi + 0.5œÉz‚äóœÉi‚äóœÉz\ntrue","category":"page"},{"location":"tutorials/math_symbol/#Construction-of-Multi-Qubits-states","page":"Math Symbol","title":"Construction of Multi-Qubits states","text":"","category":"section"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"The quantum state of spin system can be construct with q_translate_state","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"julia> q_translate_state(\"001\")\n8-element Array{Complex{Float64},1}:\n 0.0 + 0.0im\n 1.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im","category":"page"},{"location":"tutorials/math_symbol/","page":"Math Symbol","title":"Math Symbol","text":"In the string representation 0 and 1 represent the eigenstates of œÉ_z operator.","category":"page"},{"location":"tutorials/solver/#Open-System-Solvers","page":"Solver","title":"Open System Solvers","text":"","category":"section"},{"location":"tutorials/solver/","page":"Solver","title":"Solver","text":"QuantumAnnealingTools.jl provides several open quantum system solvers:","category":"page"},{"location":"tutorials/solver/#Redfield-equation","page":"Solver","title":"Redfield equation","text":"","category":"section"},{"location":"tutorials/solver/","page":"Solver","title":"Solver","text":"The interface to Redfield equation is:","category":"page"},{"location":"tutorials/solver/#Basic-usage","page":"Solver","title":"Basic usage","text":"","category":"section"},{"location":"tutorials/solver/","page":"Solver","title":"Solver","text":"The basic usage of Redfield solver is","category":"page"},{"location":"tutorials/solver/","page":"Solver","title":"Solver","text":"solve_redfield(\n    A::Annealing,\n    tf::Real,\n    unitary;\n    vectorize::Bool = false,\n    span_unit::Bool = false,\n    tstops = Float64[],\n    positivity_check::Bool = false,\n    kwargs...,\n)","category":"page"},{"location":"tutorials/solver/#QuantumAnnealingTools.solve_redfield-Tuple{Annealing,Real,Any}","page":"Solver","title":"QuantumAnnealingTools.solve_redfield","text":"solve_redfield(A, tf, unitary; vectorize, int_atol, int_rtol, Ta, kwargs...)\n\n\nSolve the time dependent Redfield equation for Annealing defined by A with total annealing time tf.\n\n...\n\nArguments\n\nA::Annealing: the Annealing object.\ntf::Real: the total annealing time.\nunitary: precalculated unitary of close system evolution.\nvectorize::Bool = false: whether to vectorize the density matrix.\nint_atol = 1e-8: the absolute error tolerance for integration.\nint_rtol = 1e-6: the relative error tolerance for integration.\nTa = tf: the time scale for backward integration.\nkwargs: other keyword arguments supported by DifferentialEquations.jl.\n\n...\n\n\n\n\n\n","category":"method"},{"location":"tutorials/solver/#Adiabatic-master-equation(AME)","page":"Solver","title":"Adiabatic master equation(AME)","text":"","category":"section"},{"location":"tutorials/solver/","page":"Solver","title":"Solver","text":"A good reference to adiabatic master equation is Albash, Tameem, et al. QuantumAnnealingTools.jl provides the following interfaces for AME solver:","category":"page"},{"location":"tutorials/solver/#Basic-usage-2","page":"Solver","title":"Basic usage","text":"","category":"section"},{"location":"tutorials/solver/","page":"Solver","title":"Solver","text":"The basic usage of AME solver is","category":"page"},{"location":"tutorials/solver/","page":"Solver","title":"Solver","text":"solve_ame(\n    A::Annealing,\n    tf::Real;\n    span_unit::Bool = false,\n    œâ_hint = [],\n    lambshift::Bool = true,\n    lvl = size(A.H, 1),\n    kwargs...,\n)","category":"page"},{"location":"tutorials/solver/#QuantumAnnealingTools.solve_ame-Tuple{Annealing,Real}","page":"Solver","title":"QuantumAnnealingTools.solve_ame","text":"solve_ame(A, tf; tspan, œâ_hint, lambshift, lvl, vectorize, kwargs...)\n\n\nSolve the adiabatic master equation for Annealing defined by A with total annealing time tf.\n\n...\n\nArguments\n\nA::Annealing: the Annealing object.\ntf::Real: the total annealing time.\ntspan = (0, tf): time interval to solve.\nœâ_hint=[] : grid for precalculating the lambshift; skip the precalculation if empty.\n'lambshift::Bool=true' : whether to include Lambshift in the calculation.\nlvl::Int=size(A.H, 1) : number of levels to keep. The default value is the dimension for the Hamiltonian.\nvectorize::Bool = false: whether to vectorize the density matrix.\nkwargs : other keyword arguments supported by DifferentialEquations.jl.\n\n...\n\n\n\n\n\n","category":"method"},{"location":"tutorials/solver/#Additional-solver-options","page":"Solver","title":"Additional solver options","text":"","category":"section"},{"location":"tutorials/solver/","page":"Solver","title":"Solver","text":"The extra keyword arguments kwargs will be directly passed to ODE solve interface. So every solver option is supported. However, because of the current implementation, several keyword arguments are strongly recommended:","category":"page"},{"location":"tutorials/solver/","page":"Solver","title":"Solver","text":"alg=Tsit5(): This set the algorithm to Tsitouras 5/4 Runge-Kutta method, which performs well for most problems. You can find a list of the available solver algorithms here. The implicit methods are only supported when the vectorize is set to true.\nsaveat: This argument denotes specific times to save the solution at, during the solving phase. It overrides the save_everystep keyword argument.\ntstops: This argument denotes extra times that the timestepping algorithm must step to. It will increase the accuracy if the algorithm is instructed to step to the know singularities of the problem.\nsave_everystep: Whether to save the result at every step. You can save the memory by setting it to false.","category":"page"},{"location":"tutorials/solver/#Examples","page":"Solver","title":"Examples","text":"","category":"section"},{"location":"tutorials/solver/","page":"Solver","title":"Solver","text":"An tutorial notebook for solving both Redfield and adiabatic master equation can be found here.","category":"page"},{"location":"tutorials/annealing/#Annealing","page":"Annealing","title":"Annealing","text":"","category":"section"},{"location":"tutorials/annealing/","page":"Annealing","title":"Annealing","text":"This package implements AbstractFactory pattern for potential quantum annealing process via an abstract type AbstractAnnealing. A complete quantum annealing process is assembled from the following parts:","category":"page"},{"location":"tutorials/annealing/","page":"Annealing","title":"Annealing","text":"Hamiltonian: Any object implements the AbstractHamiltonian interface\nInitial state: A state vector/density matrix\n(Optional)System bath coupling ‚Äì system part\n(Optional)System bath coupling ‚Äì bath part\n(Optional)Additional control protocols","category":"page"},{"location":"tutorials/annealing/","page":"Annealing","title":"Annealing","text":"For example, the following code block construct a standard single qubit annealing process","category":"page"},{"location":"tutorials/annealing/","page":"Annealing","title":"Annealing","text":"H = DenseHamiltonian([(s)->1-s, (s)->s], -[œÉx, œÉz]/2, unit=:ƒß)\nu0 = PauliVec[1][1]\ncoupling = ConstantCouplings([\"Z\"], unit=:ƒß)\nbath = Ohmic(1e-4, 4, 16)\nannealing = Annealing(H, u0; coupling=coupling, bath=bath)","category":"page"},{"location":"tutorials/annealing/","page":"Annealing","title":"Annealing","text":"with total Hamiltonian","category":"page"},{"location":"tutorials/annealing/","page":"Annealing","title":"Annealing","text":"H(s) = -(1-s)fracsigma_x2 - sfracsigma_z2 + sigma_z otimes B + H_B","category":"page"},{"location":"tutorials/annealing/","page":"Annealing","title":"Annealing","text":"where B H_B forms an Ohmic bath.","category":"page"},{"location":"tutorials/hamiltonians/#Hamiltonians","page":"Hamiltonian","title":"Hamiltonians","text":"","category":"section"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"A Hamiltonian is basically a time-dependent matrix. The package currently offers two ways to construct a Hamiltonian object. Before introducing those constructors, let's discuss the unit of Hamiltonian first.","category":"page"},{"location":"tutorials/hamiltonians/#Unit","page":"Hamiltonian","title":"Unit","text":"","category":"section"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"From the Schrodinger equation","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"  ihbar lvert Phi rangle = H lvert Phi rangle","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"we know the Hamiltonian can be normalized by H  hbar. If we set h=1, then what appears on the RHS of Schrodinger equation is 2pi H where H has the unit of frequency. We set this unit to the natural unit of superconducting qubits ‚Äì GHz.","category":"page"},{"location":"tutorials/hamiltonians/#Construction","page":"Hamiltonian","title":"Construction","text":"","category":"section"},{"location":"tutorials/hamiltonians/#Affine-Operator","page":"Hamiltonian","title":"Affine Operator","text":"","category":"section"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"For fs = [f1,f2,...,fn] and Ms = [M1,M2,...,Mn] where each of the fi and Mi are Function(or callable object) and Matrix, the following constructor:","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"function TypeHamiltonian(fs,Ms)","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"builds an time dependent Hamiltonian H = f_1(t)M_1 + f_2(t)M_2 +  + f_n(t)M_n. The Type should be changed to a specific descriptor of the Hamiltonian. For example, a Hamiltonian consisted of dense matrices can be constructed with DenseHamiltonian","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"julia> H = DenseHamiltonian([(s)->1-s, (s)->s], [œÉx, œÉz])","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"The DenseHamiltonian constructor creates a standard single qubit annealing Hamiltonian of the form H(s)=(1-s)œÉ_x+sœÉ_z, whose default unit is GHz (h=1). Internally, this package always store the value of Hhbar. So any object created with default unit will be scaled by 2œÄ. You can set the unit to ƒß=1 by using the keyword argument unit","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"julia> H_ƒß  = DenseHamiltonian([(s)->1-s, (s)->s], [œÉx, œÉz]; unit=:ƒß)","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"(Setting unit to :ƒß means the inputs of the constructor is already Hhbar.) To obtain the value of Hamiltonian at given s in consistent units, it is recommended to use function evaluate","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"julia> evaluate(H, 0.5)\n2√ó2 Array{Complex{Float64},2}:\n  0.5+0.0im  -0.5+0.0im\n -0.5+0.0im  -0.5+0.0im","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"It always returns the Hamiltonian value in GHz. Calling H directly like a Function will return numerical value of Hhbar","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"julia> H(0.5) == 2œÄ*(œÉx + œÉz)/2\ntrue","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"There are two additional constructors: SparseHamiltonian and AdiabaticFrameHamiltonian, which construct sparse Hamiltonians and Hamiltonians in adiabatic frame respectively.","category":"page"},{"location":"tutorials/hamiltonians/#Interpolating","page":"Hamiltonian","title":"Interpolating","text":"","category":"section"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"The second method is to construct the Hamiltonian by interpolating gridded values","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"  H(s_1) H(s_2) ldots","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"Internally, the package rely on Interpolations.jl for fast interpolating. The syntax for constructing interpolation Hamiltonian object is","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"H_interp = InterpDenseHamiltonian(s_axis, H_list)\nH_interp = InterpSparseHamiltonian(s_axis, H_list)","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"where s_axis and H_list are the grid points and corresponding Hamiltonian values. The constructors also take keyword argument method, order and unit. method and order specify the internal interpolation method. For dense Hamiltonians, both BSpline of order 0-3 and Gridded of order 0-1 are supported. For sparse Hamiltonians, only Gridded of order 0-1 is supported.","category":"page"},{"location":"tutorials/hamiltonians/#Eigendecomposition","page":"Hamiltonian","title":"Eigendecomposition","text":"","category":"section"},{"location":"tutorials/hamiltonians/#Plotting","page":"Hamiltonian","title":"Plotting","text":"","category":"section"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"This package can also interact with Plots.jl to provide convenient ways for visualizing the spectrum of any given Hamiltonians. For example","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"using Plots\nplot(H, 0:0.01:1, 2)","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"will produce the following figure. The second argument 0:0.01:1 is the x_axis values and the third argument 2 is the number of levels to plot. The third argument can also be a list of levels.","category":"page"},{"location":"tutorials/hamiltonians/","page":"Hamiltonian","title":"Hamiltonian","text":"(Image: plot_hamiltonian_example)","category":"page"},{"location":"lib/QTBase/","page":"Base","title":"Base","text":"Modules = [QTBase]\nPrivate = false","category":"page"},{"location":"lib/QTBase/#QTBase.PauliVec","page":"Base","title":"QTBase.PauliVec","text":"PauliVec\n\nConstants for the eigenvectors of single qubit Pauli matrices. Indices 1, 2 and 3 corresponds to the eigenvectors of œÉ_x, œÉ_y and œÉ_z.\n\nExamples\n\njulia> œÉx*PauliVec[1][1] == PauliVec[1][1]\ntrue\n\n\n\n\n\n","category":"constant"},{"location":"lib/QTBase/#QTBase.AbstractAnnealing","page":"Base","title":"QTBase.AbstractAnnealing","text":"abstract type AbstractAnnealing\n\nBase for types defining quantum annealing process.\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.AbstractBath","page":"Base","title":"QTBase.AbstractBath","text":"abstract type AbstractBath\n\nBase for types defining bath object.\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.AbstractCouplings","page":"Base","title":"QTBase.AbstractCouplings","text":"abstract type AbstractCouplings\n\nBase for types defining system bath coupling operators in open quantum system models.\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.AbstractDenseHamiltonian","page":"Base","title":"QTBase.AbstractDenseHamiltonian","text":"abstract type AbstractDenseHamiltonian <: AbstractHamiltonian{T<:Number}\n\nBase for types defining Hamiltonians using dense matrices.\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.AbstractHamiltonian","page":"Base","title":"QTBase.AbstractHamiltonian","text":"abstract type AbstractHamiltonian\n\nSuptertype for Hamiltonians with elements of type T. Any Hamiltonian object should implement two interfaces: H(t) and H(du, u, p, t).\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.AbstractLiouvillian","page":"Base","title":"QTBase.AbstractLiouvillian","text":"abstract type AbstractLiouvillian\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.AbstractSparseHamiltonian","page":"Base","title":"QTBase.AbstractSparseHamiltonian","text":"abstract type AbstractSparseHamiltonian <: AbstractHamiltonian{T<:Number}\n\nBase for types defining Hamiltonians using sparse matrices.\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.AdiabaticFrameHamiltonian","page":"Base","title":"QTBase.AdiabaticFrameHamiltonian","text":"struct AdiabaticFrameHamiltonian{T} <: AbstractDenseHamiltonian{T}\n\nDefines a time dependent Hamiltonian in adiabatic frame.\n\nFields\n\ngeometric\nGeometric part\ndiagonal\nAdiabatic part\nsize\nSize of the Hamiltonian\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.AdiabaticFrameHamiltonian-Tuple{Any,Any}","page":"Base","title":"QTBase.AdiabaticFrameHamiltonian","text":"function AdiabaticFrameHamiltonian(œâfuns, geofuns)\n\nConstructor of adiabatic frame Hamiltonian. œâfuns is a 1-D array of functions which specify the eigen energies (in GHz) of the Hamiltonian. geofuns is a 1-D array of functions which specifies the geometric phases of the Hamiltonian. geofuns can be thought as a flattened lower triangular matrix (without diagonal elements) in column-major order.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.Annealing","page":"Base","title":"QTBase.Annealing","text":"mutable struct Annealing{hType, uType} <: AbstractAnnealing{hType,uType}\n\nDefines a quantum annealing process.\n\nFields\n\nH\nHamiltonian for the annealing.\nu0\nInitial state for the annealing.\nannealing_parameter\nFunction of annealing parameter s wrt to t\ninteractions\nA system bath interaction set.\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.ConstantCouplings","page":"Base","title":"QTBase.ConstantCouplings","text":"struct ConstantCouplings <: AbstractCouplings\n\nDefines constant system bath coupling operators.\n\nFields\n\nmats\n1-D array for independent coupling operators\nstr_rep\nString representation for the coupling (for display purpose)\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.ConstantCouplings-Union{Tuple{Array{T,1}}, Tuple{T}} where T<:AbstractString","page":"Base","title":"QTBase.ConstantCouplings","text":"function ConstantCouplings(c::Vector{T}; sp = false, unit=:h) where T <: AbstractString\n\nIf the first argument is a 1-D array of strings. The constructor will automatically construct the matrics represented by the string representations.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.ConstantCouplings-Union{Tuple{Union{Array{Array{T,2},1}, Array{SparseMatrixCSC{T,Int64},1}}}, Tuple{T}} where T<:Number","page":"Base","title":"QTBase.ConstantCouplings","text":"function ConstantCouplings(mats; str_rep=nothing, unit=:h)\n\nConstructor of ConstantCouplings object. mats is 1-D array of matrices. str_rep is the optional string representation of the coupling terms. unit is the unit one ‚Äì :h or :ƒß. The mats will be scaled by 2œÄ is unit is :h.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.CustomBath","page":"Base","title":"QTBase.CustomBath","text":"mutable struct CustomBath <: AbstractBath\n\nAn custum bath object defined by the two-point correlation function and the corresponding spectrum.\n\ncfun\ncorrelation function\nŒ≥\nspectrum\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.CustomCouplings","page":"Base","title":"QTBase.CustomCouplings","text":"struct CustomCouplings <: AbstractTimeDependentCouplings\n\nCustomCouplings is a container for any user defined coupling operators.\n\nFields\n\ncoupling\nA 1-D array of callable objects that returns coupling matrices\nsize\nSize of the coupling operator\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.CustomDenseHamiltonian","page":"Base","title":"QTBase.CustomDenseHamiltonian","text":"struct CustomDenseHamiltonian{T<:Number, in_place} <: AbstractDenseHamiltonian{T<:Number}\n\nDefines a time dependent Hamiltonian object with custom function.\n\nFields\n\nf\nFunction for the Hamiltonian H(s)\nu_cache\nInternal cache\nsize\nSize\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.DaviesGenerator","page":"Base","title":"QTBase.DaviesGenerator","text":"struct DaviesGenerator <: AbstractLiouvillian\n\nDefines Davies generator\n\nFields\n\ncoupling\nSystem bath coupling operators\nŒ≥\nSpectrum density\nS\nLambshift spectrum density\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.DenseHamiltonian","page":"Base","title":"QTBase.DenseHamiltonian","text":"struct DenseHamiltonian{T<:Number} <: AbstractDenseHamiltonian{T<:Number}\n\nDefines a time dependent Hamiltonian object with dense Matrices.\n\nFields\n\nf\nList of time dependent functions\nm\nList of constant matrices\nu_cache\nInternal cache\nsize\nSize\nEIGS\nEigen decomposition routine\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.DenseHamiltonian-Tuple{Any,Any}","page":"Base","title":"QTBase.DenseHamiltonian","text":"DenseHamiltonian(funcs, mats; unit, EIGS)\n\n\nConstructor of DenseHamiltonian object. funcs and mats are a list of time dependent functions and the corresponding matrices. unit is the unit one ‚Äì :h or :ƒß. The mats will be scaled by 2œÄ if unit is :h.\n\nEIGS is the initializer for the eigen decomposition routine for the Hamiltonian. It should return a function of signature: (H, s, lvl) -> (w, v). The default method EIGEN_DEFAULT will use LAPACK routine.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.DenseHamiltonian-Tuple{Real}","page":"Base","title":"QTBase.DenseHamiltonian","text":"function (h::DenseHamiltonian)(s::Real)\n\nCalling the Hamiltonian returns the value 2œÄH(s). The argument s is in the unitless time. The returned matrix is in angular frequency.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.EnsembleFluctuator","page":"Base","title":"QTBase.EnsembleFluctuator","text":"struct EnsembleFluctuator{T} <: AbstractBath\n\nAn ensemble of random telegraph noise.\n\nf\nA list of RTNs\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.Fluctuators","page":"Base","title":"QTBase.Fluctuators","text":"mutable struct Fluctuators <: AbstractLiouvillian\n\nDefines a fluctuator ensemble controller\n\nFields\n\ncoupling\nsystem-bath coupling operator\ndist\nwaitting time distribution for every fluctuators\nb0\ncache for each fluctuator value\nnext_idx\nindex of the fluctuator to be flipped next\nnext_œÑ\ntime interval for next flip event\nn\nnoise value\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.InplaceUnitary","page":"Base","title":"QTBase.InplaceUnitary","text":"struct InplaceUnitary\n\nA tag for inplace unitary function. func(cache, t) is the actual inplace update function.\n\nFields\n\nfunc\ninplace update function\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.Interaction","page":"Base","title":"QTBase.Interaction","text":"struct Interaction\n\nAn object to hold system operator and the corresponding bath object.\n\ncoupling\nsystem operator\nbath\nbath coupling to the system operator\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.InteractionSet","page":"Base","title":"QTBase.InteractionSet","text":"struct InteractionSet{T<:Tuple}\n\nAn container for different system-bath interactions.\n\ninteractions\nA tuple of Interaction\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.InterpDenseHamiltonian","page":"Base","title":"QTBase.InterpDenseHamiltonian","text":"struct InterpDenseHamiltonian{T} <: AbstractDenseHamiltonian{T}\n\nDefines interpolating DenseHamiltonian object\n\nFields\n\ninterp_obj\nInterpolating object\nsize\nSize\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.InterpSparseHamiltonian","page":"Base","title":"QTBase.InterpSparseHamiltonian","text":"struct InterpSparseHamiltonian{T} <: AbstractSparseHamiltonian{T}\n\nDefines interpolating SparseHamiltonian object\n\nFields\n\ninterp_obj\nInterpolating object\nsize\nSize\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.ODEParams","page":"Base","title":"QTBase.ODEParams","text":"struct ODEParams\n\nDefines a complete set of ODE parameters, which includes Hamiltonian, total annealing time, open system and control objects.\n\nFields\n\nL\nHamiltonian\ntf\nTotal annealing time\nannealing_parameter\nFunction to convert physical time to annealing parameter\ncontrol\nAnnealing control object\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.OhmicBath","page":"Base","title":"QTBase.OhmicBath","text":"OhmicBath\n\nOhmic bath object to hold a particular parameter set.\n\nFields\n\nŒ∑ ‚Äì strength.\nœâc ‚Äì cutoff frequence.\nŒ≤ ‚Äì inverse temperature.\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.OpenSysOp","page":"Base","title":"QTBase.OpenSysOp","text":"struct OpenSysOp{diagonalization, adiabatic_frame}\n\nDefines an open system DiffEqOperator in the specific basis.\n\nFields\n\nH\nHamiltonian\nopensys\nOpen system part\nlvl\nLevels to truncate\nu_cache\nInternal cache\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.ProjectedCoupling","page":"Base","title":"QTBase.ProjectedCoupling","text":"struct ProjectedCoupling\n\nObject for a projected coupling parameterized by NIBA parameters. This object holds the numerical values at gridded points.\n\nFields\n\ns\nTime grid (unitless) for projection\na\n(œÉ_m - œÉ_n)^2\nb\nœÉ_mn^2\nc\nœÉ_mn(œÉ_m-œÉ_n)\nd\nœÉ_mn(œÉ_m+œÉ_n)\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.ProjectedSystem","page":"Base","title":"QTBase.ProjectedSystem","text":"struct ProjectedSystem\n\nObject for a projected low level system. The projection is only valid for real Hamiltonians.\n\nFields\n\ns\nTime grid (unitless) for projection\nev\nEnergy values for different levels\ndŒ∏\nGeometric terms\nop\nProjected system bath interaction operators\nref\nEnergy eigenstates at the final time\nlvl\nNumber of levels being kept\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.ProjectedTG","page":"Base","title":"QTBase.ProjectedTG","text":"struct ProjectedTG\n\nObject for a projected system Hamiltonian parameterized by NIBA parameters. This object holds the numerical values at gridded points.\n\nFields\n\ns\nTime grid (unitless) for projection\nœâ\nFrequencies of given basis states\nT\nAdiabatic part\nG\nGeometric phase\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.RedfieldGenerator","page":"Base","title":"QTBase.RedfieldGenerator","text":"struct RedfieldGenerator <: AbstractLiouvillian\n\nDefines RedfieldGenerator.\n\nFields\n\nops\nsystem-bath coupling operator\nunitary\nclose system unitary\ncfun\nbath correlation function\natol\nabsolute error tolerance for integration\nrtol\nrelative error tolerance for integration\nUt\ncache matrix for inplace unitary\nUœÑ\ncache matrix for inplace unitary\nŒõ\ncache matrix for integration\nTa\ntf minus coarse grain time scale\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.SparseHamiltonian","page":"Base","title":"QTBase.SparseHamiltonian","text":"struct SparseHamiltonian{T<:Number} <: AbstractSparseHamiltonian{T<:Number}\n\nDefines a time dependent Hamiltonian object with sparse Matrices.\n\nFields\n\nf\nList of time dependent functions\nm\nList of constant matrices\nu_cache\nInternal cache\nsize\nSize\nEIGS\nEigen decomposition routine\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.SparseHamiltonian-Tuple{Any,Any}","page":"Base","title":"QTBase.SparseHamiltonian","text":"SparseHamiltonian(funcs, mats; unit, EIGS)\n\n\nConstructor of SparseHamiltonian object. funcs and mats are a list of time dependent functions and the corresponding matrices. unit is the unit one ‚Äì :h or :ƒß. The mats will be scaled by 2œÄ is unit is :h.\n\nEIGS is the initializer for the eigen decomposition routine for the Hamiltonian. It should return a function of signature: (H, s, lvl) -> (w, v). The default method EIGEN_DEFAULT will use LAPACK routine.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.SparseHamiltonian-Tuple{Real}","page":"Base","title":"QTBase.SparseHamiltonian","text":"function (h::SparseHamiltonian)(t::Real)\n\nCalling the Hamiltonian returns the value 2œÄH(t).\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.TimeDependentCoupling","page":"Base","title":"QTBase.TimeDependentCoupling","text":"struct TimeDependentCoupling\n\nDefines a single time dependent system bath coupling operator. It is defined as S(s)=f(s)M.  Keyword argument unit set the unit one ‚Äì h or ƒß.\n\nFields\n\nfuncs\n1-D array of time dependent functions\nmats\n1-D array of constant matrics\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.TimeDependentCouplings","page":"Base","title":"QTBase.TimeDependentCouplings","text":"struct TimeDependentCouplings <: AbstractTimeDependentCouplings\n\nDefines an 1-D array of time dependent system bath coupling operators.\n\nFields\n\ncoupling\nA tuple of single TimeDependentCoupling operators\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.ŒìMatrix","page":"Base","title":"QTBase.ŒìMatrix","text":"struct ŒìMatrix\n\nDefines rates of Davies form ME acting on the diagonal elements.\n\nFields\n\nm\ninterpolated Œì matrix\nlvl\nlevels of the system\n\n\n\n\n\n","category":"type"},{"location":"lib/QTBase/#QTBase.:‚äó","page":"Base","title":"QTBase.:‚äó","text":"‚äó(A, B)\n\nCalculate the tensor product of A and B.\n\nExamples\n\njulia> œÉx‚äóœÉz\n4√ó4 Array{Complex{Float64},2}:\n 0.0+0.0im   0.0+0.0im  1.0+0.0im   0.0+0.0im\n 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -1.0+0.0im\n 1.0+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im\n 0.0+0.0im  -1.0+0.0im  0.0+0.0im  -0.0+0.0im\n\n\n\n\n\n","category":"function"},{"location":"lib/QTBase/#QTBase.EIGEN_DEFAULT-Tuple{AbstractDenseHamiltonian}","page":"Base","title":"QTBase.EIGEN_DEFAULT","text":"function EIGEN_DEFAULT(H)\n\nThe default initializer for eigen factorization method. It returns a function of signature: (H, s, lvl) -> (w, v). H is the Hamiltonian object, s is the dimensionless time and lvl is the energy levels to keep. This default initializer will use LAPACK routine for both dense and sparse matrices.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.EIGEN_DEFAULT-Tuple{Any}","page":"Base","title":"QTBase.EIGEN_DEFAULT","text":"function EIGEN_DEFAULT(u_cache)\n\nThe default initializer for eigen factorization method. It returns a function of signature: (H, s, lvl) -> (w, v). u_cache is the cache for Hamiltonian object, s is the time argument for the Hamiltonian and lvl is the energy levels to keep. This default initializer will use LAPACK routine for both dense and sparse matrices.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.Ohmic-Tuple{Any,Any,Any}","page":"Base","title":"QTBase.Ohmic","text":"Ohmic(Œ∑, fc, T)\n\n\nConstruct OhmicBath from parameters with physical unit: Œ∑‚Äìunitless interaction strength; fc‚Äìcutoff frequency in GHz; T‚Äìtemperature in mK.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.S-Tuple{Any,OhmicBath}","page":"Base","title":"QTBase.S","text":"S(w, bath; atol)\n\n\nCalculate the Lamb shift of Ohmic spectrum. atol is the absolute tolerance for Cauchy principal value integral.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.ame_jump-Tuple{OpenSysOp{true,false},Any,Any,Real}","page":"Base","title":"QTBase.ame_jump","text":"ame_jump(A::OpenSysOp, u, p, t::Real)\n\nCalculate the jump operator for the OpenSysOp at time t.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.check_positivity-Tuple{AbstractArray{T,2} where T}","page":"Base","title":"QTBase.check_positivity","text":"check_positivity(m)\n\nCheck if matrix m is positive. Return true is the minimum eigenvalue of m is greater than or equal to 0.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.check_unitary-Tuple{AbstractArray{T,2} where T}","page":"Base","title":"QTBase.check_unitary","text":"check_unitary(ùêî; rtol, atol)\n\n\nTest if ùêî is a unitary matrix. The function checks how close both ùêîùêî^ and ùêî^ùêî are to I, with relative and absolute error given by rtol, atol.\n\nExamples\n\njulia> check_unitary(exp(-1.0im*5*0.5*œÉx))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.coarse_grain_timescale-Tuple{AbstractBath,Any}","page":"Base","title":"QTBase.coarse_grain_timescale","text":"coarse_grain_timescale(bath, lim; rtol, atol)\n\n\nCalculate the optimal coarse grain time scale T_a for a total evolution time lim. atol and rtol are the absolute and relative error for the integration.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.collective_coupling-Tuple{Any,Any}","page":"Base","title":"QTBase.collective_coupling","text":"function collective_coupling(op, num_qubit; sp=false)\n\nCreate ConstantCouplings object with operator op on each qubits. op is the string representation of one of the Pauli matrices. num_qubit is the total number of qubits. sp set whether to use sparse matrices. unit set the unit one ‚Äì h or ƒß.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.collective_operator-Tuple{Any,Any}","page":"Base","title":"QTBase.collective_operator","text":"collective_operator(op, num_qubit; sp=false)\n\nConstruct the collective operator for a system of num_qubit qubits. op is the name of the collective Pauli matrix. For example, the following code construct an IZ + ZI matrix. Generate sparse matrix when sp is set to true.\n\nExamples\n\njulia> collective_operator(\"z\", 2)\n4√ó4 Array{Complex{Float64},2}:\n 2.0+0.0im  0.0+0.0im  0.0+0.0im   0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im   0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im   0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  -2.0+0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.concatenate-Tuple","page":"Base","title":"QTBase.concatenate","text":"function concatenate(args...)\n\nConcatenate multiple ProjectedSystem objects into a single one. The arguments need to be in time order. The ref field of the new object will have the same value as the last input arguments.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.construct_interpolations-Union{Tuple{N}, Tuple{T}, Tuple{S}, Tuple{AbstractRange{S},AbstractArray{T,N}}} where N where T<:Number where S<:Real","page":"Base","title":"QTBase.construct_interpolations","text":"function construct_interpolations(x, y; method = \"BSpline\", order = 2, extrapolation = \"line\")\n\nConstruct interpolation of N-D array y along its last dimension on grid x. method specifies the interpolation algorithm, which can be either \"BSpline\" or \"Gridded\". If x is an AbstractRange, the default method is \"BSpline\", otherwise the default method is \"Gridded\". order is the interpolation order. If x is AbstractRange, the default order is 2, otherwise the default order is 1. extrapolation specifies the extrapolation methods.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.eigen_decomp-Tuple{AbstractHamiltonian,AbstractArray{Float64,1}}","page":"Base","title":"QTBase.eigen_decomp","text":"eigen_decomp(H, s; lvl)\n\n\nCalculate the eigen value decomposition of the Hamiltonian H at an array of time points s. The output keeps the lowest lvl eigenstates and their corresponding eigenvalues. Output (vals, vecs) have the dimensions of (lvl, length(s)) and (size(H, 1), lvl, length(s)) respectively.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.eigen_decomp-Tuple{AbstractHamiltonian,Any}","page":"Base","title":"QTBase.eigen_decomp","text":"eigen_decomp(H, s; lvl)\n\n\nCalculate the eigen value decomposition of the Hamiltonian H at time s. Keyword argument lvl specifies the number of levels to keep in the output. w is a vector of eigenvalues and v is a matrix of the eigenvectors in the columns. (The kth eigenvector can be obtained from the slice v[:, k].) w will be in unit of GHz.\n\neig_init is the initializer for eigen factorization routine. It returns a function of signature: (H, s, lvl) -> (w, v). The default initializer EIGEN_DEFAULT will use LAPACK routine for both dense and sparse matrices.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.evaluate-Tuple{AbstractHamiltonian,Any}","page":"Base","title":"QTBase.evaluate","text":"evaluate(H::AbstractHamiltonian, s)\n\nEvaluate the time dependent Hamiltonian at time s with the unit of GHz\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.evaluate-Tuple{AdiabaticFrameHamiltonian,Any,Any}","page":"Base","title":"QTBase.evaluate","text":"function evaluate(H::AdiabaticFrameHamiltonian, s, tf)\n\nEvaluate the adiabatic frame Hamiltonian at (unitless) time s, with total annealing time tf (in the unit of ns). The final result is given in unit of GHz.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.freq_2_temperature-Tuple{Any}","page":"Base","title":"QTBase.freq_2_temperature","text":"freq_2_temperature(freq)\n\nConvert frequency in GHz to temperature in mK.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.get_dŒ∏","page":"Base","title":"QTBase.get_dŒ∏","text":"get_dŒ∏(sys::ProjectedSystem, i=1, j=2)\n\nGet the geometric terms between i, j energy levels from ProjectedSystem.\n\n\n\n\n\n","category":"function"},{"location":"lib/QTBase/#QTBase.gibbs_state-Tuple{Any,Any}","page":"Base","title":"QTBase.gibbs_state","text":"gibbs_state(h, Œ≤)\n\nCalculate the Gibbs state of the matrix h at temperature T (mK).\n\nExamples\n\njulia> gibbs_state(œÉz, 10)\n2√ó2 Array{Complex{Float64},2}:\n 0.178338+0.0im       0.0+0.0im\n      0.0+0.0im  0.821662+0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.gradient-Tuple{Any,Number}","page":"Base","title":"QTBase.gradient","text":"function gradient(itp, s)\n\nCalculate the gradient of itp at s.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.hamming_weight_operator-Tuple{Int64,String}","page":"Base","title":"QTBase.hamming_weight_operator","text":"hamming_weight_operator(num_qubit::Int64, op::String; sp=false)\n\nConstruct the Hamming weight operator for system of size num_qubit. The type of the Hamming weight operator is specified by op: \"x\", \"y\" or \"z\". Generate sparse matrix when sp is set to true.\n\nExamples\n\njulia> hamming_weight_operator(2,\"z\")\n4√ó4 Array{Complex{Float64},2}:\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  2.0+0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.inst_population-Tuple{Any,Any,AbstractHamiltonian}","page":"Base","title":"QTBase.inst_population","text":"inst_population(s, states, H; lvl)\n\n\nFor a time series quantum states given by states, whose time points are given by s, calculate the population of instantaneous eigenstates of H. The levels of the instantaneous eigenstates are specified by lvl, which can be any slice index.\n\neig_init is the initializer for eigen factorization routine. It returns a function of signature: (H, s, lvl) -> (w, v). The default initializer EIGEN_DEFAULT will use LAPACK routine for both dense and sparse matrices.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.local_field_term-Tuple{Any,Any,Any}","page":"Base","title":"QTBase.local_field_term","text":"local_field_term(h, idx, num_qubit; sp=false)\n\nConstruct local Hamiltonian of the form h·µ¢œÉ·µ¢·∂ª. idx is the index of all local field terms and h is a list of the corresponding weights. num_qubit is the total number of qubits. Generate sparse matrix when sp is set to true.\n\nExamples\n\njulia> local_field_term([1.0, 0.5], [1, 2], 2) == œÉz‚äóœÉi+0.5œÉi‚äóœÉz\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.log_uniform-Tuple{Any,Any,Any}","page":"Base","title":"QTBase.log_uniform","text":"log_uniform(a, b, num; base)\n\n\nGenerate a log-uniformly distributed array with num elements between a and b. The base of log is base with default value 10.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.low_level_matrix-Tuple{Any,Any}","page":"Base","title":"QTBase.low_level_matrix","text":"low_level_matrix(M, lvl)\n\nCalculate the matrix M projected to lower energy subspace containing lvl energy lvl.\n\nExamples\n\njulia> low_level_matrix(œÉx‚äóœÉx, 2)\n4√ó4 Array{Complex{Float64},2}:\n -0.5+0.0im   0.0+0.0im   0.0+0.0im   0.5+0.0im\n  0.0+0.0im  -0.5+0.0im   0.5+0.0im   0.0+0.0im\n  0.0+0.0im   0.5+0.0im  -0.5+0.0im   0.0+0.0im\n  0.5+0.0im   0.0+0.0im   0.0+0.0im  -0.5+0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.matrix_decompose-Tuple{AbstractArray{T,2} where T,Array{#s16,1} where #s16<:(AbstractArray{T,2} where T)}","page":"Base","title":"QTBase.matrix_decompose","text":"matrix_decompose(mat, basis)\n\n\nDecompse matrix mat onto matrix basis basis\n\nExamples\n\njulia> matrix_decompose(1.0*œÉx+2.0*œÉy+3.0*œÉz, [œÉx,œÉy,œÉz])\n3-element Array{Complex{Float64},1}:\n 1.0 + 0.0im\n 2.0 + 0.0im\n 3.0 + 0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.partial_trace-Tuple{Array{T,2} where T,Any}","page":"Base","title":"QTBase.partial_trace","text":"partial_trace(œÅ, qubit_2_keep)\n\n\nCalculate the partial trace of the density matrix œÅ. qubit_2_keep is an array of qubit indices to keep.\n\nExamples\n\njulia> œÅ1 = [0.4 0.5; 0.5 0.6]; œÅ2 = [0.5 0; 0 0.5];\njulia> partial_trace(œÅ1‚äóœÅ2, [1])\n2√ó2 Array{Float64,2}:\n 0.4  0.5\n 0.5  0.6\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.project_to_lowlevel-Union{Tuple{S}, Tuple{T}, Tuple{AbstractHamiltonian{T},Any,Any,AbstractArray{S,1}}} where S<:Real where T<:Real","page":"Base","title":"QTBase.project_to_lowlevel","text":"project_to_lowlevel(H::AbstractHamiltonian{T}, dH, coupling, s_axis; lvl=2, eig_init = EIGEN_DEFAULT)\n\nProject a Hamiltonian H to the lowest lvl level subspace. dH is the derivative of Hamiltonian and coupling is the system-bath interaction operator. They should be callable with a single argument ‚Äì annealing parameter s. s_axis is the (unitless) times to calculate the projection.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.q_translate-Tuple{String}","page":"Base","title":"QTBase.q_translate","text":"q_translate(h::String)\n\nConvert a string h representing multi-qubits Pauli matrices summation into its numerical form.\n\nExamples\n\njulia> q_translate(\"X+2.0Z\")\n2√ó2 Array{Complex{Float64},2}:\n 2.0+0.0im   1.0+0.0im\n 1.0+0.0im  -2.0+0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.q_translate_state-Tuple{String}","page":"Base","title":"QTBase.q_translate_state","text":"q_translate_state(h::String; normal=false)\n\nConvert a string representation of quantum state to a vector. The keyword argument normal indicates whether to normalize the output vector. (Currently only '0' and '1' are supported)\n\nExamples\n\nSingle term:\n\njulia> q_translate_state(\"001\")\n8-element Array{Complex{Float64},1}:\n 0.0 + 0.0im\n 1.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n\nMultiple terms:\n\njulia> q_translate_state(\"(101)+(001)\", normal=true)\n8-element Array{Complex{Float64},1}:\n                0.0 + 0.0im\n 0.7071067811865475 + 0.0im\n                0.0 + 0.0im\n                0.0 + 0.0im\n                0.0 + 0.0im\n 0.7071067811865475 + 0.0im\n                0.0 + 0.0im\n                0.0 + 0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.single_clause-NTuple{4,Any}","page":"Base","title":"QTBase.single_clause","text":"single_clause(ops, q_ind, weight, num_qubit; sp=false)\n\nConstruct a single clause of the multi-qubits Hamiltonian. ops is a list of Pauli operator names which appears in this clause. q_ind is the list of indices corresponding to the Pauli matrices in ops. weight is the constant factor of this clause. num_qubit is the total number of qubits. A sparse matrix can be construct by setting sp to true. The following example construct a clause of Z_1 I Z_32.\n\nExamples\n\njulia> single_clause([\"z\", \"z\"], [1, 3], 0.5, 3)\n8√ó8 Array{Complex{Float64},2}:\n 0.5+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im\n 0.0+0.0im  -0.5+0.0im  0.0+0.0im  -0.0+0.0im   0.0+0.0im  -0.0+0.0im   0.0+0.0im  -0.0+0.0im\n 0.0+0.0im   0.0+0.0im  0.5+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im   0.0+0.0im\n 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -0.5+0.0im   0.0+0.0im  -0.0+0.0im   0.0+0.0im  -0.0+0.0im\n 0.0+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im  -0.5+0.0im  -0.0+0.0im  -0.0+0.0im  -0.0+0.0im\n 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -0.0+0.0im  -0.0+0.0im   0.5-0.0im  -0.0+0.0im   0.0-0.0im\n 0.0+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im  -0.0+0.0im  -0.0+0.0im  -0.5+0.0im  -0.0+0.0im\n 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -0.0+0.0im  -0.0+0.0im   0.0-0.0im  -0.0+0.0im   0.5-0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.standard_driver-Tuple{Any}","page":"Base","title":"QTBase.standard_driver","text":"standard_driver(num_qubit; sp=false)\n\nConstruct the standard driver Hamiltonian for a system of num_qubit qubits. For example, a two qubits standard driver matrix is IX + XI. Generate sparse matrix when sp is set to true.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.temperature_2_freq-Tuple{Any}","page":"Base","title":"QTBase.temperature_2_freq","text":"temperature_2_freq(T)\n\nConvert temperature from mK to GHz.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.temperature_2_Œ≤-Tuple{Any}","page":"Base","title":"QTBase.temperature_2_Œ≤","text":" temperature_2_Œ≤(T)\n\nConvert physical temperature T in mK to thermodynamic Œ≤ in the unit of inverse angular frequency, that is to say Œ≤ = ƒßkT.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.two_local_term-Tuple{Any,Any,Any}","page":"Base","title":"QTBase.two_local_term","text":"two_local_term(j, idx, num_qubit; sp=false)\n\nConstruct local Hamiltonian of the form J·µ¢‚±ºœÉ·µ¢·∂ªœÉ‚±º·∂ª. idx is the index of all two local terms and j is a list of the corresponding weights. num_qubit is the total number of qubits. Generate sparse matrix when sp is set to true.\n\nExamples\n\njulia> two_local_term([1.0, 0.5], [[1,2], [1,3]], 3) == œÉz‚äóœÉz‚äóœÉi + 0.5œÉz‚äóœÉi‚äóœÉz\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.Œ≤_2_temperature-Tuple{Any}","page":"Base","title":"QTBase.Œ≤_2_temperature","text":"Œ≤_2_temperature(Œ≤)\n\nConvert thermodynamic Œ≤ in the unit of inverse angular frequency to physical temperature T in GHz.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.Œ≥-Tuple{Any,OhmicBath}","page":"Base","title":"QTBase.Œ≥","text":"Œ≥(œâ, params)\n\n\nCalculate Ohmic spectrum density, defined as a full Fourier transform on the bath correlation function.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.œÑ_B-Tuple{Any,Any,Any}","page":"Base","title":"QTBase.œÑ_B","text":"œÑ_B(cfun, lim, œÑsb; rtol, atol)\n\n\nCalculate the bath correlation time œÑ_B. The upper limit lim and œÑsb need to be manually specified. atol and rtol are the absolute and relative error for the integration.\n\n\n\n\n\n","category":"method"},{"location":"lib/QTBase/#QTBase.œÑ_SB-Tuple{Any}","page":"Base","title":"QTBase.œÑ_SB","text":"œÑ_SB(cfun; lim, rtol, atol)\n\n\nCalculate œÑ_SB from the bath correlation function cfun. It is defined as the integration of the absolute value of bath correlation function from zero to lim. The default value of lim is Inf. atol and rtol are the absolute and relative error of the integration.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/bath/#Bath","page":"Bath","title":"Bath","text":"","category":"section"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"We start with a general form of system bath interaction Hamiltonian","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"  H_SB = sum_alpha S_alphaotimes B_alpha","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"and define each B_alpha (together with the bath Hamiltonian H_B) as an AbstractBath object. An important metric for any bath is its two point correlation function","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"  C(t_1 t_2) = langle mathcalB(t_1) mathcalB(t_2) rangle","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"where","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"  mathcalB(t) = U_B^dagger (t) B U_B(t)","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"and U_B(t) is the unitary generated by the pure bath Hamiltonian","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"  U_B(t) = mathcalTexpBig -iint_0^t H_B mathrmdtau Big","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"The spectrum density of the bath is defined as the Fourier transform of the correlation function and is usually denoted as S(omega). It is important to notice that, only for Gaussian bath(or bath which satisfies the Wick Theorem) does the correlation function uniquely determine the bath. Otherwise, high order correlation functions may be necessary. Nevertheless, it is still an area of active research on how to experimentally measure those high order correlation functions. So in most occasions, only two point correlation function is available to us and we treat the noise as Gaussian.","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"Currently, there are two build-in concrete types of the AbstractBath class ‚Äì OhmicBath and HybridOhmicBath. More examples can be found in this notebook.","category":"page"},{"location":"tutorials/bath/#Ohmic-Bath","page":"Bath","title":"Ohmic Bath","text":"","category":"section"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"A self-consistent reference for Ohmic bath is Albash, Tameem, et al. We can use Ohmic function to construct OhmicBath object","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"Œ∑ = 1e-4; fc=4; T=16\nbath = Ohmic(Œ∑, fc, T);","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"The correlation and spectrum function of the bath object can be calculated by","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"correlation(œÑ, bath)\nspectrum(œâ, bath)","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"This interface is true for every concrete type of AbstractBath. However, the plotting system works differently for different bath models. For OhmicBath, you can use","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"œâ = range(0, 20, length=200)\nplot(bath, :Œ≥, œâ)\nplot(bath, :S, œâ)","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"to conveniently plot the spectrum and lamb shift.","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"(Image: plot_ohmic_spectrum) (Image: plot_ohmic_lamb)","category":"page"},{"location":"tutorials/bath/#Hybrid-Ohmic-Bath","page":"Bath","title":"Hybrid Ohmic Bath","text":"","category":"section"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"A good reference paper for the hybrid ohmic bath model is Lanting et al. The model is generalized in Smirnov and Amin. The basic idea is, the noise spectrum of this bath model can be split into the low frequency and high frequency parts","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"  S(omega) = S^L(œâ) + S^H(œâ)","category":"page"},{"location":"tutorials/bath/","page":"Bath","title":"Bath","text":"The high frequency part of the bath is the Ohmic and the low frequency part can be something like the 1f noise. The benefit of this formalism is that, instead of the entire spectrum density, S^L(omega) can be parametrized by a single parameter in the macroscopic resonant tunneling(MRT) experiment.","category":"page"},{"location":"#HOME","page":"Home","title":"HOME","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is a quantum annealing toolbox for Julia programming language.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package is written in Julia programming language. To learn more about Julia, please check its excellent doc pages. If you want to learn more about quantum annealing/adiabatic quantum computing, this review paper is a good place to start.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package has a core component package QTBase.jl, both of which are currently unregistered. To install, just run the following command inside the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(PackageSpec(url=\"https://github.com/USCqserver/QTBase.jl\", rev=\"master\"))\nPkg.add(PackageSpec(url=\"https://github.com/USCqserver/QuantumAnnealingTools.jl\", rev=\"master\"))","category":"page"},{"location":"","page":"Home","title":"Home","text":"It will install the packages directly from their github repos. This can also be done in Julia's Pkg REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(1.2) pkg> add https://github.com/USCqserver/QTBase.jl\n(1.2) pkg> add https://github.com/USCqserver/QuantumAnnealingTools.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"More information about Julia's package manager can be found at Pkg.jl.","category":"page"},{"location":"#Useful-Packages","page":"Home","title":"Useful Packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"It is recommended to install the following external packages:  ","category":"page"},{"location":"#[Plots.jl](https://github.com/JuliaPlots/Plots.jl)","page":"Home","title":"Plots.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Plots is a visualization interface and toolset for Julia. QuantumAnnealingTools.jl provides several plotting functionality by recipes to Plots.jl.","category":"page"},{"location":"#[DifferentialEquations.jl](http://docs.juliadiffeq.org/latest/)","page":"Home","title":"DifferentialEquations.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Even though QuantumAnnealingTools.jl can function without DifferentialEquations.jl, it needs to be loaded in order for the master equation solvers to work properly. For low dependency usage, replacing DifferentialEquations by OrdinaryDiffEq.jl will also work.","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In the first example, we solve a standard single qubit annealing problem with Hamiltonian","category":"page"},{"location":"","page":"Home","title":"Home","text":"    H(s) = A(s)œÉ_x + B(s)œÉ_z","category":"page"},{"location":"","page":"Home","title":"Home","text":"where A(s)=1-s and B(s)=s are usually known as annealing schedules. The general workflow is to define the Hamiltonian, construct the annealing process and then solve the system dynamics. The full code for this example is","category":"page"},{"location":"","page":"Home","title":"Home","text":"using QuantumAnnealingTools\nusing DifferentialEquations\ntf = 20\nu0 = PauliVec[1][2]\nH = DenseHamiltonian([(s)->1-s, (s)->s], [œÉx, œÉz], unit=:ƒß)\nannealing = Annealing(H, u0)\nsol = solve_schrodinger(annealing, tf)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where the pieces are explained below.","category":"page"},{"location":"","page":"Home","title":"Home","text":"First, we need to load the package DifferentialEquations.jl for ODE solvers. Then we define the Hamiltonian of the annealing process. In this package, a time dependent Hamiltonian can be specified by a list of time dependent functions and a list of constant matrices","category":"page"},{"location":"","page":"Home","title":"Home","text":"H = DenseHamiltonian([(s)->1-s, (s)->s], [œÉx, œÉz], unit=:ƒß)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The resulting Hamiltonian is an affine combination of the corresponding functions and matrices (1-s)œÉ_x + sœÉ_z. Then we define the initial state u0. Together with Hamiltonian, an annealing object can be constructed","category":"page"},{"location":"","page":"Home","title":"Home","text":"annealing = Annealing(H, u0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The final step is to solve system dynamics. In this example, directly solve the Schrodinger equation for a total annealing time tf.","category":"page"},{"location":"#Tutorials","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following tutorials will introduce you to the functionality of QuantumAnnealingTools.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"tutorials/math_symbol.md\",\n    \"tutorials/hamiltonians.md\",\n    \"tutorials/couplings.md\",\n    \"tutorials/bath.md\",\n    \"tutorials/annealing.md\"\n    ]\nDepth = 1","category":"page"},{"location":"lib/bath/#Bath-Module","page":"Bath","title":"Bath Module","text":"","category":"section"},{"location":"lib/bath/#Ohmic-Bath-Object","page":"Bath","title":"Ohmic Bath Object","text":"","category":"section"},{"location":"lib/bath/","page":"Bath","title":"Bath","text":"OhmicBath\nOhmic(Œ∑, fc, T)\ncorrelation(œÑ, params::OhmicBath)\npolaron_correlation(œÑ, a, params::OhmicBath)\nŒ≥(w, params::OhmicBath)\nS(w, params::OhmicBath; atol=1e-7)\ninterpolate_spectral_density(œâ_grid::AbstractRange{T}, params::OhmicBath) where T<:Number","category":"page"},{"location":"lib/bath/#Hybrid-Ohmic-Bath","page":"Bath","title":"Hybrid Ohmic Bath","text":"","category":"section"},{"location":"lib/bath/","page":"Bath","title":"Bath","text":"HybridOhmicBath\nHybridOhmic(W, Œ∑, fc, T)\npolaron_correlation(œÑ, bath::HybridOhmicBath, a=1)\nG‚Çï(œâ, bath::HybridOhmicBath, a=1)\nG‚Çó(œâ, bath::HybridOhmicBath, a=1)","category":"page"}]
}
